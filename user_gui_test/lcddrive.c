/****************************************************************************************
* 文件名：LCDDRIVE.C
* 功能：图形液晶240*128驱动(型号为SMG240128A)。32K显示存，0000H-7FFFH地址。显示是横向字节，
* 高位在前。
* 说明：图形液晶采用T6963C为LCD控制芯片，内带负压产生器，单5伏供电，并行接口(使用LPC2210驱动)。
* 硬件连接：D0--D7  <===>  AD0--AD7
*           /WR     <===>  WR
*           /RD     <===>  RD
*           /CE     <===>  !A15
*           C/D     <===>  A0
*
*           /RST    <===>  VCC
****************************************************************************************/
#include "config.h"

TCOLOR  gui_disp_buf[GUI_LCM_YMAX][GUI_LCM_XMAX/8];			/* 声明GUI显示缓冲区 */

/* 定义LCM地址 */
#define Bank1_LCD_D1    ((uint32_t)0x6C000002)    //Disp Data ADDR
#define Bank1_LCD_C1    ((uint32_t)0x6C000000)	  //Disp Reg ADDR

/***********************************************************************
* 名称：LCD_WriteCommand()
* 功能：写命令子程序。(发送命令前，不检查液晶模块的状态)
* 入口参数：command  	要写入LCM的命令字
* 出口参数：无
* 说明：函数会设置LCM数据总线为输出方式
***********************************************************************/
#define  LCD_WriteCommand(command)  *(__IO uint16_t *) (Bank1_LCD_C1) = command


/***********************************************************************
* 名称：LCD_WriteData()
* 功能：写数据子程序。(发送数据前，不检查液晶模块的状态)
* 入口参数：dat  	要写入LCM的数据
* 出口参数：无
* 说明：函数会设置LCM数据总线为输出方式
***********************************************************************/
#define  LCD_WriteData(dat)  *(__IO uint16_t *) (Bank1_LCD_D1) = dat



/***********************************************************************
* 名称：LCD_ReadState()
* 功能：读取状态字子程序。
* 入口参数：无
* 出口参数：返回值即为读出的状态字
* 说明：函数会设置LCM数据总线为输入方式
***********************************************************************/
#define  LCD_ReadState()	Bank1_LCD_C1


/***********************************************************************
* 名称：LCD_ReadData()
* 功能：读取数据子程序。
* 入口参数：无
* 出口参数：返回值即为读出的数据
* 说明：函数会设置LCM数据总线为输入方式
***********************************************************************/
#define  LCD_ReadData()		Bank1_LCD_D1




/***********************************************************************
* 名称：LCD_TestStaBit01()
* 功能：判断读写指令和读写数据是否允许。
* 入口参数：无
* 出口参数：返回0表示禁止，否则表示允许
***********************************************************************/

/***********************************************************************
* 名称：LCD_TestStaBit3()
* 功能：数据自动写状态是否允许。
* 入口参数：无
* 出口参数：返回0表示禁止，否则表示允许
***********************************************************************/


/***********************************************************************
* 名称：LCD_WriteTCommand1()
* 功能：写无参数命令子程序。会先判断LCM状态字。
* 入口参数：command  		要写入LCM的命令字
* 出口参数：操作出错返回0，否则返回1
***********************************************************************/


/***********************************************************************
* 名称：LCD_WriteTCommand3()
* 功能：写双参数命令子程序。会先判断LCM状态字。
* 入口参数：command  	要写入LCM的命令字
*          	dat1		参数1
*          	dat2		参数2
* 出口参数：操作出错返回0，否则返回1
* 说明：先发送两字节参数据数据，再发送命令字
***********************************************************************/


/***********************************************************************
* 名称：LCD_WriteTCommand2()
* 功能：写单参数命令子程序。会先判断LCM状态字。
* 入口参数：command  	要写入LCM的命令字
*          	dat1		参数1
* 出口参数：操作出错返回0，否则返回1
* 说明：先发送参数据数据，再发送命令字
***********************************************************************/

/***********************************************************************
* 名称：LCD_WriteTData1()
* 功能：写1字节数据子程序。会先判断状态字。
* 入口参数：dat  		要写入LCM的数据
* 出口参数：操作出错返回0，否则返回1
***********************************************************************/





/* 以下为LCM的用户接口层，主要负责解释用户命令，并发送到LCM，为用户编程提供接口 */

/***********************************************************************
* 名称：LCD_FillAll()
* 功能：LCD填充。以图形方式进行填充，起始地址为0x0000。
* 入口参数：dat		要填充的数据
* 出口参数：无
***********************************************************************/
void  LCD_FillAll(uint16_t dat)
{  
	uint32_t temp;
	BlockWrite(0,0,X_SIZE,Y_SIZE);
	for (temp=0; temp<X_SIZE*Y_SIZE; temp++)
	*(__IO uint16_t *) (Bank1_LCD_D) = dat;

	
}





/****************************************************************************
*                    与LCM相关的GUI接口函数
****************************************************************************/


/****************************************************************************
* 名称：GUI_FillSCR()
* 功能：全屏填充。直接使用数据填充显示缓冲区。
* 入口参数：dat		填充的数据(对于黑白色LCM，为0的点灭，为1的点显示)
* 出口参数：无
****************************************************************************/
void  GUI_FillSCR(uint16_t dat)
{  
	uint32_t temp;
	BlockWrite(0,0,X_SIZE,Y_SIZE);
	for (temp=0; temp<X_SIZE*Y_SIZE; temp++)
	*(__IO uint16_t *) (Bank1_LCD_D) = dat;
}


/****************************************************************************
* 名称：GUI_Initialize()
* 功能：初始化GUI，包括初始化显示缓冲区，初始化LCM并清屏。
* 入口参数：无
* 出口参数：无
****************************************************************************/
void  GUI_Initialize(void)
{  
	Lcd_Initialize();				// 初始化LCM模块工作模式，纯图形模式
    GUI_FillSCR(0x00);					// 初始化缓冲区为0x00，并输出屏幕(清屏)
} 


/****************************************************************************
* 名称：GUI_ClearSCR()
* 功能：清屏。
* 入口参数：无
* 出口参数：无
* 说明：用户根据LCM的实际情况编写此函数。
****************************************************************************/
void  GUI_ClearSCR(void)
{  
	GUI_FillSCR(0x00);
}



/****************************************************************************
* 名称：GUI_Point()
* 功能：在指定位置上画点。
* 入口参数： x		指定点所在列的位置
*           y		指定点所在行的位置
*           color	显示颜色(对于黑白色LCM，为0时灭，为1时显示)
* 出口参数：返回值为1时表示操作成功，为0时表示操作失败。(操作失败原因是指定地址超出有
*          效范围)
* 说明：用户根据LCM的实际情况编写此函数。对于单色，只有一个位有效，则要使用左移的方法
*      实现point_dat = (point_dat&MASK_TAB [i]) | (color<<n)，其它位数的一样
*      处理。
****************************************************************************/
uint8  GUI_Point(uint32 x, uint32 y, TCOLOR color)
{  
	BlockWrite(x,x,y,y);
	*(__IO uint16_t *) (Bank1_LCD_D) = color;
	return(1);
}

/****************************************************************************
* 名称：GUI_ReadPoint()
* 功能：读取指定点的颜色。
* 入口参数：x			指定点所在列的位置
*          y		指定点所在行的位置
*          ret		保存颜色值的指针
* 出口参数：返回0时表示指定地址超出有效范围。
* 说明：对于单色，设置ret的d0位为1或0，4级灰度则为d0、d1有效，8位RGB则d0--d7有效，
*      RGB结构则R、G、B变量有效。
****************************************************************************/
int  GUI_ReadPoint(uint32 x, uint32 y, TCOLOR *ret)
{  
   *ret = GetPoint(x,y);
   return(1);
}


/****************************************************************************
* 名称：GUI_HLine()
* 功能：画水平线。
* 入口参数： x0		水平线起点所在列的位置
*           y0		水平线起点所在行的位置
*           x1      水平线终点所在列的位置
*           color	显示颜色(对于黑白色LCM，为0时灭，为1时显示)
* 出口参数：无
* 说明：操作失败原因是指定地址超出缓冲区范围。
****************************************************************************/
void  GUI_HLine(uint32 x0, uint32 y0, uint32 x1, uint16 color) 
{  
	uint32_t i;
	BlockWrite(x0,x1,y0,y0);
	for(i = 0; i < (x0 + x1 -1) ;i++)
	*(__IO uint16_t *) (Bank1_LCD_D) = color;
}


/****************************************************************************
* 名称：GUI_RLine()
* 功能：画垂直线。
* 入口参数： x0		垂直线起点所在列的位置
*           y0		垂直线起点所在行的位置
*           y1      垂直线终点所在行的位置
*           color	显示颜色(对于黑白色LCM，为0时灭，为1时显示)
* 出口参数：无
* 说明：操作失败原因是指定地址超出缓冲区范围。
****************************************************************************/
void  GUI_RLine(uint32 x0, uint32 y0, uint32 y1, uint16 color) 
{  
	uint32_t i;
	BlockWrite(x0,x0,y0,y1);
	for(i = 0; i < (y0 + y1 -1) ;i++)
	*(__IO uint16_t *) (Bank1_LCD_D) = color;

}






















