; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\output\drv_fram.o --asm_dir=.\Listing\ --list_dir=.\Listing\ --depend=.\output\drv_fram.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x -I..\bsp_lib -I..\UCOSII\port -I..\UCOSII\src -I..\UCOSII\uC-CPU -I..\Libraries\CMSIS -I..\User\INCLUDES -I..\LCD -I..\USR\Global -I..\USR -I..\USR\FSM -I..\USR\Commucation -I..\USR\Mdb -I..\USR\Drop -I..\USR\DriverBoard -I..\USR\Flash -I..\USR\Card -I..\USR\MSG -I..\USR\Bsp -I..\USR\SetPar -I..\User\QRCode -I..\USR\MEM -I..\USR\QRCode -I..\USR\SETUP -I..\USR\stm32 -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -IC:\Keil_v5\ARM\INC\ST\STM32F10x -D__MICROLIB -D__UVISION_VERSION=525 -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER --omf_browse=.\output\drv_fram.crf ..\USR\DriverBoard\drv_fram.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  apply_driverboard_msg PROC
;;;34     */
;;;35     uint8_t apply_driverboard_msg(uint8_t cmd, uint8_t addr, uint8_t channel, uint16_t extend, uint8_t *dat)
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;36     {
000004  4607              MOV      r7,r0
000006  4688              MOV      r8,r1
000008  4691              MOV      r9,r2
00000a  461e              MOV      r6,r3
00000c  f8dda028          LDR      r10,[sp,#0x28]
;;;37     	DRV_MSG *drvmsg = 0;
000010  2400              MOVS     r4,#0
;;;38     	uint8_t err,i;
;;;39     	
;;;40     	drvmsg = (DRV_MSG*)_malloc(sizeof(DRV_MSG), &err);
000012  4669              MOV      r1,sp
000014  200c              MOVS     r0,#0xc
000016  f7fffffe          BL       _malloc
00001a  4604              MOV      r4,r0
;;;41     	drvmsg->dat = 0;//防止野指针
00001c  2000              MOVS     r0,#0
00001e  60a0              STR      r0,[r4,#8]
;;;42     	log_output(drvmsg);
;;;43     	
;;;44     	if(drvmsg)//申请到内存
000020  b344              CBZ      r4,|L1.116|
;;;45     	{
;;;46     		drvmsg->cmd = cmd;
000022  70a7              STRB     r7,[r4,#2]
;;;47     		drvmsg->id = addr;
000024  f8848000          STRB     r8,[r4,#0]
;;;48     		drvmsg->channel = channel;
000028  f8849001          STRB     r9,[r4,#1]
;;;49     		drvmsg->dat = 0;//防止野指针
00002c  60a0              STR      r0,[r4,#8]
;;;50     		if(extend)//申请额外数据空间
00002e  b196              CBZ      r6,|L1.86|
;;;51     		{
;;;52     			drvmsg->dat = _malloc(extend, &err);
000030  4669              MOV      r1,sp
000032  4630              MOV      r0,r6
000034  f7fffffe          BL       _malloc
000038  60a0              STR      r0,[r4,#8]
;;;53     			log_output(drvmsg->dat);
;;;54     			if(drvmsg->dat)
00003a  68a0              LDR      r0,[r4,#8]
00003c  b158              CBZ      r0,|L1.86|
;;;55     			{
;;;56     				drvmsg->extend = extend;
00003e  80a6              STRH     r6,[r4,#4]
;;;57     				for(i = 0; i < drvmsg->extend; i++)
000040  2500              MOVS     r5,#0
000042  e005              B        |L1.80|
                  |L1.68|
;;;58     				drvmsg->dat[i] = dat[i];
000044  f81a0005          LDRB     r0,[r10,r5]
000048  68a1              LDR      r1,[r4,#8]
00004a  5548              STRB     r0,[r1,r5]
00004c  1c68              ADDS     r0,r5,#1              ;57
00004e  b2c5              UXTB     r5,r0                 ;57
                  |L1.80|
000050  88a0              LDRH     r0,[r4,#4]            ;57
000052  42a8              CMP      r0,r5                 ;57
000054  dcf6              BGT      |L1.68|
                  |L1.86|
;;;59     			}
;;;60     		}
;;;61     		//发送到队列
;;;62     		if(OSQPost(driverQueen, drvmsg))//没发送成功
000056  4621              MOV      r1,r4
000058  48c4              LDR      r0,|L1.876|
00005a  6800              LDR      r0,[r0,#0]  ; driverQueen
00005c  f7fffffe          BL       OSQPost
000060  b150              CBZ      r0,|L1.120|
;;;63     		{
;;;64     			_free(drvmsg->dat);
000062  68a0              LDR      r0,[r4,#8]
000064  f7fffffe          BL       _free
;;;65     			_free(drvmsg);
000068  4620              MOV      r0,r4
00006a  f7fffffe          BL       _free
;;;66     			return 2;
00006e  2002              MOVS     r0,#2
                  |L1.112|
;;;67     		}
;;;68     	}
;;;69     	else
;;;70     		return FALSE;
;;;71     	return TRUE;
;;;72     }
000070  e8bd8ff8          POP      {r3-r11,pc}
                  |L1.116|
000074  2000              MOVS     r0,#0                 ;70
000076  e7fb              B        |L1.112|
                  |L1.120|
000078  2001              MOVS     r0,#1                 ;71
00007a  e7f9              B        |L1.112|
;;;73     
                          ENDP

                  release_drv_msg PROC
;;;76     */
;;;77     static void release_drv_msg(DRV_MSG *drvMsg){
00007c  b510              PUSH     {r4,lr}
00007e  4604              MOV      r4,r0
;;;78     	//释放驱动板消息内存
;;;79     	_free(drvMsg->dat);
000080  68a0              LDR      r0,[r4,#8]
000082  f7fffffe          BL       _free
;;;80     	_free(drvMsg);
000086  4620              MOV      r0,r4
000088  f7fffffe          BL       _free
;;;81     }
00008c  bd10              POP      {r4,pc}
;;;82     
                          ENDP

                  drv_init PROC
;;;86     */
;;;87     static void drv_init(void)
00008e  b538              PUSH     {r3-r5,lr}
;;;88     {
;;;89     	//读设置，观察是多少个驱动板
;;;90     	
;;;91     	uint8_t i,j,err;
;;;92     	if(g_vm.maxContainerNum == 0 || g_vm.maxContainerNum >10)
000090  48b7              LDR      r0,|L1.880|
000092  7c00              LDRB     r0,[r0,#0x10]  ; g_vm
000094  b118              CBZ      r0,|L1.158|
000096  48b6              LDR      r0,|L1.880|
000098  7c00              LDRB     r0,[r0,#0x10]  ; g_vm
00009a  280a              CMP      r0,#0xa
00009c  dd02              BLE      |L1.164|
                  |L1.158|
;;;93     		g_vm.maxContainerNum = 1; 
00009e  2001              MOVS     r0,#1
0000a0  49b3              LDR      r1,|L1.880|
0000a2  7408              STRB     r0,[r1,#0x10]
                  |L1.164|
;;;94     	//驱动板申请内存
;;;95     	for(i = 0;i < g_vm.maxContainerNum; i++)
0000a4  2400              MOVS     r4,#0
0000a6  e04d              B        |L1.324|
                  |L1.168|
;;;96     	{
;;;97     		pt_driverBoard[i] = 0;
0000a8  2000              MOVS     r0,#0
0000aa  49b2              LDR      r1,|L1.884|
0000ac  f8410024          STR      r0,[r1,r4,LSL #2]
;;;98     		pt_driverBoard[i] = _malloc(sizeof(DRIVERBOARD),&err); 
0000b0  4669              MOV      r1,sp
0000b2  2078              MOVS     r0,#0x78
0000b4  f7fffffe          BL       _malloc
0000b8  49ae              LDR      r1,|L1.884|
0000ba  f8410024          STR      r0,[r1,r4,LSL #2]
;;;99     		for(j = 0; j < 80; j++)
0000be  2500              MOVS     r5,#0
0000c0  e007              B        |L1.210|
                  |L1.194|
;;;100    		{
;;;101    			pt_driverBoard[i]->channelState[j] = 6;//初始化为未安装电机
0000c2  2106              MOVS     r1,#6
0000c4  48ab              LDR      r0,|L1.884|
0000c6  f8500024          LDR      r0,[r0,r4,LSL #2]
0000ca  1dc0              ADDS     r0,r0,#7
0000cc  5541              STRB     r1,[r0,r5]
0000ce  1c68              ADDS     r0,r5,#1              ;99
0000d0  b2c5              UXTB     r5,r0                 ;99
                  |L1.210|
0000d2  2d50              CMP      r5,#0x50              ;99
0000d4  dbf5              BLT      |L1.194|
;;;102    		}
;;;103    		for(j = 0; j < 6; j++)
0000d6  2500              MOVS     r5,#0
0000d8  e007              B        |L1.234|
                  |L1.218|
;;;104    		{
;;;105    			pt_driverBoard[i]->exState[i] = 0;
0000da  2100              MOVS     r1,#0
0000dc  48a5              LDR      r0,|L1.884|
0000de  f8500024          LDR      r0,[r0,r4,LSL #2]
0000e2  1c40              ADDS     r0,r0,#1
0000e4  5501              STRB     r1,[r0,r4]
0000e6  1c68              ADDS     r0,r5,#1              ;103
0000e8  b2c5              UXTB     r5,r0                 ;103
                  |L1.234|
0000ea  2d06              CMP      r5,#6                 ;103
0000ec  dbf5              BLT      |L1.218|
;;;106    		}
;;;107    		for(j = 0; j < 2; j++)
0000ee  2500              MOVS     r5,#0
0000f0  e00d              B        |L1.270|
                  |L1.242|
;;;108    		{
;;;109    			pt_driverBoard[i]->temp.state[j] = 0;
0000f2  2100              MOVS     r1,#0
0000f4  489f              LDR      r0,|L1.884|
0000f6  f8500024          LDR      r0,[r0,r4,LSL #2]
0000fa  3064              ADDS     r0,r0,#0x64
0000fc  5541              STRB     r1,[r0,r5]
;;;110    			pt_driverBoard[i]->temp.value[j] = 0;
0000fe  489d              LDR      r0,|L1.884|
000100  f8500024          LDR      r0,[r0,r4,LSL #2]
000104  3068              ADDS     r0,r0,#0x68
000106  f8401025          STR      r1,[r0,r5,LSL #2]
00010a  1c68              ADDS     r0,r5,#1              ;107
00010c  b2c5              UXTB     r5,r0                 ;107
                  |L1.270|
00010e  2d02              CMP      r5,#2                 ;107
000110  dbef              BLT      |L1.242|
;;;111    		}
;;;112    		pt_driverBoard[i]->temp.stoptimer = 0;
000112  2100              MOVS     r1,#0
000114  4897              LDR      r0,|L1.884|
000116  f8500024          LDR      r0,[r0,r4,LSL #2]
00011a  f8801070          STRB     r1,[r0,#0x70]
;;;113    		pt_driverBoard[i]->state = INIT;//初始化状态
00011e  2002              MOVS     r0,#2
000120  4994              LDR      r1,|L1.884|
000122  f8511024          LDR      r1,[r1,r4,LSL #2]
000126  7008              STRB     r0,[r1,#0]
;;;114    
;;;115    		
;;;116    		//读这两个参数（并且立刻发送给驱动板保存）
;;;117    		pt_driverBoard[i]->overload.value = 0;
000128  2100              MOVS     r1,#0
00012a  4892              LDR      r0,|L1.884|
00012c  f8500024          LDR      r0,[r0,r4,LSL #2]
000130  f8801075          STRB     r1,[r0,#0x75]
;;;118    		pt_driverBoard[i]->overload.count = 0;
000134  2000              MOVS     r0,#0
000136  498f              LDR      r1,|L1.884|
000138  f8511024          LDR      r1,[r1,r4,LSL #2]
00013c  f8810074          STRB     r0,[r1,#0x74]
000140  1c60              ADDS     r0,r4,#1              ;95
000142  b2c4              UXTB     r4,r0                 ;95
                  |L1.324|
000144  488a              LDR      r0,|L1.880|
000146  7c00              LDRB     r0,[r0,#0x10]         ;95  ; g_vm
000148  42a0              CMP      r0,r4                 ;95
00014a  dcad              BGT      |L1.168|
;;;119    	}
;;;120    }
00014c  bd38              POP      {r3-r5,pc}
;;;121    
                          ENDP

                  drv_export_policy PROC
;;;125    */
;;;126    static void drv_export_policy(void)
00014e  b510              PUSH     {r4,lr}
;;;127    {
;;;128    	policy_tempeture();	//制冷策略
000150  f7fffffe          BL       policy_tempeture
;;;129    	policy_light();		//光照策略
000154  f7fffffe          BL       policy_light
;;;130    	policy_glass();		//玻璃加热
000158  f7fffffe          BL       policy_glass
;;;131    	policy_backup2();	//备用通道2
00015c  f7fffffe          BL       policy_backup2
;;;132    	//测试程序
;;;133    //		drv_cmd_openEX(0, EX_COLD);
;;;134    //		drv_cmd_openEX(0, EX_WIND);
;;;135    //		drv_cmd_openEX(0, EX_LIGHT);
;;;136    //		drv_cmd_openEX(0, EX_DISINFECT);
;;;137    //		drv_cmd_openEX(0, EX_BACKUP1);
;;;138    //		drv_cmd_openEX(0, EX_BACKUP2);
;;;139    
;;;140    
;;;141    }
000160  bd10              POP      {r4,pc}
;;;142    
                          ENDP

                  drv_reset PROC
;;;148    */
;;;149    static void drv_reset(void)
000162  b510              PUSH     {r4,lr}
;;;150    {
;;;151    	uint8_t i;
;;;152    	//复位所有驱动板
;;;153    	for(i = 0;i < g_vm.maxContainerNum; i++) 
000164  2400              MOVS     r4,#0
000166  e004              B        |L1.370|
                  |L1.360|
;;;154    	drv_cmd_channelResetall(i);
000168  4620              MOV      r0,r4
00016a  f7fffffe          BL       drv_cmd_channelResetall
00016e  1c60              ADDS     r0,r4,#1              ;153
000170  b2c4              UXTB     r4,r0                 ;153
                  |L1.370|
000172  487f              LDR      r0,|L1.880|
000174  7c00              LDRB     r0,[r0,#0x10]         ;153  ; g_vm
000176  42a0              CMP      r0,r4                 ;153
000178  dcf6              BGT      |L1.360|
;;;155    	
;;;156    }
00017a  bd10              POP      {r4,pc}
;;;157    /*
                          ENDP

                  drv_check PROC
;;;159    */
;;;160    static void drv_check(void)
00017c  b510              PUSH     {r4,lr}
;;;161    {
;;;162    	uint8_t i;
;;;163    	
;;;164    	//查询所有驱动板
;;;165    	for(i = 0; (i < g_vm.maxContainerNum) && (pt_driverBoard[i] != 0); i++)
00017e  2400              MOVS     r4,#0
000180  e019              B        |L1.438|
                  |L1.386|
;;;166    	{
;;;167    		drv_cmd_checkVER(i);	//查驱动板版本
000182  4620              MOV      r0,r4
000184  f7fffffe          BL       drv_cmd_checkVER
;;;168    		drv_cmd_channelCheckall(i);
000188  4620              MOV      r0,r4
00018a  f7fffffe          BL       drv_cmd_channelCheckall
;;;169    		drv_cmd_checkTemp(i, 0);//查询温度1
00018e  2100              MOVS     r1,#0
000190  4620              MOV      r0,r4
000192  f7fffffe          BL       drv_cmd_checkTemp
;;;170    		drv_cmd_checkTemp(i, 1);//查询温度2
000196  2101              MOVS     r1,#1
000198  4620              MOV      r0,r4
00019a  f7fffffe          BL       drv_cmd_checkTemp
;;;171    		drv_cmd_checkEX(i, EX_DISINFECT);
00019e  2103              MOVS     r1,#3
0001a0  4620              MOV      r0,r4
0001a2  f7fffffe          BL       drv_cmd_checkEX
;;;172    		drv_cmd_checkEX(i, EX_COLD);
0001a6  2100              MOVS     r1,#0
0001a8  4620              MOV      r0,r4
0001aa  f7fffffe          BL       drv_cmd_checkEX
;;;173    		drv_export_policy();//执行一次控制策略，加速设备开启速度
0001ae  f7fffffe          BL       drv_export_policy
0001b2  1c60              ADDS     r0,r4,#1              ;165
0001b4  b2c4              UXTB     r4,r0                 ;165
                  |L1.438|
0001b6  486e              LDR      r0,|L1.880|
0001b8  7c00              LDRB     r0,[r0,#0x10]         ;165  ; g_vm
0001ba  42a0              CMP      r0,r4                 ;165
0001bc  dd04              BLE      |L1.456|
0001be  486d              LDR      r0,|L1.884|
0001c0  f8500024          LDR      r0,[r0,r4,LSL #2]     ;165
0001c4  2800              CMP      r0,#0                 ;165
0001c6  d1dc              BNE      |L1.386|
                  |L1.456|
;;;174    	}
;;;175    }
0001c8  bd10              POP      {r4,pc}
;;;176    
                          ENDP

                  drv_task PROC
;;;179    */
;;;180    void drv_task(void)
0001ca  b508              PUSH     {r3,lr}
;;;181    {
;;;182    	uint8_t err, i;
;;;183    	uint32_t policyTimeout, tempReportTimeout;
;;;184    	DRV_MSG *cur_dmsg;
;;;185    	FSMMSG *to_fsm = 0;
0001cc  2400              MOVS     r4,#0
;;;186    	
;;;187    	drv_init();//初始化驱动板
0001ce  f7fffffe          BL       drv_init
;;;188    	drv_reset();//复位驱动板
0001d2  f7fffffe          BL       drv_reset
;;;189    	drv_check();//查所有驱动板信息
0001d6  f7fffffe          BL       drv_check
;;;190    	
;;;191    	driverQueen = OSQCreate(pt_drvMsg,DRIVER_QUEEN_SIZE);//驱动板主队列创建(此队列允许接收3条数据)
0001da  2102              MOVS     r1,#2
0001dc  4866              LDR      r0,|L1.888|
0001de  f7fffffe          BL       OSQCreate
0001e2  4962              LDR      r1,|L1.876|
0001e4  6008              STR      r0,[r1,#0]  ; driverQueen
;;;192    	policyTimeout = OSTimeGet();//记录当前时间
0001e6  f7fffffe          BL       OSTimeGet
0001ea  4607              MOV      r7,r0
;;;193    	tempReportTimeout = OSTimeGet();
0001ec  f7fffffe          BL       OSTimeGet
0001f0  4680              MOV      r8,r0
;;;194    	
;;;195    	while(1)
0001f2  e0b9              B        |L1.872|
                  |L1.500|
;;;196    	{
;;;197    		cur_dmsg = (DRV_MSG *) OSQPend(driverQueen, 10*OS_TICKS_PER_SEC ,&err);
0001f4  466a              MOV      r2,sp
0001f6  f2427110          MOV      r1,#0x2710
0001fa  485c              LDR      r0,|L1.876|
0001fc  6800              LDR      r0,[r0,#0]  ; driverQueen
0001fe  f7fffffe          BL       OSQPend
000202  4605              MOV      r5,r0
;;;198    		if(err == OS_NO_ERR)//有命令需要执行
000204  f89d0000          LDRB     r0,[sp,#0]
000208  2800              CMP      r0,#0
00020a  d175              BNE      |L1.760|
;;;199    		{
;;;200    			if(pt_driverBoard[cur_dmsg->id] != 0 )//当前驱动板指针不是空指针
00020c  7828              LDRB     r0,[r5,#0]
00020e  4959              LDR      r1,|L1.884|
000210  f8510020          LDR      r0,[r1,r0,LSL #2]
000214  2800              CMP      r0,#0
000216  d06b              BEQ      |L1.752|
;;;201    			{
;;;202    				if(pt_driverBoard[cur_dmsg->id]->state == 1 )//判断驱动板是否正常
000218  7828              LDRB     r0,[r5,#0]
00021a  f8510020          LDR      r0,[r1,r0,LSL #2]
00021e  7800              LDRB     r0,[r0,#0]
000220  2801              CMP      r0,#1
000222  d148              BNE      |L1.694|
;;;203    				{
;;;204    					switch(cur_dmsg->cmd)//判断命令类型，调用驱动函数
000224  78a8              LDRB     r0,[r5,#2]
000226  b120              CBZ      r0,|L1.562|
000228  2801              CMP      r0,#1
00022a  d018              BEQ      |L1.606|
00022c  2805              CMP      r0,#5
00022e  d141              BNE      |L1.692|
000230  e02b              B        |L1.650|
                  |L1.562|
;;;205    					{
;;;206    						case M_CHANNEL_SALE://出货指令
;;;207    							to_fsm = apply_fsm_msg(FSMMSG_SIZE_DEFAULT);
000232  2000              MOVS     r0,#0
000234  f7fffffe          BL       apply_fsm_msg
000238  4604              MOV      r4,r0
;;;208    						
;;;209    							log_output(to_fsm);
;;;210    						
;;;211    							to_fsm->type = MsgCHAN;
00023a  2006              MOVS     r0,#6
00023c  7020              STRB     r0,[r4,#0]
;;;212    							to_fsm->stype = M_CHANNEL_SALE;//要和上面类型对应
00023e  2000              MOVS     r0,#0
000240  7060              STRB     r0,[r4,#1]
;;;213    							to_fsm->value = drv_cmd_sale(cur_dmsg->id, cur_dmsg->channel);
000242  7869              LDRB     r1,[r5,#1]
000244  7828              LDRB     r0,[r5,#0]
000246  f7fffffe          BL       drv_cmd_sale
00024a  6060              STR      r0,[r4,#4]
;;;214    							if(send_fsm_msg(to_fsm) != TRUE)
00024c  4620              MOV      r0,r4
00024e  f7fffffe          BL       send_fsm_msg
000252  2801              CMP      r0,#1
000254  d002              BEQ      |L1.604|
;;;215    								release_fsm_msg(to_fsm);
000256  4620              MOV      r0,r4
000258  f7fffffe          BL       release_fsm_msg
                  |L1.604|
;;;216    						break;
00025c  e02a              B        |L1.692|
                  |L1.606|
;;;217    							
;;;218    						case M_CHANNEL_TEST://复位指令（电机测试）
;;;219    							to_fsm = apply_fsm_msg(FSMMSG_SIZE_DEFAULT);
00025e  2000              MOVS     r0,#0
000260  f7fffffe          BL       apply_fsm_msg
000264  4604              MOV      r4,r0
;;;220    						
;;;221    							log_output(to_fsm);
;;;222    						
;;;223    							to_fsm->type = MsgCHAN;
000266  2006              MOVS     r0,#6
000268  7020              STRB     r0,[r4,#0]
;;;224    							to_fsm->stype = M_CHANNEL_TEST;//要和上面类型对应
00026a  2001              MOVS     r0,#1
00026c  7060              STRB     r0,[r4,#1]
;;;225    							to_fsm->value = drv_cmd_channelReset(cur_dmsg->id, cur_dmsg->channel);
00026e  7869              LDRB     r1,[r5,#1]
000270  7828              LDRB     r0,[r5,#0]
000272  f7fffffe          BL       drv_cmd_channelReset
000276  6060              STR      r0,[r4,#4]
;;;226    							if(send_fsm_msg(to_fsm) != TRUE)
000278  4620              MOV      r0,r4
00027a  f7fffffe          BL       send_fsm_msg
00027e  2801              CMP      r0,#1
000280  d002              BEQ      |L1.648|
;;;227    								release_fsm_msg(to_fsm);
000282  4620              MOV      r0,r4
000284  f7fffffe          BL       release_fsm_msg
                  |L1.648|
;;;228    						break;
000288  e014              B        |L1.692|
                  |L1.650|
;;;229    							
;;;230    						case M_DRV_CHECK://整机查货道指令
;;;231    							to_fsm = apply_fsm_msg(FSMMSG_SIZE_DEFAULT);
00028a  2000              MOVS     r0,#0
00028c  f7fffffe          BL       apply_fsm_msg
000290  4604              MOV      r4,r0
;;;232    						
;;;233    							log_output(to_fsm);
;;;234    						
;;;235    							to_fsm->type = MsgCHAN;
000292  2006              MOVS     r0,#6
000294  7020              STRB     r0,[r4,#0]
;;;236    							to_fsm->stype = M_DRV_CHECK;//要和上面类型对应
000296  2005              MOVS     r0,#5
000298  7060              STRB     r0,[r4,#1]
;;;237    							to_fsm->value = drv_cmd_channelCheckall(cur_dmsg->id);
00029a  7828              LDRB     r0,[r5,#0]
00029c  f7fffffe          BL       drv_cmd_channelCheckall
0002a0  6060              STR      r0,[r4,#4]
;;;238    							if(send_fsm_msg(to_fsm) != TRUE)
0002a2  4620              MOV      r0,r4
0002a4  f7fffffe          BL       send_fsm_msg
0002a8  2801              CMP      r0,#1
0002aa  d002              BEQ      |L1.690|
;;;239    								release_fsm_msg(to_fsm);
0002ac  4620              MOV      r0,r4
0002ae  f7fffffe          BL       release_fsm_msg
                  |L1.690|
;;;240    						break;
0002b2  bf00              NOP      
                  |L1.692|
0002b4  e023              B        |L1.766|
                  |L1.694|
;;;241    						
;;;242    					}
;;;243    				}
;;;244    				else//驱动板故障
;;;245    				{
;;;246    					to_fsm = apply_fsm_msg(FSMMSG_SIZE_DEFAULT);
0002b6  2000              MOVS     r0,#0
0002b8  f7fffffe          BL       apply_fsm_msg
0002bc  4604              MOV      r4,r0
;;;247    				
;;;248    					log_output(to_fsm);
;;;249    				
;;;250    					to_fsm->type = MsgCHAN;
0002be  2006              MOVS     r0,#6
0002c0  7020              STRB     r0,[r4,#0]
;;;251    					to_fsm->stype = M_DRV_ERR;//驱动板故障
0002c2  200a              MOVS     r0,#0xa
0002c4  7060              STRB     r0,[r4,#1]
;;;252    					to_fsm->value = pt_driverBoard[cur_dmsg->id]->state;
0002c6  7828              LDRB     r0,[r5,#0]
0002c8  492a              LDR      r1,|L1.884|
0002ca  f8510020          LDR      r0,[r1,r0,LSL #2]
0002ce  7800              LDRB     r0,[r0,#0]
0002d0  6060              STR      r0,[r4,#4]
;;;253    					if(send_fsm_msg(to_fsm) != TRUE)
0002d2  4620              MOV      r0,r4
0002d4  f7fffffe          BL       send_fsm_msg
0002d8  2801              CMP      r0,#1
0002da  d002              BEQ      |L1.738|
;;;254    						release_fsm_msg(to_fsm);
0002dc  4620              MOV      r0,r4
0002de  f7fffffe          BL       release_fsm_msg
                  |L1.738|
;;;255    					
;;;256    					
;;;257    					//发送复位指令（驱动板增加一条指令，指针指向0，直接复位整个程序）
;;;258    					drv_cmd_checkTemp(0,0);
0002e2  2100              MOVS     r1,#0
0002e4  4608              MOV      r0,r1
0002e6  f7fffffe          BL       drv_cmd_checkTemp
0002ea  e008              B        |L1.766|
0002ec  e004              B        |L1.760|
0002ee  e7ff              B        |L1.752|
                  |L1.752|
;;;259    					
;;;260    				}
;;;261    			}
;;;262    			else//驱动板是空指针
;;;263    			{
;;;264    				//报致命错误
;;;265    				err = err;
0002f0  f89d0000          LDRB     r0,[sp,#0]
0002f4  9000              STR      r0,[sp,#0]
0002f6  e002              B        |L1.766|
                  |L1.760|
;;;266    			}
;;;267    		}
;;;268    		else//没有命令要执行
;;;269    		{
;;;270    			drv_cmd_checkVER(0);//查驱动板1版本号
0002f8  2000              MOVS     r0,#0
0002fa  f7fffffe          BL       drv_cmd_checkVER
                  |L1.766|
;;;271    		}
;;;272    		release_drv_msg(cur_dmsg);//释放驱动板消息内存
0002fe  4628              MOV      r0,r5
000300  f7fffffe          BL       release_drv_msg
;;;273    		
;;;274    		
;;;275    		/*
;;;276    		控制策略
;;;277    		*/
;;;278    		if((OSTimeGet() - policyTimeout > OS_TICKS_PER_SEC*10) || (OSTimeGet() < policyTimeout))//如果超过10s，运行一次回路控制策略
000304  f7fffffe          BL       OSTimeGet
000308  1bc0              SUBS     r0,r0,r7
00030a  f2427110          MOV      r1,#0x2710
00030e  4288              CMP      r0,r1
000310  d803              BHI      |L1.794|
000312  f7fffffe          BL       OSTimeGet
000316  42b8              CMP      r0,r7
000318  d226              BCS      |L1.872|
                  |L1.794|
;;;279    		{
;;;280    			drv_export_policy();
00031a  f7fffffe          BL       drv_export_policy
;;;281    			policyTimeout = OSTimeGet();//更新时间
00031e  f7fffffe          BL       OSTimeGet
000322  4607              MOV      r7,r0
;;;282    			
;;;283    			if(OSTimeGet() - tempReportTimeout >= OS_TICKS_PER_SEC*60*10)//10分钟发一条温度信息
000324  f7fffffe          BL       OSTimeGet
000328  eba00008          SUB      r0,r0,r8
00032c  4913              LDR      r1,|L1.892|
00032e  4288              CMP      r0,r1
000330  d31a              BCC      |L1.872|
;;;284    			{
;;;285    				tempReportTimeout = OSTimeGet();
000332  f7fffffe          BL       OSTimeGet
000336  4680              MOV      r8,r0
;;;286    				for(i = 0; i < g_vm.maxContainerNum; i++)
000338  2600              MOVS     r6,#0
00033a  e011              B        |L1.864|
                  |L1.828|
;;;287    				{
;;;288    					if(pt_driverBoard[i] != 0)
00033c  480d              LDR      r0,|L1.884|
00033e  f8500026          LDR      r0,[r0,r6,LSL #2]
000342  b158              CBZ      r0,|L1.860|
;;;289    					{
;;;290    						report_temp_value(i, pt_driverBoard[i]->temp.state[0], pt_driverBoard[i]->temp.value[0]);
000344  480b              LDR      r0,|L1.884|
000346  f8500026          LDR      r0,[r0,r6,LSL #2]
00034a  6e82              LDR      r2,[r0,#0x68]
00034c  4809              LDR      r0,|L1.884|
00034e  f8500026          LDR      r0,[r0,r6,LSL #2]
000352  f8901064          LDRB     r1,[r0,#0x64]
000356  4630              MOV      r0,r6
000358  f7fffffe          BL       report_temp_value
                  |L1.860|
00035c  1c70              ADDS     r0,r6,#1              ;286
00035e  b2c6              UXTB     r6,r0                 ;286
                  |L1.864|
000360  4803              LDR      r0,|L1.880|
000362  7c00              LDRB     r0,[r0,#0x10]         ;286  ; g_vm
000364  42b0              CMP      r0,r6                 ;286
000366  dce9              BGT      |L1.828|
                  |L1.872|
000368  e744              B        |L1.500|
;;;291    					}
;;;292    				}
;;;293    			}
;;;294    		}
;;;295    	}
;;;296    }
;;;297    
                          ENDP

00036a  0000              DCW      0x0000
                  |L1.876|
                          DCD      driverQueen
                  |L1.880|
                          DCD      g_vm
                  |L1.884|
                          DCD      pt_driverBoard
                  |L1.888|
                          DCD      pt_drvMsg
                  |L1.892|
                          DCD      0x000927c0

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  pt_driverBoard
                          %        40

                          AREA ||.data||, DATA, ALIGN=2

                  pt_drvMsg
                          %        8
                  driverQueen
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "..\\USR\\DriverBoard\\drv_fram.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___10_drv_fram_c_47e93acc____REV16|
#line 129 "C:\\Keil_v5\\ARM\\CMSIS\\Include\\core_cmInstr.h"
|__asm___10_drv_fram_c_47e93acc____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___10_drv_fram_c_47e93acc____REVSH|
#line 144
|__asm___10_drv_fram_c_47e93acc____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
