; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\output\bsp_commucation.o --asm_dir=.\Listing\ --list_dir=.\Listing\ --depend=.\output\bsp_commucation.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x -I..\bsp_lib -I..\UCOSII\port -I..\UCOSII\src -I..\UCOSII\uC-CPU -I..\Libraries\CMSIS -I..\User\INCLUDES -I..\LCD -I..\USR\Global -I..\USR -I..\USR\FSM -I..\USR\Commucation -I..\USR\Mdb -I..\USR\Drop -I..\USR\DriverBoard -I..\USR\Flash -I..\USR\Card -I..\USR\MSG -I..\USR\Bsp -I..\USR\SetPar -I..\User\QRCode -I..\USR\MEM -I..\USR\QRCode -I..\USR\SETUP -I..\USR\stm32 -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -IC:\Keil_v5\ARM\INC\ST\STM32F10x -D__MICROLIB -D__UVISION_VERSION=525 -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER --omf_browse=.\output\bsp_commucation.crf ..\USR\Bsp\bsp_commucation.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  usart3_config PROC
;;;18     */
;;;19     static void usart3_config(void)
000000  b500              PUSH     {lr}
;;;20     {
000002  b087              SUB      sp,sp,#0x1c
;;;21     	GPIO_InitTypeDef GPIO_InitStructure;	
;;;22     	USART_InitTypeDef USART_InitStructure;	 
;;;23     	NVIC_InitTypeDef NVIC_InitStructure;	
;;;24     
;;;25     	//使能引脚时钟，与复用功能时钟
;;;26     	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB | RCC_APB2Periph_AFIO ,  ENABLE );
000004  2101              MOVS     r1,#1
000006  2009              MOVS     r0,#9
000008  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;27     	RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART3 ,ENABLE);
00000c  2101              MOVS     r1,#1
00000e  0488              LSLS     r0,r1,#18
000010  f7fffffe          BL       RCC_APB1PeriphClockCmd
;;;28     
;;;29     	//TX 引脚
;;;30     	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;			//PB10
000014  f44f6080          MOV      r0,#0x400
000018  f8ad0018          STRH     r0,[sp,#0x18]
;;;31     	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;		//复用的推挽输出
00001c  2018              MOVS     r0,#0x18
00001e  f88d001b          STRB     r0,[sp,#0x1b]
;;;32     	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;		
000022  2003              MOVS     r0,#3
000024  f88d001a          STRB     r0,[sp,#0x1a]
;;;33     	GPIO_Init(GPIOB, &GPIO_InitStructure);
000028  a906              ADD      r1,sp,#0x18
00002a  48e6              LDR      r0,|L1.964|
00002c  f7fffffe          BL       GPIO_Init
;;;34         //RX 引脚
;;;35     	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_11;			//PB11
000030  f44f6000          MOV      r0,#0x800
000034  f8ad0018          STRH     r0,[sp,#0x18]
;;;36     	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;//浮空输入
000038  2004              MOVS     r0,#4
00003a  f88d001b          STRB     r0,[sp,#0x1b]
;;;37     	GPIO_Init(GPIOB, &GPIO_InitStructure);
00003e  a906              ADD      r1,sp,#0x18
000040  48e0              LDR      r0,|L1.964|
000042  f7fffffe          BL       GPIO_Init
;;;38     	//串口配置
;;;39     	USART_InitStructure.USART_BaudRate            = 115200  ;				//波特率
000046  f44f30e1          MOV      r0,#0x1c200
00004a  9002              STR      r0,[sp,#8]
;;;40     	USART_InitStructure.USART_WordLength          = USART_WordLength_8b;           	//8位数据
00004c  2000              MOVS     r0,#0
00004e  f8ad000c          STRH     r0,[sp,#0xc]
;;;41     	USART_InitStructure.USART_StopBits            = USART_StopBits_1;              	//1个停止位
000052  f8ad000e          STRH     r0,[sp,#0xe]
;;;42     	USART_InitStructure.USART_Parity              = USART_Parity_No ;              	//无奇偶检验
000056  f8ad0010          STRH     r0,[sp,#0x10]
;;;43     	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;	//禁用硬件流控制
00005a  f8ad0014          STRH     r0,[sp,#0x14]
;;;44     	USART_InitStructure.USART_Mode                = USART_Mode_Rx | USART_Mode_Tx;  //使能发送接收
00005e  200c              MOVS     r0,#0xc
000060  f8ad0012          STRH     r0,[sp,#0x12]
;;;45     	USART_Init(USART3, &USART_InitStructure);
000064  a902              ADD      r1,sp,#8
000066  48d8              LDR      r0,|L1.968|
000068  f7fffffe          BL       USART_Init
;;;46     	
;;;47     	
;;;48     	//串口中断配置
;;;49     //	USART_ITConfig(USART3,USART_IT_RXNE, ENABLE);          //使能接收中断
;;;50     	USART_ITConfig(USART3,USART_IT_ERR,ENABLE);				//使能错误中断
00006c  2201              MOVS     r2,#1
00006e  2160              MOVS     r1,#0x60
000070  48d5              LDR      r0,|L1.968|
000072  f7fffffe          BL       USART_ITConfig
;;;51     	
;;;52     	USART_ITConfig(USART3,USART_IT_IDLE,ENABLE );		//使能空闲中断(只要这个就行)
000076  2201              MOVS     r2,#1
000078  f2404124          MOV      r1,#0x424
00007c  48d2              LDR      r0,|L1.968|
00007e  f7fffffe          BL       USART_ITConfig
;;;53     //	USART_ITConfig(USART3, USART_IT_TC, ENABLE);                                  
;;;54     //	USART_ClearITPendingBit(USART3, USART_IT_RXNE);
;;;55     
;;;56     
;;;57     	
;;;58     //	USART_ClearFlag(USART3,USART_FLAG_RXNE); 
;;;59     	USART_ClearFlag(USART3,USART_FLAG_TC); 				//清发送完标志
000082  2140              MOVS     r1,#0x40
000084  48d0              LDR      r0,|L1.968|
000086  f7fffffe          BL       USART_ClearFlag
;;;60     
;;;61     	USART_Cmd(USART3, ENABLE);     	//使能uart1外设
00008a  2101              MOVS     r1,#1
00008c  48ce              LDR      r0,|L1.968|
00008e  f7fffffe          BL       USART_Cmd
;;;62     	
;;;63     	//=============================
;;;64     	//中断使能，对应到中断向量表
;;;65     	//=============================
;;;66     	NVIC_InitStructure.NVIC_IRQChannel = USART3_IRQn; 		                       	//USART3接收中断
000092  2027              MOVS     r0,#0x27
000094  f88d0004          STRB     r0,[sp,#4]
;;;67     	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1;                       //先占优先级
000098  2001              MOVS     r0,#1
00009a  f88d0005          STRB     r0,[sp,#5]
;;;68     	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 1;		                        //从优先级
00009e  f88d0006          STRB     r0,[sp,#6]
;;;69     	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;									//中断通道使能
0000a2  f88d0007          STRB     r0,[sp,#7]
;;;70     	NVIC_Init(&NVIC_InitStructure);
0000a6  a801              ADD      r0,sp,#4
0000a8  f7fffffe          BL       NVIC_Init
;;;71     }
0000ac  b007              ADD      sp,sp,#0x1c
0000ae  bd00              POP      {pc}
;;;72     
                          ENDP

                  uart3_dmaRecv_config PROC
;;;76     */
;;;77     static void uart3_dmaRecv_config(void)
0000b0  b500              PUSH     {lr}
;;;78     {
0000b2  b08d              SUB      sp,sp,#0x34
;;;79     	DMA_InitTypeDef DMA_InitStructure;
;;;80     	NVIC_InitTypeDef NVIC_InitStructure;				
;;;81     	
;;;82     	RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA1, ENABLE);	//DMA1 时钟打开
0000b4  2101              MOVS     r1,#1
0000b6  4608              MOV      r0,r1
0000b8  f7fffffe          BL       RCC_AHBPeriphClockCmd
;;;83     	
;;;84     	
;;;85     	DMA_DeInit(DMA1_Channel3); 
0000bc  48c3              LDR      r0,|L1.972|
0000be  f7fffffe          BL       DMA_DeInit
;;;86     	DMA_InitStructure.DMA_PeripheralBaseAddr = (uint32_t)(&USART3->DR);		//dr寄存器的地址· (0x40013804)
0000c2  48c1              LDR      r0,|L1.968|
0000c4  1d00              ADDS     r0,r0,#4
0000c6  9002              STR      r0,[sp,#8]
;;;87     	DMA_InitStructure.DMA_MemoryBaseAddr = (uint32_t)commucation_recv_buf;				//接收缓冲的地址
0000c8  48c1              LDR      r0,|L1.976|
0000ca  9003              STR      r0,[sp,#0xc]
;;;88     	DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralSRC;						//外设作为数据来源
0000cc  2000              MOVS     r0,#0
0000ce  9004              STR      r0,[sp,#0x10]
;;;89     	DMA_InitStructure.DMA_BufferSize = RX_LEN;
0000d0  f44f7080          MOV      r0,#0x100
0000d4  9005              STR      r0,[sp,#0x14]
;;;90     	DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;	//dma 不自增
0000d6  2000              MOVS     r0,#0
0000d8  9006              STR      r0,[sp,#0x18]
;;;91     	DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;				//内存自增
0000da  2080              MOVS     r0,#0x80
0000dc  9007              STR      r0,[sp,#0x1c]
;;;92     	DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_Byte;	//dma数据宽度（Byte宽）
0000de  2000              MOVS     r0,#0
0000e0  9008              STR      r0,[sp,#0x20]
;;;93     	DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_Byte;			//内存数据宽度
0000e2  9009              STR      r0,[sp,#0x24]
;;;94     	DMA_InitStructure.DMA_Mode = DMA_Mode_Normal;		//普通模式；非循环接收
0000e4  900a              STR      r0,[sp,#0x28]
;;;95     	DMA_InitStructure.DMA_Priority = DMA_Priority_High;	//DMA高优先级（DMA设备间的优先级）
0000e6  f44f5000          MOV      r0,#0x2000
0000ea  900b              STR      r0,[sp,#0x2c]
;;;96     	DMA_InitStructure.DMA_M2M = DMA_M2M_Disable;		//关闭内存到内存传输模式
0000ec  2000              MOVS     r0,#0
0000ee  900c              STR      r0,[sp,#0x30]
;;;97     	DMA_Init(DMA1_Channel3, &DMA_InitStructure);
0000f0  a902              ADD      r1,sp,#8
0000f2  48b6              LDR      r0,|L1.972|
0000f4  f7fffffe          BL       DMA_Init
;;;98     	
;;;99     	DMA_ClearFlag(DMA1_FLAG_GL1);       // 清除DMA所有标志   
0000f8  2001              MOVS     r0,#1
0000fa  f7fffffe          BL       DMA_ClearFlag
;;;100    	
;;;101    	/*
;;;102    	注意，这里并没有开DMA接收中断
;;;103    	*/
;;;104    //	DMA_ITConfig(DMA1_Channel3, DMA_IT_TC, ENABLE);//传输完成中断
;;;105    //	DMA_ITConfig(DMA1_Channel3, DMA_IT_TE, ENABLE);//传输错误中断
;;;106    	
;;;107    	/* Enable USART3 DMA TX request */
;;;108    	USART_DMACmd(USART3, USART_DMAReq_Rx, ENABLE);	//使能串口1的DMA接收
0000fe  2201              MOVS     r2,#1
000100  2140              MOVS     r1,#0x40
000102  48b1              LDR      r0,|L1.968|
000104  f7fffffe          BL       USART_DMACmd
;;;109    	USART_DMACmd(USART3, USART_DMAReq_Tx, ENABLE);	//使能串口1的DMA发送
000108  2201              MOVS     r2,#1
00010a  2180              MOVS     r1,#0x80
00010c  48ae              LDR      r0,|L1.968|
00010e  f7fffffe          BL       USART_DMACmd
;;;110    
;;;111    	DMA_Cmd(DMA1_Channel3, ENABLE);					//打开DMA1-5通道
000112  2101              MOVS     r1,#1
000114  48ad              LDR      r0,|L1.972|
000116  f7fffffe          BL       DMA_Cmd
;;;112    		
;;;113    	//=============================
;;;114    	//DMA中断设置
;;;115    	//=============================
;;;116    	NVIC_InitStructure.NVIC_IRQChannel = DMA1_Channel3_IRQn; 		                //中断通道
00011a  200d              MOVS     r0,#0xd
00011c  f88d0004          STRB     r0,[sp,#4]
;;;117    	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1;                       //抢占优先级
000120  2001              MOVS     r0,#1
000122  f88d0005          STRB     r0,[sp,#5]
;;;118    	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;		                        //从优先级
000126  2000              MOVS     r0,#0
000128  f88d0006          STRB     r0,[sp,#6]
;;;119    	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;									//中断使能
00012c  2001              MOVS     r0,#1
00012e  f88d0007          STRB     r0,[sp,#7]
;;;120    	NVIC_Init(&NVIC_InitStructure);
000132  a801              ADD      r0,sp,#4
000134  f7fffffe          BL       NVIC_Init
;;;121    
;;;122    }
000138  b00d              ADD      sp,sp,#0x34
00013a  bd00              POP      {pc}
;;;123    
                          ENDP

                  uart3_dmaSend_config PROC
;;;127    */
;;;128    void uart3_dmaSend_config(void)
00013c  b500              PUSH     {lr}
;;;129    {
00013e  b08d              SUB      sp,sp,#0x34
;;;130    	DMA_InitTypeDef DMA_InitStructure;
;;;131    	NVIC_InitTypeDef NVIC_InitStructure;				
;;;132    	
;;;133    	RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA1, ENABLE);	//DMA1 时钟打开
000140  2101              MOVS     r1,#1
000142  4608              MOV      r0,r1
000144  f7fffffe          BL       RCC_AHBPeriphClockCmd
;;;134    
;;;135    	DMA_DeInit(DMA1_Channel2); 
000148  48a0              LDR      r0,|L1.972|
00014a  3814              SUBS     r0,r0,#0x14
00014c  f7fffffe          BL       DMA_DeInit
;;;136    	DMA_InitStructure.DMA_PeripheralBaseAddr = (uint32_t)(&USART3->DR);
000150  489d              LDR      r0,|L1.968|
000152  1d00              ADDS     r0,r0,#4
000154  9002              STR      r0,[sp,#8]
;;;137    	DMA_InitStructure.DMA_MemoryBaseAddr = (uint32_t)commucation_send_buf;
000156  489f              LDR      r0,|L1.980|
000158  9003              STR      r0,[sp,#0xc]
;;;138    	DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralDST;				//外设作为数据目的地
00015a  2010              MOVS     r0,#0x10
00015c  9004              STR      r0,[sp,#0x10]
;;;139    	DMA_InitStructure.DMA_BufferSize = TX_LEN;							//DMA缓存大小
00015e  0100              LSLS     r0,r0,#4
000160  9005              STR      r0,[sp,#0x14]
;;;140    	DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;//DMA外设地址不自增
000162  2000              MOVS     r0,#0
000164  9006              STR      r0,[sp,#0x18]
;;;141    	DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;			//DMA内存地址自增
000166  2080              MOVS     r0,#0x80
000168  9007              STR      r0,[sp,#0x1c]
;;;142    	DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_Byte;//8bit 数据宽度，dma
00016a  2000              MOVS     r0,#0
00016c  9008              STR      r0,[sp,#0x20]
;;;143    	DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_Byte;	//8bit 数据宽度，内存
00016e  9009              STR      r0,[sp,#0x24]
;;;144    	DMA_InitStructure.DMA_Mode = DMA_Mode_Normal;					//发完一次就停
000170  900a              STR      r0,[sp,#0x28]
;;;145    	DMA_InitStructure.DMA_Priority = DMA_Priority_High;				//高优先级
000172  f44f5000          MOV      r0,#0x2000
000176  900b              STR      r0,[sp,#0x2c]
;;;146    	DMA_InitStructure.DMA_M2M = DMA_M2M_Disable;					//进制内存到内存
000178  2000              MOVS     r0,#0
00017a  900c              STR      r0,[sp,#0x30]
;;;147    	
;;;148    	DMA_Init(DMA1_Channel2, &DMA_InitStructure);					//配置寄存器
00017c  a902              ADD      r1,sp,#8
00017e  4893              LDR      r0,|L1.972|
000180  3814              SUBS     r0,r0,#0x14
000182  f7fffffe          BL       DMA_Init
;;;149    	
;;;150    		DMA_ClearFlag(DMA1_FLAG_GL1);       // 清除DMA所有标志   
000186  2001              MOVS     r0,#1
000188  f7fffffe          BL       DMA_ClearFlag
;;;151    
;;;152    	
;;;153    	DMA_ITConfig(DMA1_Channel2, DMA_IT_TC, ENABLE);					//发送完中断
00018c  2201              MOVS     r2,#1
00018e  2102              MOVS     r1,#2
000190  488e              LDR      r0,|L1.972|
000192  3814              SUBS     r0,r0,#0x14
000194  f7fffffe          BL       DMA_ITConfig
;;;154    	DMA_ITConfig(DMA1_Channel2, DMA_IT_TE, ENABLE);					//传输错误中断
000198  2201              MOVS     r2,#1
00019a  2108              MOVS     r1,#8
00019c  488b              LDR      r0,|L1.972|
00019e  3814              SUBS     r0,r0,#0x14
0001a0  f7fffffe          BL       DMA_ITConfig
;;;155    	
;;;156    	/* Enable USART3 DMA TX request */
;;;157    	USART_DMACmd(USART3, USART_DMAReq_Tx, ENABLE);
0001a4  2201              MOVS     r2,#1
0001a6  2180              MOVS     r1,#0x80
0001a8  4887              LDR      r0,|L1.968|
0001aa  f7fffffe          BL       USART_DMACmd
;;;158    	DMA_Cmd(DMA1_Channel2, DISABLE);				//关闭DMA1-4通道
0001ae  2100              MOVS     r1,#0
0001b0  4886              LDR      r0,|L1.972|
0001b2  3814              SUBS     r0,r0,#0x14
0001b4  f7fffffe          BL       DMA_Cmd
;;;159    	
;;;160    	//=============================
;;;161    	//DMA中断设置
;;;162    	//=============================
;;;163    	NVIC_InitStructure.NVIC_IRQChannel = DMA1_Channel2_IRQn; 		                //中断通道
0001b8  200c              MOVS     r0,#0xc
0001ba  f88d0004          STRB     r0,[sp,#4]
;;;164    	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;                       //抢占优先级
0001be  2000              MOVS     r0,#0
0001c0  f88d0005          STRB     r0,[sp,#5]
;;;165    	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 1;		                        //从优先级
0001c4  2001              MOVS     r0,#1
0001c6  f88d0006          STRB     r0,[sp,#6]
;;;166    	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;									//中断使能
0001ca  f88d0007          STRB     r0,[sp,#7]
;;;167    	NVIC_Init(&NVIC_InitStructure);
0001ce  a801              ADD      r0,sp,#4
0001d0  f7fffffe          BL       NVIC_Init
;;;168    
;;;169    }
0001d4  b00d              ADD      sp,sp,#0x34
0001d6  bd00              POP      {pc}
;;;170    
                          ENDP

                  DMA1_Channel3_IRQHandler PROC
;;;176    static uint8_t DMA_fl = 0;
;;;177    void DMA1_Channel3_IRQHandler(void)
0001d8  b510              PUSH     {r4,lr}
;;;178    {
;;;179    	DMA_fl = !DMA_fl;
0001da  487f              LDR      r0,|L1.984|
0001dc  7800              LDRB     r0,[r0,#0]  ; DMA_fl
0001de  b908              CBNZ     r0,|L1.484|
0001e0  2001              MOVS     r0,#1
0001e2  e000              B        |L1.486|
                  |L1.484|
0001e4  2000              MOVS     r0,#0
                  |L1.486|
0001e6  497c              LDR      r1,|L1.984|
0001e8  7008              STRB     r0,[r1,#0]
;;;180    	if(DMA_GetITStatus(DMA1_IT_TC3) == SET)    
0001ea  f44f7000          MOV      r0,#0x200
0001ee  f7fffffe          BL       DMA_GetITStatus
0001f2  2801              CMP      r0,#1
0001f4  d102              BNE      |L1.508|
;;;181    	{
;;;182    		DMA_ClearITPendingBit(DMA1_IT_TC3);
0001f6  0240              LSLS     r0,r0,#9
0001f8  f7fffffe          BL       DMA_ClearITPendingBit
                  |L1.508|
;;;183    	}
;;;184    	if(DMA_GetITStatus(DMA1_IT_TE3) == SET)
0001fc  f44f6000          MOV      r0,#0x800
000200  f7fffffe          BL       DMA_GetITStatus
000204  2801              CMP      r0,#1
000206  d102              BNE      |L1.526|
;;;185    	{
;;;186    		DMA_ClearITPendingBit(DMA1_IT_TE3);
000208  02c0              LSLS     r0,r0,#11
00020a  f7fffffe          BL       DMA_ClearITPendingBit
                  |L1.526|
;;;187    	}
;;;188    	DMA_ClearITPendingBit(DMA1_IT_TC3);
00020e  f44f7000          MOV      r0,#0x200
000212  f7fffffe          BL       DMA_ClearITPendingBit
;;;189    	DMA_ClearITPendingBit(DMA1_IT_TE3);
000216  f44f6000          MOV      r0,#0x800
00021a  f7fffffe          BL       DMA_ClearITPendingBit
;;;190    	DMA_Cmd(DMA1_Channel3, DISABLE);//关DMA防止处理时有数据过来
00021e  2100              MOVS     r1,#0
000220  486a              LDR      r0,|L1.972|
000222  f7fffffe          BL       DMA_Cmd
;;;191    	DMA1_Channel3->CNDTR = 100;//重装填
000226  2064              MOVS     r0,#0x64
000228  4968              LDR      r1,|L1.972|
00022a  3930              SUBS     r1,r1,#0x30
00022c  6348              STR      r0,[r1,#0x34]
;;;192    	DMA_Cmd(DMA1_Channel3, ENABLE);//数据处理完，重开DMA
00022e  2101              MOVS     r1,#1
000230  4866              LDR      r0,|L1.972|
000232  f7fffffe          BL       DMA_Cmd
;;;193    }
000236  bd10              POP      {r4,pc}
;;;194    
                          ENDP

                  DMA1_Channel2_IRQHandler PROC
;;;199    */
;;;200    void DMA1_Channel2_IRQHandler(void)
000238  b510              PUSH     {r4,lr}
;;;201    {
;;;202    //	DMA_fl = !DMA_fl;
;;;203    	if(DMA_GetITStatus(DMA1_IT_TC2) == SET)    
00023a  2020              MOVS     r0,#0x20
00023c  f7fffffe          BL       DMA_GetITStatus
000240  2801              CMP      r0,#1
000242  d102              BNE      |L1.586|
;;;204    	{
;;;205    		DMA_ClearITPendingBit(DMA1_IT_TC2);
000244  2020              MOVS     r0,#0x20
000246  f7fffffe          BL       DMA_ClearITPendingBit
                  |L1.586|
;;;206    	}
;;;207    	if(DMA_GetITStatus(DMA1_IT_TE2) == SET)
00024a  2080              MOVS     r0,#0x80
00024c  f7fffffe          BL       DMA_GetITStatus
000250  2801              CMP      r0,#1
000252  d102              BNE      |L1.602|
;;;208    	{
;;;209    		DMA_ClearITPendingBit(DMA1_IT_TE2);
000254  2080              MOVS     r0,#0x80
000256  f7fffffe          BL       DMA_ClearITPendingBit
                  |L1.602|
;;;210    	}
;;;211    	DMA_ClearITPendingBit(DMA1_IT_TC2);
00025a  2020              MOVS     r0,#0x20
00025c  f7fffffe          BL       DMA_ClearITPendingBit
;;;212    	DMA_ClearITPendingBit(DMA1_IT_TE2);
000260  2080              MOVS     r0,#0x80
000262  f7fffffe          BL       DMA_ClearITPendingBit
;;;213    	DMA_Cmd(DMA1_Channel2, DISABLE);//关
000266  2100              MOVS     r1,#0
000268  4858              LDR      r0,|L1.972|
00026a  3814              SUBS     r0,r0,#0x14
00026c  f7fffffe          BL       DMA_Cmd
;;;214    	
;;;215    	DMA1_Channel3->CNDTR = RX_LEN;//重设置接收缓冲长度
000270  f44f7080          MOV      r0,#0x100
000274  4955              LDR      r1,|L1.972|
000276  3930              SUBS     r1,r1,#0x30
000278  6348              STR      r0,[r1,#0x34]
;;;216    	DMA_Cmd(DMA1_Channel3, ENABLE);	//打开接收DMA
00027a  2101              MOVS     r1,#1
00027c  4853              LDR      r0,|L1.972|
00027e  f7fffffe          BL       DMA_Cmd
;;;217    //	show_string("11", 500, 350);
;;;218    
;;;219    }
000282  bd10              POP      {r4,pc}
;;;220    
                          ENDP

                  commucation_recv_default PROC
;;;225    */
;;;226    void commucation_recv_default(uint8_t * dat, uint16_t len)
000284  4770              BX       lr
;;;227    {
;;;228    	//这里可以作为那种全双工通讯的通道
;;;229    }
;;;230    
                          ENDP

                  USART3_IRQHandler PROC
;;;237    */
;;;238    void USART3_IRQHandler(void)
000286  b510              PUSH     {r4,lr}
;;;239    {
;;;240    	uint32_t  sr;
;;;241    	sr = sr;//防止编译器报错
000288  bf00              NOP      
;;;242    	//sr = USART3->SR;
;;;243    	if(USART_GetITStatus(USART3, USART_IT_TXE) != RESET)//发送空
00028a  f2407127          MOV      r1,#0x727
00028e  484e              LDR      r0,|L1.968|
000290  f7fffffe          BL       USART_GetITStatus
000294  b120              CBZ      r0,|L1.672|
;;;244    	{
;;;245    		USART_ClearITPendingBit(USART3, USART_IT_TXE);
000296  f2407127          MOV      r1,#0x727
00029a  484b              LDR      r0,|L1.968|
00029c  f7fffffe          BL       USART_ClearITPendingBit
                  |L1.672|
;;;246    	}
;;;247    	
;;;248    	if(USART_GetITStatus(USART3, USART_IT_TC) != RESET)//发送完成
0002a0  f2406126          MOV      r1,#0x626
0002a4  4848              LDR      r0,|L1.968|
0002a6  f7fffffe          BL       USART_GetITStatus
0002aa  b150              CBZ      r0,|L1.706|
;;;249    	{
;;;250    		USART_ClearITPendingBit(USART3, USART_IT_TC);
0002ac  f2406126          MOV      r1,#0x626
0002b0  4845              LDR      r0,|L1.968|
0002b2  f7fffffe          BL       USART_ClearITPendingBit
;;;251    		USART_ITConfig(USART3, USART_IT_TC, DISABLE);                                  
0002b6  2200              MOVS     r2,#0
0002b8  f2406126          MOV      r1,#0x626
0002bc  4842              LDR      r0,|L1.968|
0002be  f7fffffe          BL       USART_ITConfig
                  |L1.706|
;;;252    	}
;;;253    	
;;;254    	if(USART_GetITStatus(USART3, USART_IT_RXNE) != RESET)//收到数据
0002c2  f2405125          MOV      r1,#0x525
0002c6  4840              LDR      r0,|L1.968|
0002c8  f7fffffe          BL       USART_GetITStatus
0002cc  b120              CBZ      r0,|L1.728|
;;;255    	{	 	
;;;256    		USART_ClearITPendingBit(USART3, USART_IT_RXNE);//清除接收中断标志
0002ce  f2405125          MOV      r1,#0x525
0002d2  483d              LDR      r0,|L1.968|
0002d4  f7fffffe          BL       USART_ClearITPendingBit
                  |L1.728|
;;;257    //		rx_len %= 100;
;;;258    //		rx_buffer[rx_len++]=USART_ReceiveData(USART3);//¶ÁÈ¡½ÓÊÕµ½µÄÊý¾ÝUSART3->DR,×Ô¶¯Çå³ý±êÖ¾Î»
;;;259    	}
;;;260    	
;;;261    	if(USART_GetITStatus(USART3, USART_IT_ORE) != RESET)//溢出错误
0002d8  f44f7158          MOV      r1,#0x360
0002dc  483a              LDR      r0,|L1.968|
0002de  f7fffffe          BL       USART_GetITStatus
0002e2  b140              CBZ      r0,|L1.758|
;;;262    	{//RDR 中有数据未读，但是移位寄存器有数据需要发送到RDR中
;;;263    		sr = USART_ReceiveData(USART3);
0002e4  4838              LDR      r0,|L1.968|
0002e6  f7fffffe          BL       USART_ReceiveData
0002ea  4604              MOV      r4,r0
;;;264    		USART_ClearITPendingBit(USART3, USART_IT_ORE);//请溢出错误标志
0002ec  f44f7158          MOV      r1,#0x360
0002f0  4835              LDR      r0,|L1.968|
0002f2  f7fffffe          BL       USART_ClearITPendingBit
                  |L1.758|
;;;265    	}
;;;266    	
;;;267    	if(USART_GetITStatus(USART3, USART_IT_IDLE) != RESET)//空闲
0002f6  f2404124          MOV      r1,#0x424
0002fa  4833              LDR      r0,|L1.968|
0002fc  f7fffffe          BL       USART_GetITStatus
000300  b300              CBZ      r0,|L1.836|
;;;268    	{
;;;269    //			show_string("0 ", 500, 350);
;;;270    
;;;271    		DMA_fl = 3;
000302  2003              MOVS     r0,#3
000304  4934              LDR      r1,|L1.984|
000306  7008              STRB     r0,[r1,#0]
;;;272    		sr = USART_ReceiveData(USART3);
000308  482f              LDR      r0,|L1.968|
00030a  f7fffffe          BL       USART_ReceiveData
00030e  4604              MOV      r4,r0
;;;273    		DMA_Cmd(DMA1_Channel3, DISABLE);//关闭DMA，防止处理时有数据过来
000310  2100              MOVS     r1,#0
000312  482e              LDR      r0,|L1.972|
000314  f7fffffe          BL       DMA_Cmd
;;;274    		USART_ClearITPendingBit(USART3, USART_IT_IDLE );
000318  f2404124          MOV      r1,#0x424
00031c  482a              LDR      r0,|L1.968|
00031e  f7fffffe          BL       USART_ClearITPendingBit
;;;275    		//获取DMA接收数据长度
;;;276    		commucation_rx_len = RX_LEN - DMA_GetCurrDataCounter(DMA1_Channel3);//这个和手上的中文手册不同
000322  482a              LDR      r0,|L1.972|
000324  f7fffffe          BL       DMA_GetCurrDataCounter
000328  f5c07080          RSB      r0,r0,#0x100
00032c  492b              LDR      r1,|L1.988|
00032e  8008              STRH     r0,[r1,#0]
;;;277    		
;;;278    		commucationo_recv_dealwith(commucation_recv_buf, commucation_rx_len);
000330  4608              MOV      r0,r1
000332  8801              LDRH     r1,[r0,#0]  ; commucation_rx_len
000334  4826              LDR      r0,|L1.976|
000336  4a2a              LDR      r2,|L1.992|
000338  6812              LDR      r2,[r2,#0]  ; commucationo_recv_dealwith
00033a  4790              BLX      r2
;;;279    		commucationo_recv_dealwith = commucation_recv_default;
00033c  f2af00bb          ADR      r0,commucation_recv_default + 1
000340  4927              LDR      r1,|L1.992|
000342  6008              STR      r0,[r1,#0]  ; commucationo_recv_dealwith
                  |L1.836|
;;;280    		
;;;281    //		DMA1_Channel3->CNDTR = 100;//重设置接收缓冲长度
;;;282    //		DMA_Cmd(DMA1_Channel3, ENABLE);	//打开DMA
;;;283    	}
;;;284    
;;;285    	if(USART_GetITStatus(USART3 ,USART_IT_PE | USART_IT_FE | USART_IT_NE) != RESET)//其他错误
000344  f44f715a          MOV      r1,#0x368
000348  481f              LDR      r0,|L1.968|
00034a  f7fffffe          BL       USART_GetITStatus
00034e  b140              CBZ      r0,|L1.866|
;;;286    	{//没开对应的中断使能的话，是不会触发的
;;;287    		sr = USART_ReceiveData(USART3);
000350  481d              LDR      r0,|L1.968|
000352  f7fffffe          BL       USART_ReceiveData
000356  4604              MOV      r4,r0
;;;288    		USART_ClearITPendingBit(USART3, USART_IT_PE | USART_IT_FE | USART_IT_NE);
000358  f44f715a          MOV      r1,#0x368
00035c  481a              LDR      r0,|L1.968|
00035e  f7fffffe          BL       USART_ClearITPendingBit
                  |L1.866|
;;;289    	}
;;;290    }
000362  bd10              POP      {r4,pc}
;;;291    
                          ENDP

                  bsp_commucation_init PROC
;;;297    */
;;;298    void bsp_commucation_init(void)
000364  b510              PUSH     {r4,lr}
;;;299    {
;;;300    	usart3_config();
000366  f7fffffe          BL       usart3_config
;;;301    	uart3_dmaSend_config();
00036a  f7fffffe          BL       uart3_dmaSend_config
;;;302    	uart3_dmaRecv_config();
00036e  f7fffffe          BL       uart3_dmaRecv_config
;;;303    	commucationo_recv_dealwith = commucation_recv_default;
000372  f2af00ef          ADR      r0,commucation_recv_default + 1
000376  491a              LDR      r1,|L1.992|
000378  6008              STR      r0,[r1,#0]  ; commucationo_recv_dealwith
;;;304    }
00037a  bd10              POP      {r4,pc}
;;;305    
                          ENDP

                  commucation_send PROC
;;;310    */
;;;311    void commucation_send(uint8_t *dat, uint16_t size, COMMUCATION_RECV_DEALWITH callback)  
00037c  b570              PUSH     {r4-r6,lr}
;;;312    {
00037e  4605              MOV      r5,r0
000380  460c              MOV      r4,r1
000382  4616              MOV      r6,r2
;;;313    //	show_string("13", 500, 350);
;;;314    	memcpy(commucation_send_buf, dat, size);//拷贝要发送的内容
000384  4622              MOV      r2,r4
000386  4629              MOV      r1,r5
000388  4812              LDR      r0,|L1.980|
00038a  f7fffffe          BL       __aeabi_memcpy
;;;315    	commucationo_recv_dealwith = callback;
00038e  4814              LDR      r0,|L1.992|
000390  6006              STR      r6,[r0,#0]  ; commucationo_recv_dealwith
;;;316    	commucation_rx_len = 0;
000392  2000              MOVS     r0,#0
000394  4911              LDR      r1,|L1.988|
000396  8008              STRH     r0,[r1,#0]
;;;317    //		show_string("12", 500, 350);
;;;318        DMA_Cmd(DMA1_Channel2, DISABLE);//开始DMA发送
000398  2100              MOVS     r1,#0
00039a  480c              LDR      r0,|L1.972|
00039c  3814              SUBS     r0,r0,#0x14
00039e  f7fffffe          BL       DMA_Cmd
;;;319        DMA1_Channel2->CNDTR = size; // 设置要发送的字节数目
0003a2  480a              LDR      r0,|L1.972|
0003a4  3830              SUBS     r0,r0,#0x30
0003a6  6204              STR      r4,[r0,#0x20]
;;;320        DMA_Cmd(DMA1_Channel2, ENABLE);//开始DMA发送
0003a8  2101              MOVS     r1,#1
0003aa  4808              LDR      r0,|L1.972|
0003ac  3814              SUBS     r0,r0,#0x14
0003ae  f7fffffe          BL       DMA_Cmd
;;;321    }
0003b2  bd70              POP      {r4-r6,pc}
;;;322    
                          ENDP

                  commucation_recv_get PROC
;;;325    */
;;;326    uint8_t *commucation_recv_get(void)
0003b4  4806              LDR      r0,|L1.976|
;;;327    {
;;;328    	return commucation_recv_buf;
;;;329    }
0003b6  4770              BX       lr
;;;330    
                          ENDP

                  commucation_send_get PROC
;;;333    */
;;;334    uint8_t *commucation_send_get(void)
0003b8  4806              LDR      r0,|L1.980|
;;;335    {
;;;336    	return commucation_send_buf;
;;;337    }
0003ba  4770              BX       lr
;;;338    
                          ENDP

                  commucation_rxlen_get PROC
;;;341    */
;;;342    uint32_t commucation_rxlen_get(void)
0003bc  4807              LDR      r0,|L1.988|
;;;343    {
;;;344    	return commucation_rx_len;
0003be  8800              LDRH     r0,[r0,#0]  ; commucation_rx_len
;;;345    }
0003c0  4770              BX       lr
                          ENDP

0003c2  0000              DCW      0x0000
                  |L1.964|
                          DCD      0x40010c00
                  |L1.968|
                          DCD      0x40004800
                  |L1.972|
                          DCD      0x40020030
                  |L1.976|
                          DCD      commucation_recv_buf
                  |L1.980|
                          DCD      commucation_send_buf
                  |L1.984|
                          DCD      DMA_fl
                  |L1.988|
                          DCD      commucation_rx_len
                  |L1.992|
                          DCD      commucationo_recv_dealwith

                          AREA ||.bss||, DATA, NOINIT, ALIGN=0

                  commucation_recv_buf
                          %        256
                  commucation_send_buf
                          %        256

                          AREA ||.data||, DATA, ALIGN=2

                  commucation_rx_len
000000  00000000          DCB      0x00,0x00,0x00,0x00
                  commucationo_recv_dealwith
                          DCD      0x00000000
                  DMA_fl
000008  00                DCB      0x00

;*** Start embedded assembler ***

#line 1 "..\\USR\\Bsp\\bsp_commucation.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___17_bsp_commucation_c_472cc795____REV16|
#line 129 "C:\\Keil_v5\\ARM\\CMSIS\\Include\\core_cmInstr.h"
|__asm___17_bsp_commucation_c_472cc795____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___17_bsp_commucation_c_472cc795____REVSH|
#line 144
|__asm___17_bsp_commucation_c_472cc795____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
