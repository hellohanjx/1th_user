; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\output\i2c_ee_dma.o --asm_dir=.\Listing\ --list_dir=.\Listing\ --depend=.\output\i2c_ee_dma.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x -I..\bsp_lib -I..\UCOSII\port -I..\UCOSII\src -I..\UCOSII\uC-CPU -I..\Libraries\CMSIS -I..\User\INCLUDES -I..\LCD -I..\USR\Global -I..\USR -I..\USR\FSM -I..\USR\Commucation -I..\USR\Mdb -I..\USR\Drop -I..\USR\DriverBoard -I..\USR\Flash -I..\USR\Card -I..\USR\MSG -I..\USR\Bsp -I..\USR\SetPar -I..\User\QRCode -I..\USR\MEM -I..\USR\QRCode -I..\USR\SETUP -I..\USR\stm32 -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -IC:\Keil_v5\ARM\INC\ST\STM32F10x -D__MICROLIB -D__UVISION_VERSION=525 -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER --omf_browse=.\output\i2c_ee_dma.crf ..\bsp_lib\i2c_ee_dma.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  I2C_EE_Init PROC
;;;62     *******************************************************************************/
;;;63     void  I2C_EE_Init(void)
000000  b500              PUSH     {lr}
;;;64     {
000002  b087              SUB      sp,sp,#0x1c
;;;65     	/******* GPIO configuration and clock enable *********/
;;;66     	GPIO_InitTypeDef  GPIO_InitStructure; 
;;;67     	I2C_InitTypeDef  I2C_InitStructure;
;;;68     	NVIC_InitTypeDef NVIC_InitStructure;
;;;69     	
;;;70         RCC_APB1PeriphClockCmd(RCC_APB1Periph_I2C1, ENABLE);
000004  2101              MOVS     r1,#1
000006  0548              LSLS     r0,r1,#21
000008  f7fffffe          BL       RCC_APB1PeriphClockCmd
;;;71     	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE);
00000c  2101              MOVS     r1,#1
00000e  2008              MOVS     r0,#8
000010  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;72     
;;;73     	//引脚设置
;;;74     	GPIO_PinRemapConfig(GPIO_Remap_I2C1, ENABLE); //管脚重映射
000014  2101              MOVS     r1,#1
000016  2002              MOVS     r0,#2
000018  f7fffffe          BL       GPIO_PinRemapConfig
;;;75         GPIO_InitStructure.GPIO_Pin =  GPIO_Pin_8 | GPIO_Pin_9;
00001c  f44f7040          MOV      r0,#0x300
000020  f8ad0018          STRH     r0,[sp,#0x18]
;;;76     	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
000024  2003              MOVS     r0,#3
000026  f88d001a          STRB     r0,[sp,#0x1a]
;;;77     	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_OD;
00002a  201c              MOVS     r0,#0x1c
00002c  f88d001b          STRB     r0,[sp,#0x1b]
;;;78     	GPIO_Init(GPIOB, &GPIO_InitStructure);
000030  a906              ADD      r1,sp,#0x18
000032  48fe              LDR      r0,|L1.1068|
000034  f7fffffe          BL       GPIO_Init
;;;79     
;;;80     
;;;81     	//i2c 设置
;;;82     	I2C_DeInit(I2C1);
000038  48fd              LDR      r0,|L1.1072|
00003a  f7fffffe          BL       I2C_DeInit
;;;83     	I2C_InitStructure.I2C_Mode = I2C_Mode_I2C; 			//设置为I2C模式
00003e  2000              MOVS     r0,#0
000040  f8ad000c          STRH     r0,[sp,#0xc]
;;;84     	I2C_InitStructure.I2C_DutyCycle = I2C_DutyCycle_2;  //占空比
000044  f64b70ff          MOV      r0,#0xbfff
000048  f8ad000e          STRH     r0,[sp,#0xe]
;;;85     	I2C_InitStructure.I2C_OwnAddress1 = I2C1_ADDRESS7;  //stm32作为从机的地址
00004c  2001              MOVS     r0,#1
00004e  f8ad0010          STRH     r0,[sp,#0x10]
;;;86     	I2C_InitStructure.I2C_Ack = I2C_Ack_Enable; 		//使能应答 ack
000052  0280              LSLS     r0,r0,#10
000054  f8ad0012          STRH     r0,[sp,#0x12]
;;;87     	#ifdef SLAVE_10BIT_ADDRESS  
;;;88     	I2C_InitStructure.I2C_AcknowledgedAddress = I2C_AcknowledgedAddress_10bit;  // user define
;;;89     	#else
;;;90     	I2C_InitStructure.I2C_AcknowledgedAddress = I2C_AcknowledgedAddress_7bit;	//应答地址（7bit）
000058  0100              LSLS     r0,r0,#4
00005a  f8ad0014          STRH     r0,[sp,#0x14]
;;;91     	#endif
;;;92     	I2C_InitStructure.I2C_ClockSpeed = I2C_SPEED; //时钟频率 <= 400KHz
00005e  48f5              LDR      r0,|L1.1076|
000060  9002              STR      r0,[sp,#8]
;;;93     	I2C_Init(I2C1, &I2C_InitStructure);
000062  a902              ADD      r1,sp,#8
000064  48f2              LDR      r0,|L1.1072|
000066  f7fffffe          BL       I2C_Init
;;;94     	I2C_Cmd(I2C1, ENABLE);
00006a  2101              MOVS     r1,#1
00006c  48f0              LDR      r0,|L1.1072|
00006e  f7fffffe          BL       I2C_Cmd
;;;95     	sem_i2cbus_lock=OSSemCreate(1);
000072  2001              MOVS     r0,#1
000074  f7fffffe          BL       OSSemCreate
000078  49ef              LDR      r1,|L1.1080|
00007a  6008              STR      r0,[r1,#0]  ; sem_i2cbus_lock
;;;96     	
;;;97       
;;;98     /************** I2C NVIC configuration *************************/  
;;;99         //NVIC_PriorityGroupConfig(NVIC_PriorityGroup_1);
;;;100    
;;;101        NVIC_InitStructure.NVIC_IRQChannel = I2C1_EV_IRQn;
00007c  201f              MOVS     r0,#0x1f
00007e  f88d0004          STRB     r0,[sp,#4]
;;;102        NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
000082  2000              MOVS     r0,#0
000084  f88d0006          STRB     r0,[sp,#6]
;;;103        NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1;
000088  2001              MOVS     r0,#1
00008a  f88d0005          STRB     r0,[sp,#5]
;;;104        NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
00008e  f88d0007          STRB     r0,[sp,#7]
;;;105        NVIC_Init(&NVIC_InitStructure);
000092  a801              ADD      r0,sp,#4
000094  f7fffffe          BL       NVIC_Init
;;;106    	
;;;107        NVIC_InitStructure.NVIC_IRQChannel = I2C1_ER_IRQn;
000098  2020              MOVS     r0,#0x20
00009a  f88d0004          STRB     r0,[sp,#4]
;;;108        NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
00009e  2000              MOVS     r0,#0
0000a0  f88d0006          STRB     r0,[sp,#6]
;;;109        NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;//抢占式优先级(这是最高优先级的中断)
0000a4  f88d0005          STRB     r0,[sp,#5]
;;;110        NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
0000a8  2001              MOVS     r0,#1
0000aa  f88d0007          STRB     r0,[sp,#7]
;;;111        NVIC_Init(&NVIC_InitStructure);
0000ae  a801              ADD      r0,sp,#4
0000b0  f7fffffe          BL       NVIC_Init
;;;112        
;;;113        RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA1, ENABLE);
0000b4  2101              MOVS     r1,#1
0000b6  4608              MOV      r0,r1
0000b8  f7fffffe          BL       RCC_AHBPeriphClockCmd
;;;114    }
0000bc  b007              ADD      sp,sp,#0x1c
0000be  bd00              POP      {pc}
;;;115    
                          ENDP

                  i2c_ee_readbuffer PROC
;;;125    *******************************************************************************/
;;;126    static void i2c_ee_readbuffer(uint8_t* pBuffer, uint16_t ReadAddr, uint16_t NumByteToRead)
0000c0  b570              PUSH     {r4-r6,lr}
;;;127    {
0000c2  b08e              SUB      sp,sp,#0x38
0000c4  4605              MOV      r5,r0
0000c6  460e              MOV      r6,r1
0000c8  4614              MOV      r4,r2
;;;128    	uint8_t err;
;;;129    	DMA_InitTypeDef  DMA_InitStructure;
;;;130    	NVIC_InitTypeDef NVIC_InitStructure;
;;;131    	
;;;132    	/* PV operation */
;;;133    //	if (PV_flag_1 !=0)
;;;134    //	  return;
;;;135    	if(NumByteToRead==0)
0000ca  b90c              CBNZ     r4,|L1.208|
                  |L1.204|
;;;136    		return;
;;;137    	OSSemPend(sem_i2cbus_lock, 0, &err);
;;;138    //	PV_flag_1 = 1;
;;;139    	
;;;140    	/* DMA initialization */
;;;141    	DMA_DeInit(DMA1_Channel7);	//DMA 复位
;;;142    	DMA_InitStructure.DMA_PeripheralBaseAddr = (uint32_t)&I2C1->DR;			//DMA外设基地址 指向 i2c1 数据寄存器地址
;;;143    	DMA_InitStructure.DMA_MemoryBaseAddr = (uint32_t)pBuffer; 				//DMA内存基地址
;;;144    	DMA_InitStructure.DMA_BufferSize = NumByteToRead; 						//DMA缓存大小
;;;145    	DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralSRC; 						//外设作为数据传输来源
;;;146    	DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable; 		//外设基地址寄存器不递增
;;;147    	DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable; 				//内存基地址递增
;;;148    	DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_Byte; //外设数据宽度 
;;;149    	DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_Byte; 		//内存数据宽度
;;;150    	DMA_InitStructure.DMA_Mode = DMA_Mode_Normal; 							//工作在正常（还有循环方式）缓存模式
;;;151    	DMA_InitStructure.DMA_Priority = DMA_Priority_VeryHigh;  				//DMA 通道优先级（4种）
;;;152    	DMA_InitStructure.DMA_M2M = DMA_M2M_Disable; 							//DMA 通道没有设置为内存到内存传输
;;;153    	
;;;154    	DMA_Init(DMA1_Channel7, &DMA_InitStructure);
;;;155    	DMA_ITConfig(DMA1_Channel7, DMA_IT_TC, ENABLE);							//使能传输完成中断
;;;156    	
;;;157    	NVIC_InitStructure.NVIC_IRQChannel = DMA1_Channel7_IRQn;				//开DMA7中断
;;;158    	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
;;;159    	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1;
;;;160    	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
;;;161    	NVIC_Init(&NVIC_InitStructure);
;;;162    	
;;;163    	/*initialize static parameter*/
;;;164    	MasterDirection = Receiver;			//表示主机工作方式：收数据
;;;165    	MasterReceptionComplete = 0;		//接收完成
;;;166    	
;;;167    	/*initialize static parameter according to input parameter*/ 
;;;168    	SlaveADDR = EEPROM_ADDRESS;			//从设备地址
;;;169    	DeviceOffset = ReadAddr;			//数据地址
;;;170    	OffsetDone = FALSE;					//数据地址完成标志
;;;171    	
;;;172    	/* global state variable i2c_comm_state */
;;;173    	i2c_comm_state = COMM_PRE;			//i2c 总线状态
;;;174    	    
;;;175    	I2C_AcknowledgeConfig(I2C1, ENABLE);//使能i2c应答功能
;;;176    	I2C_ITConfig(I2C1, I2C_IT_EVT | I2C_IT_ERR , ENABLE);//使能I2C事件与异常中断
;;;177    	
;;;178    	/* Send START condition */
;;;179    	//if(I2C1->CR1 & 0x200)		//判断是否有停止条件 stop产生
;;;180    	//I2C1->CR1 &= 0xFDFF;		//清除 stop
;;;181    	
;;;182    	if(I2C_GetFlagStatus(I2C1, I2C_FLAG_STOPF))//读stop标志位 并清除(根据库函数写的流程)
;;;183    		I2C_Cmd(I2C1, ENABLE);
;;;184    	
;;;185    	I2C_GenerateSTART(I2C1, ENABLE);	//产生 Start 条件
;;;186    	while(i2c_comm_state != COMM_DONE && i2c_comm_state != COMM_EXIT);	//一直等到完成或者发生错误
;;;187    	
;;;188    	OSSemPost(sem_i2cbus_lock);
;;;189    }
0000cc  b00e              ADD      sp,sp,#0x38
0000ce  bd70              POP      {r4-r6,pc}
                  |L1.208|
0000d0  aa0d              ADD      r2,sp,#0x34           ;137
0000d2  2100              MOVS     r1,#0                 ;137
0000d4  48d8              LDR      r0,|L1.1080|
0000d6  6800              LDR      r0,[r0,#0]            ;137  ; sem_i2cbus_lock
0000d8  f7fffffe          BL       OSSemPend
0000dc  48d7              LDR      r0,|L1.1084|
0000de  f7fffffe          BL       DMA_DeInit
0000e2  48d3              LDR      r0,|L1.1072|
0000e4  3010              ADDS     r0,r0,#0x10           ;142
0000e6  9002              STR      r0,[sp,#8]            ;142
0000e8  9503              STR      r5,[sp,#0xc]          ;143
0000ea  9405              STR      r4,[sp,#0x14]         ;144
0000ec  2000              MOVS     r0,#0                 ;145
0000ee  9004              STR      r0,[sp,#0x10]         ;145
0000f0  9006              STR      r0,[sp,#0x18]         ;146
0000f2  2080              MOVS     r0,#0x80              ;147
0000f4  9007              STR      r0,[sp,#0x1c]         ;147
0000f6  2000              MOVS     r0,#0                 ;148
0000f8  9008              STR      r0,[sp,#0x20]         ;148
0000fa  9009              STR      r0,[sp,#0x24]         ;149
0000fc  900a              STR      r0,[sp,#0x28]         ;150
0000fe  f44f5040          MOV      r0,#0x3000            ;151
000102  900b              STR      r0,[sp,#0x2c]         ;151
000104  2000              MOVS     r0,#0                 ;152
000106  900c              STR      r0,[sp,#0x30]         ;152
000108  a902              ADD      r1,sp,#8              ;154
00010a  48cc              LDR      r0,|L1.1084|
00010c  f7fffffe          BL       DMA_Init
000110  2201              MOVS     r2,#1                 ;155
000112  2102              MOVS     r1,#2                 ;155
000114  48c9              LDR      r0,|L1.1084|
000116  f7fffffe          BL       DMA_ITConfig
00011a  2011              MOVS     r0,#0x11              ;157
00011c  f88d0004          STRB     r0,[sp,#4]            ;157
000120  2000              MOVS     r0,#0                 ;158
000122  f88d0006          STRB     r0,[sp,#6]            ;158
000126  2001              MOVS     r0,#1                 ;159
000128  f88d0005          STRB     r0,[sp,#5]            ;159
00012c  f88d0007          STRB     r0,[sp,#7]            ;160
000130  a801              ADD      r0,sp,#4              ;161
000132  f7fffffe          BL       NVIC_Init
000136  2001              MOVS     r0,#1                 ;164
000138  49c1              LDR      r1,|L1.1088|
00013a  7008              STRB     r0,[r1,#0]            ;164
00013c  2000              MOVS     r0,#0                 ;165
00013e  49c1              LDR      r1,|L1.1092|
000140  7008              STRB     r0,[r1,#0]            ;165
000142  20a0              MOVS     r0,#0xa0              ;168
000144  49c0              LDR      r1,|L1.1096|
000146  8008              STRH     r0,[r1,#0]            ;168
000148  48c0              LDR      r0,|L1.1100|
00014a  8006              STRH     r6,[r0,#0]            ;169
00014c  2000              MOVS     r0,#0                 ;170
00014e  49c0              LDR      r1,|L1.1104|
000150  7008              STRB     r0,[r1,#0]            ;170
000152  2001              MOVS     r0,#1                 ;173
000154  49bf              LDR      r1,|L1.1108|
000156  7008              STRB     r0,[r1,#0]            ;173
000158  2101              MOVS     r1,#1                 ;175
00015a  48b5              LDR      r0,|L1.1072|
00015c  f7fffffe          BL       I2C_AcknowledgeConfig
000160  2201              MOVS     r2,#1                 ;176
000162  f44f7140          MOV      r1,#0x300             ;176
000166  48b2              LDR      r0,|L1.1072|
000168  f7fffffe          BL       I2C_ITConfig
00016c  49ba              LDR      r1,|L1.1112|
00016e  48b0              LDR      r0,|L1.1072|
000170  f7fffffe          BL       I2C_GetFlagStatus
000174  b118              CBZ      r0,|L1.382|
000176  2101              MOVS     r1,#1                 ;183
000178  48ad              LDR      r0,|L1.1072|
00017a  f7fffffe          BL       I2C_Cmd
                  |L1.382|
00017e  2101              MOVS     r1,#1                 ;185
000180  48ab              LDR      r0,|L1.1072|
000182  f7fffffe          BL       I2C_GenerateSTART
000186  bf00              NOP                            ;186
                  |L1.392|
000188  48b2              LDR      r0,|L1.1108|
00018a  7800              LDRB     r0,[r0,#0]            ;186  ; i2c_comm_state
00018c  b118              CBZ      r0,|L1.406|
00018e  48b1              LDR      r0,|L1.1108|
000190  7800              LDRB     r0,[r0,#0]            ;186  ; i2c_comm_state
000192  2804              CMP      r0,#4                 ;186
000194  d1f8              BNE      |L1.392|
                  |L1.406|
000196  48a8              LDR      r0,|L1.1080|
000198  6800              LDR      r0,[r0,#0]            ;188  ; sem_i2cbus_lock
00019a  f7fffffe          BL       OSSemPost
00019e  bf00              NOP      
0001a0  e794              B        |L1.204|
;;;190    
                          ENDP

                  I2C_EE_ReadBuffer PROC
;;;191    void I2C_EE_ReadBuffer(uint8_t* pBuffer, uint16_t ReadAddr, uint16_t NumByteToRead)
0001a2  b5f8              PUSH     {r3-r7,lr}
;;;192    {
0001a4  4604              MOV      r4,r0
0001a6  460e              MOV      r6,r1
0001a8  4615              MOV      r5,r2
;;;193    	if(NumByteToRead == 1)//读 1 BYTE
0001aa  2d01              CMP      r5,#1
0001ac  d108              BNE      |L1.448|
;;;194    	{
;;;195    		uint8_t data[2];
;;;196    		i2c_ee_readbuffer(data,ReadAddr,2);
0001ae  2202              MOVS     r2,#2
0001b0  4631              MOV      r1,r6
0001b2  4668              MOV      r0,sp
0001b4  f7fffffe          BL       i2c_ee_readbuffer
;;;197    		pBuffer[0]=data[0];
0001b8  f89d0000          LDRB     r0,[sp,#0]
0001bc  7020              STRB     r0,[r4,#0]
;;;198    	}
0001be  e004              B        |L1.458|
                  |L1.448|
;;;199    	else//读多字节
;;;200    	{
;;;201    		i2c_ee_readbuffer(pBuffer,ReadAddr,NumByteToRead);
0001c0  462a              MOV      r2,r5
0001c2  4631              MOV      r1,r6
0001c4  4620              MOV      r0,r4
0001c6  f7fffffe          BL       i2c_ee_readbuffer
                  |L1.458|
;;;202    	}
;;;203    }
0001ca  bdf8              POP      {r3-r7,pc}
;;;204    
                          ENDP

                  I2C_EE_PageWrite PROC
;;;215    *******************************************************************************/
;;;216    static void I2C_EE_PageWrite(uint8_t* pBuffer, uint16_t WriteAddr, uint16_t NumByteToWrite)
0001cc  b570              PUSH     {r4-r6,lr}
;;;217    {
0001ce  b08c              SUB      sp,sp,#0x30
0001d0  4604              MOV      r4,r0
0001d2  460d              MOV      r5,r1
0001d4  4616              MOV      r6,r2
;;;218    	DMA_InitTypeDef  DMA_InitStructure;
;;;219    	NVIC_InitTypeDef NVIC_InitStructure;
;;;220    
;;;221    	DMA_DeInit(DMA1_Channel6);
0001d6  4899              LDR      r0,|L1.1084|
0001d8  3814              SUBS     r0,r0,#0x14
0001da  f7fffffe          BL       DMA_DeInit
;;;222    	DMA_InitStructure.DMA_PeripheralBaseAddr = (uint32_t)(&I2C1->DR);//指向i2c1数据寄存器
0001de  4894              LDR      r0,|L1.1072|
0001e0  3010              ADDS     r0,r0,#0x10
0001e2  9001              STR      r0,[sp,#4]
;;;223    	
;;;224    	DMA_InitStructure.DMA_MemoryBaseAddr = (uint32_t)pBuffer; 	//内存地址
0001e4  9402              STR      r4,[sp,#8]
;;;225    	DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralDST; 			//外设作为数据传输的目的地
0001e6  2010              MOVS     r0,#0x10
0001e8  9003              STR      r0,[sp,#0xc]
;;;226    	DMA_InitStructure.DMA_BufferSize = NumByteToWrite; 			//DMA 缓存大小
0001ea  9604              STR      r6,[sp,#0x10]
;;;227    	DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable; 	//外设地址不增加
0001ec  2000              MOVS     r0,#0
0001ee  9005              STR      r0,[sp,#0x14]
;;;228    	DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable; 			//内存地址增加
0001f0  2080              MOVS     r0,#0x80
0001f2  9006              STR      r0,[sp,#0x18]
;;;229    	DMA_InitStructure.DMA_PeripheralDataSize = DMA_MemoryDataSize_Byte; //外设数据宽度
0001f4  2000              MOVS     r0,#0
0001f6  9007              STR      r0,[sp,#0x1c]
;;;230    	DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_Byte; 	//内存数据宽度
0001f8  9008              STR      r0,[sp,#0x20]
;;;231    	DMA_InitStructure.DMA_Mode = DMA_Mode_Normal; 						//正常模式
0001fa  9009              STR      r0,[sp,#0x24]
;;;232    	DMA_InitStructure.DMA_Priority = DMA_Priority_VeryHigh;  			//非常高 的优先级
0001fc  f44f5040          MOV      r0,#0x3000
000200  900a              STR      r0,[sp,#0x28]
;;;233    	DMA_InitStructure.DMA_M2M = DMA_M2M_Disable; 						//非内存到内存的传输
000202  2000              MOVS     r0,#0
000204  900b              STR      r0,[sp,#0x2c]
;;;234    	
;;;235    	DMA_Init(DMA1_Channel6, &DMA_InitStructure);
000206  a901              ADD      r1,sp,#4
000208  488c              LDR      r0,|L1.1084|
00020a  3814              SUBS     r0,r0,#0x14
00020c  f7fffffe          BL       DMA_Init
;;;236    	DMA_ITConfig(DMA1_Channel6, DMA_IT_TC, ENABLE);						//开传输完成中断
000210  2201              MOVS     r2,#1
000212  2102              MOVS     r1,#2
000214  4889              LDR      r0,|L1.1084|
000216  3814              SUBS     r0,r0,#0x14
000218  f7fffffe          BL       DMA_ITConfig
;;;237    	
;;;238    	NVIC_InitStructure.NVIC_IRQChannel = DMA1_Channel6_IRQn;
00021c  2010              MOVS     r0,#0x10
00021e  f88d0000          STRB     r0,[sp,#0]
;;;239    	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
000222  2000              MOVS     r0,#0
000224  f88d0002          STRB     r0,[sp,#2]
;;;240    	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
000228  f88d0001          STRB     r0,[sp,#1]
;;;241    	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
00022c  2001              MOVS     r0,#1
00022e  f88d0003          STRB     r0,[sp,#3]
;;;242    	NVIC_Init(&NVIC_InitStructure);
000232  4668              MOV      r0,sp
000234  f7fffffe          BL       NVIC_Init
;;;243    	
;;;244    	/*initialize static parameter*/
;;;245    	MasterDirection = Transmitter;		//i2c 主设备方向
000238  2000              MOVS     r0,#0
00023a  4981              LDR      r1,|L1.1088|
00023c  7008              STRB     r0,[r1,#0]
;;;246    	MasterTransitionComplete = 0;		//发送完成标志初始化
00023e  4987              LDR      r1,|L1.1116|
000240  7008              STRB     r0,[r1,#0]
;;;247    	
;;;248    	/*initialize static parameter according to input parameter*/ 
;;;249    	SlaveADDR = EEPROM_ADDRESS; 	//从设备地址
000242  20a0              MOVS     r0,#0xa0
000244  4980              LDR      r1,|L1.1096|
000246  8008              STRH     r0,[r1,#0]
;;;250    	DeviceOffset = WriteAddr; 		//数据地址
000248  4880              LDR      r0,|L1.1100|
00024a  8005              STRH     r5,[r0,#0]
;;;251    	OffsetDone = FALSE;				//数据地址传输完成标志
00024c  2000              MOVS     r0,#0
00024e  4980              LDR      r1,|L1.1104|
000250  7008              STRB     r0,[r1,#0]
;;;252    	    
;;;253    	I2C_AcknowledgeConfig(I2C1, ENABLE);	//使能ack应答
000252  2101              MOVS     r1,#1
000254  4876              LDR      r0,|L1.1072|
000256  f7fffffe          BL       I2C_AcknowledgeConfig
;;;254    	I2C_ITConfig(I2C1, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR, ENABLE);	//开启i2c 事件/缓冲/错误中断
00025a  2201              MOVS     r2,#1
00025c  f44f61e0          MOV      r1,#0x700
000260  4873              LDR      r0,|L1.1072|
000262  f7fffffe          BL       I2C_ITConfig
;;;255    	
;;;256    	/* Send START condition */
;;;257    //	if(I2C1->CR1 & 0x200)
;;;258    //	I2C1->CR1 &= 0xFDFF;
;;;259    
;;;260    	if(I2C_GetFlagStatus(I2C1, I2C_FLAG_STOPF))//读stop标志位 并清除(根据库函数缩写流程)
000266  497c              LDR      r1,|L1.1112|
000268  4871              LDR      r0,|L1.1072|
00026a  f7fffffe          BL       I2C_GetFlagStatus
00026e  b118              CBZ      r0,|L1.632|
;;;261    	{
;;;262    		I2C_Cmd(I2C1, ENABLE);
000270  2101              MOVS     r1,#1
000272  486f              LDR      r0,|L1.1072|
000274  f7fffffe          BL       I2C_Cmd
                  |L1.632|
;;;263    	}
;;;264    	
;;;265    	while(I2C_GetFlagStatus(I2C1, I2C_FLAG_BUSY));   //如果总线忙，则等待
000278  bf00              NOP      
                  |L1.634|
00027a  f44f3100          MOV      r1,#0x20000
00027e  486c              LDR      r0,|L1.1072|
000280  f7fffffe          BL       I2C_GetFlagStatus
000284  2800              CMP      r0,#0
000286  d1f8              BNE      |L1.634|
;;;266    	
;;;267    	I2C_GenerateSTART(I2C1, ENABLE);	//起始条件
000288  2101              MOVS     r1,#1
00028a  4869              LDR      r0,|L1.1072|
00028c  f7fffffe          BL       I2C_GenerateSTART
;;;268    
;;;269    }
000290  b00c              ADD      sp,sp,#0x30
000292  bd70              POP      {r4-r6,pc}
;;;270    
                          ENDP

                  I2C_EE_WriteOnePage PROC
;;;274    //=========================================
;;;275    static void I2C_EE_WriteOnePage(uint8_t* pBuffer, uint16_t WriteAddr, uint16_t NumByteToWrite)
000294  e92d47ff          PUSH     {r0-r10,lr}
;;;276    {
000298  4682              MOV      r10,r0
00029a  460d              MOV      r5,r1
00029c  4614              MOV      r4,r2
;;;277    	uint8_t NumOfPage = 0, NumOfSingle = 0, Addr = 0, count = 0;
00029e  f04f0800          MOV      r8,#0
0002a2  2600              MOVS     r6,#0
0002a4  46b1              MOV      r9,r6
0002a6  2700              MOVS     r7,#0
;;;278    
;;;279    	Addr = WriteAddr % I2C_PageSize;				//是否整页对齐
0002a8  4628              MOV      r0,r5
0002aa  17e9              ASRS     r1,r5,#31
0002ac  eb056151          ADD      r1,r5,r1,LSR #25
0002b0  11c9              ASRS     r1,r1,#7
0002b2  eba511c1          SUB      r1,r5,r1,LSL #7
0002b6  f00109ff          AND      r9,r1,#0xff
;;;280    	count = I2C_PageSize - Addr;					//非整页对齐时此页可写入的字节
0002ba  f1c90080          RSB      r0,r9,#0x80
0002be  b2c7              UXTB     r7,r0
;;;281    	NumOfPage =  NumByteToWrite / I2C_PageSize;		//要写的整页数量
0002c0  4620              MOV      r0,r4
0002c2  17e1              ASRS     r1,r4,#31
0002c4  eb046151          ADD      r1,r4,r1,LSR #25
0002c8  f3c118c7          UBFX     r8,r1,#7,#8
;;;282    	NumOfSingle = NumByteToWrite % I2C_PageSize;	//要写的不足整页的字节长度
0002cc  17e1              ASRS     r1,r4,#31
0002ce  eb046151          ADD      r1,r4,r1,LSR #25
0002d2  11c9              ASRS     r1,r1,#7
0002d4  eba411c1          SUB      r1,r4,r1,LSL #7
0002d8  b2ce              UXTB     r6,r1
;;;283    	I2C_NumByteWritingNow=0;						//已写的字节
0002da  2000              MOVS     r0,#0
0002dc  4960              LDR      r1,|L1.1120|
0002de  7008              STRB     r0,[r1,#0]
;;;284    
;;;285    	if(Addr == 0) //整页对齐
0002e0  f1b90f00          CMP      r9,#0
0002e4  d113              BNE      |L1.782|
;;;286    	{
;;;287    		if(NumOfPage == 0) //不足一页
0002e6  f1b80f00          CMP      r8,#0
0002ea  d107              BNE      |L1.764|
;;;288    		{
;;;289    			I2C_EE_PageWrite(pBuffer, WriteAddr, NumOfSingle);
0002ec  4632              MOV      r2,r6
0002ee  4629              MOV      r1,r5
0002f0  4650              MOV      r0,r10
0002f2  f7fffffe          BL       I2C_EE_PageWrite
;;;290    			I2C_NumByteWritingNow=NumOfSingle;		//已写的数量等于不足整页的字节长度
0002f6  485a              LDR      r0,|L1.1120|
0002f8  7006              STRB     r6,[r0,#0]
0002fa  e02b              B        |L1.852|
                  |L1.764|
;;;291    		}
;;;292    		else  //超过一页
;;;293    		{
;;;294    			I2C_EE_PageWrite(pBuffer, WriteAddr, I2C_PageSize); 
0002fc  2280              MOVS     r2,#0x80
0002fe  4629              MOV      r1,r5
000300  4650              MOV      r0,r10
000302  f7fffffe          BL       I2C_EE_PageWrite
;;;295    			I2C_NumByteWritingNow=I2C_PageSize;		//已写入的数量等于页长度
000306  2080              MOVS     r0,#0x80
000308  4955              LDR      r1,|L1.1120|
00030a  7008              STRB     r0,[r1,#0]
00030c  e022              B        |L1.852|
                  |L1.782|
;;;296    		}
;;;297    	}
;;;298    
;;;299    	else	//非整页对齐 
;;;300    	{
;;;301    		if(NumOfPage == 0) 
00030e  f1b80f00          CMP      r8,#0
000312  d107              BNE      |L1.804|
;;;302    		{
;;;303    			I2C_EE_PageWrite(pBuffer, WriteAddr, NumOfSingle);
000314  4632              MOV      r2,r6
000316  4629              MOV      r1,r5
000318  4650              MOV      r0,r10
00031a  f7fffffe          BL       I2C_EE_PageWrite
;;;304    			I2C_NumByteWritingNow = NumOfSingle;
00031e  4850              LDR      r0,|L1.1120|
000320  7006              STRB     r6,[r0,#0]
000322  e017              B        |L1.852|
                  |L1.804|
;;;305    		}
;;;306    		else
;;;307    		{
;;;308    			if(count != 0)
000324  b13f              CBZ      r7,|L1.822|
;;;309    			{  
;;;310    				I2C_EE_PageWrite(pBuffer, WriteAddr, count);//一次只能写入 count字节
000326  463a              MOV      r2,r7
000328  4629              MOV      r1,r5
00032a  4650              MOV      r0,r10
00032c  f7fffffe          BL       I2C_EE_PageWrite
;;;311    				I2C_NumByteWritingNow = count;
000330  484b              LDR      r0,|L1.1120|
000332  7007              STRB     r7,[r0,#0]
000334  e00e              B        |L1.852|
                  |L1.822|
;;;312    			}
;;;313    			else 
;;;314    			{
;;;315    				lcd_show_string("address error", 0, 350, RED, WHITE, font48);
000336  4a4b              LDR      r2,|L1.1124|
000338  ca07              LDM      r2,{r0-r2}
00033a  ab01              ADD      r3,sp,#4
00033c  c307              STM      r3!,{r0-r2}
00033e  f64f70ff          MOV      r0,#0xffff
000342  f44f4378          MOV      r3,#0xf800
000346  f44f72af          MOV      r2,#0x15e
00034a  2100              MOVS     r1,#0
00034c  9000              STR      r0,[sp,#0]
00034e  a046              ADR      r0,|L1.1128|
000350  f7fffffe          BL       lcd_show_string
                  |L1.852|
;;;316    			} 
;;;317    		}
;;;318    	}  
;;;319    }
000354  e8bd87ff          POP      {r0-r10,pc}
;;;320    
                          ENDP

                  I2C_EE_WriteOnePageCompleted PROC
;;;323    //============================
;;;324    void I2C_EE_WriteOnePageCompleted(void)
000358  4847              LDR      r0,|L1.1144|
;;;325    {
;;;326    	I2C_pBuffer += I2C_NumByteWritingNow;
00035a  6800              LDR      r0,[r0,#0]  ; I2C_pBuffer
00035c  4940              LDR      r1,|L1.1120|
00035e  7809              LDRB     r1,[r1,#0]  ; I2C_NumByteWritingNow
000360  4408              ADD      r0,r0,r1
000362  4945              LDR      r1,|L1.1144|
000364  6008              STR      r0,[r1,#0]  ; I2C_pBuffer
;;;327    	I2C_WriteAddr += I2C_NumByteWritingNow;
000366  4845              LDR      r0,|L1.1148|
000368  8800              LDRH     r0,[r0,#0]  ; I2C_WriteAddr
00036a  493d              LDR      r1,|L1.1120|
00036c  7809              LDRB     r1,[r1,#0]  ; I2C_NumByteWritingNow
00036e  4408              ADD      r0,r0,r1
000370  4942              LDR      r1,|L1.1148|
000372  8008              STRH     r0,[r1,#0]
;;;328    	I2C_NumByteToWrite -= I2C_NumByteWritingNow;
000374  4842              LDR      r0,|L1.1152|
000376  6800              LDR      r0,[r0,#0]  ; I2C_NumByteToWrite
000378  4939              LDR      r1,|L1.1120|
00037a  7809              LDRB     r1,[r1,#0]  ; I2C_NumByteWritingNow
00037c  1a40              SUBS     r0,r0,r1
00037e  4940              LDR      r1,|L1.1152|
000380  6008              STR      r0,[r1,#0]  ; I2C_NumByteToWrite
;;;329    }
000382  4770              BX       lr
;;;330    /*******************************************************************************
                          ENDP

                  I2C_EE_WriteBuffer PROC
;;;339    *******************************************************************************/
;;;340    void I2C_EE_WriteBuffer(uint8_t* pBuffer, uint16_t WriteAddr, uint16_t NumByteToWrite)
000384  b5f8              PUSH     {r3-r7,lr}
;;;341    {
000386  4605              MOV      r5,r0
000388  460e              MOV      r6,r1
00038a  4614              MOV      r4,r2
;;;342    	uint8_t err;
;;;343    	/* PV operation */ 
;;;344    //	if (PV_flag_1 !=0)
;;;345    //	  return;
;;;346    	if(NumByteToWrite == 0)//写入0字节
00038c  b904              CBNZ     r4,|L1.912|
                  |L1.910|
;;;347    		return;
;;;348    	
;;;349    	OSSemPend(sem_i2cbus_lock, 0, &err);
;;;350    //	PV_flag_1 = 1;
;;;351    
;;;352    	i2c_comm_state = COMM_PRE;	//i2c 总线状态
;;;353    
;;;354    	I2C_pBuffer = pBuffer;
;;;355    	I2C_WriteAddr = WriteAddr;
;;;356    	I2C_NumByteToWrite = NumByteToWrite;
;;;357    
;;;358    	I2C_EE_WriteOnePage(I2C_pBuffer,I2C_WriteAddr,I2C_NumByteToWrite);
;;;359    	
;;;360    	while(i2c_comm_state != COMM_DONE && i2c_comm_state != COMM_EXIT);	//一直等到完成或者发生错误
;;;361    	
;;;362    	OSSemPost(sem_i2cbus_lock);
;;;363    
;;;364    }
00038e  bdf8              POP      {r3-r7,pc}
                  |L1.912|
000390  466a              MOV      r2,sp                 ;349
000392  2100              MOVS     r1,#0                 ;349
000394  4828              LDR      r0,|L1.1080|
000396  6800              LDR      r0,[r0,#0]            ;349  ; sem_i2cbus_lock
000398  f7fffffe          BL       OSSemPend
00039c  2001              MOVS     r0,#1                 ;352
00039e  492d              LDR      r1,|L1.1108|
0003a0  7008              STRB     r0,[r1,#0]            ;352
0003a2  4835              LDR      r0,|L1.1144|
0003a4  6005              STR      r5,[r0,#0]            ;354  ; I2C_pBuffer
0003a6  4835              LDR      r0,|L1.1148|
0003a8  8006              STRH     r6,[r0,#0]            ;355
0003aa  4835              LDR      r0,|L1.1152|
0003ac  6004              STR      r4,[r0,#0]            ;356  ; I2C_NumByteToWrite
0003ae  8800              LDRH     r0,[r0,#0]            ;358  ; I2C_NumByteToWrite
0003b0  b282              UXTH     r2,r0                 ;358
0003b2  4832              LDR      r0,|L1.1148|
0003b4  8801              LDRH     r1,[r0,#0]            ;358  ; I2C_WriteAddr
0003b6  4830              LDR      r0,|L1.1144|
0003b8  6800              LDR      r0,[r0,#0]            ;358  ; I2C_pBuffer
0003ba  f7fffffe          BL       I2C_EE_WriteOnePage
0003be  bf00              NOP                            ;360
                  |L1.960|
0003c0  4824              LDR      r0,|L1.1108|
0003c2  7800              LDRB     r0,[r0,#0]            ;360  ; i2c_comm_state
0003c4  b118              CBZ      r0,|L1.974|
0003c6  4823              LDR      r0,|L1.1108|
0003c8  7800              LDRB     r0,[r0,#0]            ;360  ; i2c_comm_state
0003ca  2804              CMP      r0,#4                 ;360
0003cc  d1f8              BNE      |L1.960|
                  |L1.974|
0003ce  481a              LDR      r0,|L1.1080|
0003d0  6800              LDR      r0,[r0,#0]            ;362  ; sem_i2cbus_lock
0003d2  f7fffffe          BL       OSSemPost
0003d6  bf00              NOP      
0003d8  e7d9              B        |L1.910|
;;;365    
                          ENDP

                  I2C_EE_WaitOperationIsCompleted PROC
;;;372    *******************************************************************************/
;;;373    static void I2C_EE_WaitOperationIsCompleted(void)
0003da  bf00              NOP      
                  |L1.988|
;;;374    {
;;;375    	while(i2c_comm_state != COMM_DONE);
0003dc  481d              LDR      r0,|L1.1108|
0003de  7800              LDRB     r0,[r0,#0]  ; i2c_comm_state
0003e0  2800              CMP      r0,#0
0003e2  d1fb              BNE      |L1.988|
;;;376    }	
0003e4  4770              BX       lr
;;;377    
                          ENDP

                  DMA1_Channel6_IRQHandler PROC
;;;381    */
;;;382    void DMA1_Channel6_IRQHandler(void)
0003e6  b51f              PUSH     {r0-r4,lr}
;;;383    {
;;;384    	if (DMA_GetFlagStatus(DMA1_FLAG_TC6))//检查通道传输完成标志
0003e8  f44f1000          MOV      r0,#0x200000
0003ec  f7fffffe          BL       DMA_GetFlagStatus
0003f0  2800              CMP      r0,#0
0003f2  d079              BEQ      |L1.1256|
;;;385    	{
;;;386    		t_dma6 ++;
0003f4  4823              LDR      r0,|L1.1156|
0003f6  6800              LDR      r0,[r0,#0]  ; t_dma6
0003f8  1c40              ADDS     r0,r0,#1
0003fa  4922              LDR      r1,|L1.1156|
0003fc  6008              STR      r0,[r1,#0]  ; t_dma6
;;;387    		//if (I2C1->SR2 & 0x01) //主模式
;;;388    		if(I2C_GetFlagStatus(I2C1, I2C_FLAG_MSL))//主模式
0003fe  f44f3180          MOV      r1,#0x10000
000402  480b              LDR      r0,|L1.1072|
000404  f7fffffe          BL       I2C_GetFlagStatus
000408  2800              CMP      r0,#0
00040a  d06f              BEQ      |L1.1260|
;;;389    		{
;;;390    			//DMA1-6 (I2C1 Tx DMA)transfer complete ISR
;;;391    			I2C_DMACmd(I2C1, DISABLE);			//禁能 i2c DMA请求
00040c  2100              MOVS     r1,#0
00040e  4808              LDR      r0,|L1.1072|
000410  f7fffffe          BL       I2C_DMACmd
;;;392    			DMA_Cmd(DMA1_Channel6, DISABLE);	//禁能 DMA 通道6
000414  2100              MOVS     r1,#0
000416  4809              LDR      r0,|L1.1084|
000418  3814              SUBS     r0,r0,#0x14
00041a  f7fffffe          BL       DMA_Cmd
;;;393    			
;;;394    			//wait until BTF
;;;395    			//while (!(I2C1->SR1 & 0x04));		//字节发送是否结束 1结束 0未结束   btf == 1
;;;396    			while(!(I2C_GetFlagStatus(I2C1, I2C_FLAG_BTF)));//@@ 这里需要加个超时处理
00041e  bf00              NOP      
                  |L1.1056|
000420  490d              LDR      r1,|L1.1112|
000422  390c              SUBS     r1,r1,#0xc
000424  4802              LDR      r0,|L1.1072|
000426  f7fffffe          BL       I2C_GetFlagStatus
00042a  e02d              B        |L1.1160|
                  |L1.1068|
                          DCD      0x40010c00
                  |L1.1072|
                          DCD      0x40005400
                  |L1.1076|
                          DCD      0x00030d40
                  |L1.1080|
                          DCD      sem_i2cbus_lock
                  |L1.1084|
                          DCD      0x40020080
                  |L1.1088|
                          DCD      MasterDirection
                  |L1.1092|
                          DCD      MasterReceptionComplete
                  |L1.1096|
                          DCD      SlaveADDR
                  |L1.1100|
                          DCD      DeviceOffset
                  |L1.1104|
                          DCD      OffsetDone
                  |L1.1108|
                          DCD      i2c_comm_state
                  |L1.1112|
                          DCD      0x10000010
                  |L1.1116|
                          DCD      MasterTransitionComplete
                  |L1.1120|
                          DCD      I2C_NumByteWritingNow
                  |L1.1124|
                          DCD      font48
                  |L1.1128|
000468  61646472          DCB      "address error",0
00046c  65737320
000470  6572726f
000474  7200    
000476  00                DCB      0
000477  00                DCB      0
                  |L1.1144|
                          DCD      I2C_pBuffer
                  |L1.1148|
                          DCD      I2C_WriteAddr
                  |L1.1152|
                          DCD      I2C_NumByteToWrite
                  |L1.1156|
                          DCD      t_dma6
                  |L1.1160|
000488  2800              CMP      r0,#0
00048a  d0c9              BEQ      |L1.1056|
;;;397    			I2C_GenerateSTOP(I2C1, ENABLE);		//产生i2c 结束条件
00048c  2101              MOVS     r1,#1
00048e  48e7              LDR      r0,|L1.2092|
000490  f7fffffe          BL       I2C_GenerateSTOP
;;;398    			OSTimeDlyHMSM(0,0,0,10);
000494  230a              MOVS     r3,#0xa
000496  2200              MOVS     r2,#0
000498  4611              MOV      r1,r2
00049a  4610              MOV      r0,r2
00049c  f7fffffe          BL       OSTimeDlyHMSM
;;;399    			// wait until BUSY clear
;;;400    			//while (I2C1->SR2 & 0x02);			//检查总线是否有通讯 0无 1有		busy == 0
;;;401    			while(I2C_GetFlagStatus(I2C1, I2C_FLAG_BUSY));//@@ 总线忙；这里也需要超时处理
0004a0  bf00              NOP      
                  |L1.1186|
0004a2  f44f3100          MOV      r1,#0x20000
0004a6  48e1              LDR      r0,|L1.2092|
0004a8  f7fffffe          BL       I2C_GetFlagStatus
0004ac  2800              CMP      r0,#0
0004ae  d1f8              BNE      |L1.1186|
;;;402    			MasterTransitionComplete = 1;		//发送完成
0004b0  2001              MOVS     r0,#1
0004b2  49df              LDR      r1,|L1.2096|
0004b4  7008              STRB     r0,[r1,#0]
;;;403    			i2c_comm_state = COMM_IN_PROCESS;	//进入处理过程
0004b6  2002              MOVS     r0,#2
0004b8  49de              LDR      r1,|L1.2100|
0004ba  7008              STRB     r0,[r1,#0]
;;;404    			I2C_ITConfig(I2C1, I2C_IT_EVT, ENABLE); //使能 i2c 事件中断
0004bc  2201              MOVS     r2,#1
0004be  0201              LSLS     r1,r0,#8
0004c0  48da              LDR      r0,|L1.2092|
0004c2  f7fffffe          BL       I2C_ITConfig
;;;405    			
;;;406    			check_begin = TRUE;
0004c6  2001              MOVS     r0,#1
0004c8  49db              LDR      r1,|L1.2104|
0004ca  7008              STRB     r0,[r1,#0]
;;;407    			
;;;408    			//if(I2C1->CR1 & 0x200)				//检查是否产生停止条件
;;;409    			//I2C1->CR1 &= 0xFDFF;				//清除停止条件
;;;410    			if(I2C_GetFlagStatus(I2C1, I2C_FLAG_STOPF))//读stop标志位 并清除(根据库函数缩写流程)
0004cc  49db              LDR      r1,|L1.2108|
0004ce  48d7              LDR      r0,|L1.2092|
0004d0  f7fffffe          BL       I2C_GetFlagStatus
0004d4  b118              CBZ      r0,|L1.1246|
;;;411    				I2C_Cmd(I2C1, ENABLE);
0004d6  2101              MOVS     r1,#1
0004d8  48d4              LDR      r0,|L1.2092|
0004da  f7fffffe          BL       I2C_Cmd
                  |L1.1246|
;;;412    
;;;413    			I2C_GenerateSTART(I2C1, ENABLE);	//产生开始条件
0004de  2101              MOVS     r1,#1
0004e0  48d2              LDR      r0,|L1.2092|
0004e2  f7fffffe          BL       I2C_GenerateSTART
0004e6  e010              B        |L1.1290|
                  |L1.1256|
0004e8  e013              B        |L1.1298|
0004ea  e7ff              B        |L1.1260|
                  |L1.1260|
;;;414    		}
;;;415    		else //从模式
;;;416    		{
;;;417    			lcd_show_string("dma6 i2c slave mode ", 0, 350, RED, WHITE, font48); //进入这种模式肯定是不对的
0004ec  4ad4              LDR      r2,|L1.2112|
0004ee  ca07              LDM      r2,{r0-r2}
0004f0  ab01              ADD      r3,sp,#4
0004f2  c307              STM      r3!,{r0-r2}
0004f4  f64f70ff          MOV      r0,#0xffff
0004f8  f44f4378          MOV      r3,#0xf800
0004fc  f44f72af          MOV      r2,#0x15e
000500  2100              MOVS     r1,#0
000502  9000              STR      r0,[sp,#0]
000504  a0cf              ADR      r0,|L1.2116|
000506  f7fffffe          BL       lcd_show_string
                  |L1.1290|
;;;418    		}
;;;419    		DMA_ClearFlag(DMA1_FLAG_TC6);	//清除DMA传输完成标志
00050a  f44f1000          MOV      r0,#0x200000
00050e  f7fffffe          BL       DMA_ClearFlag
                  |L1.1298|
;;;420    	}
;;;421    	
;;;422    	if (DMA_GetFlagStatus(DMA1_FLAG_GL6))	//检查通道6 全局中断标志
000512  f44f1080          MOV      r0,#0x100000
000516  f7fffffe          BL       DMA_GetFlagStatus
00051a  b118              CBZ      r0,|L1.1316|
;;;423    	{
;;;424    		DMA_ClearFlag( DMA1_FLAG_GL6);
00051c  f44f1080          MOV      r0,#0x100000
000520  f7fffffe          BL       DMA_ClearFlag
                  |L1.1316|
;;;425    	}
;;;426    	if (DMA_GetFlagStatus(DMA1_FLAG_HT6))	//检查通道6 传输过半标志
000524  f44f0080          MOV      r0,#0x400000
000528  f7fffffe          BL       DMA_GetFlagStatus
00052c  b118              CBZ      r0,|L1.1334|
;;;427    	{
;;;428    		DMA_ClearFlag( DMA1_FLAG_HT6);
00052e  f44f0080          MOV      r0,#0x400000
000532  f7fffffe          BL       DMA_ClearFlag
                  |L1.1334|
;;;429    	}
;;;430    }
000536  bd1f              POP      {r0-r4,pc}
;;;431    
                          ENDP

                  DMA1_Channel7_IRQHandler PROC
;;;435    */
;;;436    void DMA1_Channel7_IRQHandler(void)
000538  b51f              PUSH     {r0-r4,lr}
;;;437    {
;;;438      //LCD_ShowString("7", 400 , 300, RED, FONT_48);
;;;439    	if (DMA_GetFlagStatus(DMA1_FLAG_TC7))//通道7传输完成标志
00053a  f04f7000          MOV      r0,#0x2000000
00053e  f7fffffe          BL       DMA_GetFlagStatus
000542  b338              CBZ      r0,|L1.1428|
;;;440    	{
;;;441    		if (I2C1->SR2 & 0x01)	//i2c 主模式
000544  48b9              LDR      r0,|L1.2092|
000546  3018              ADDS     r0,r0,#0x18
000548  8800              LDRH     r0,[r0,#0]
00054a  f0000001          AND      r0,r0,#1
00054e  b170              CBZ      r0,|L1.1390|
;;;442    		{
;;;443    			I2C_DMACmd(I2C1, DISABLE);
000550  2100              MOVS     r1,#0
000552  48b6              LDR      r0,|L1.2092|
000554  f7fffffe          BL       I2C_DMACmd
;;;444    			I2C_GenerateSTOP(I2C1, ENABLE);
000558  2101              MOVS     r1,#1
00055a  48b4              LDR      r0,|L1.2092|
00055c  f7fffffe          BL       I2C_GenerateSTOP
;;;445    			i2c_comm_state = COMM_DONE;
000560  2000              MOVS     r0,#0
000562  49b4              LDR      r1,|L1.2100|
000564  7008              STRB     r0,[r1,#0]
;;;446    			MasterReceptionComplete = 1;
000566  2001              MOVS     r0,#1
000568  49bc              LDR      r1,|L1.2140|
00056a  7008              STRB     r0,[r1,#0]
00056c  e00e              B        |L1.1420|
                  |L1.1390|
;;;447    //			PV_flag_1 =0;
;;;448    			
;;;449    		}
;;;450    		else //i2c 从模式
;;;451    		{
;;;452    			lcd_show_string("dma7 i2c slave mode ", 0, 350, RED, WHITE, font48);//进入这种模式肯定是不对的
00056e  4ab4              LDR      r2,|L1.2112|
000570  ca07              LDM      r2,{r0-r2}
000572  ab01              ADD      r3,sp,#4
000574  c307              STM      r3!,{r0-r2}
000576  f64f70ff          MOV      r0,#0xffff
00057a  f44f4378          MOV      r3,#0xf800
00057e  f44f72af          MOV      r2,#0x15e
000582  2100              MOVS     r1,#0
000584  9000              STR      r0,[sp,#0]
000586  a0b6              ADR      r0,|L1.2144|
000588  f7fffffe          BL       lcd_show_string
                  |L1.1420|
;;;453    		}
;;;454    		DMA_ClearFlag(DMA1_FLAG_TC7);//清除发送完成标志位
00058c  f04f7000          MOV      r0,#0x2000000
000590  f7fffffe          BL       DMA_ClearFlag
                  |L1.1428|
;;;455    	}
;;;456      
;;;457    	if (DMA_GetFlagStatus(DMA1_FLAG_GL7))//通道7全局标志
000594  f04f7080          MOV      r0,#0x1000000
000598  f7fffffe          BL       DMA_GetFlagStatus
00059c  b118              CBZ      r0,|L1.1446|
;;;458    	{
;;;459    		DMA_ClearFlag( DMA1_FLAG_GL7);
00059e  f04f7080          MOV      r0,#0x1000000
0005a2  f7fffffe          BL       DMA_ClearFlag
                  |L1.1446|
;;;460    	}
;;;461    	
;;;462    	if (DMA_GetFlagStatus(DMA1_FLAG_HT7))//通道7传输过半标志
0005a6  f04f6080          MOV      r0,#0x4000000
0005aa  f7fffffe          BL       DMA_GetFlagStatus
0005ae  b118              CBZ      r0,|L1.1464|
;;;463    	{
;;;464    		DMA_ClearFlag( DMA1_FLAG_HT7);
0005b0  f04f6080          MOV      r0,#0x4000000
0005b4  f7fffffe          BL       DMA_ClearFlag
                  |L1.1464|
;;;465    	}
;;;466    }
0005b8  bd1f              POP      {r0-r4,pc}
;;;467    
                          ENDP

                  I2C1_EV_IRQHandler PROC
;;;471    */
;;;472    void I2C1_EV_IRQHandler(void)
0005ba  b51f              PUSH     {r0-r4,lr}
;;;473    {
;;;474    	//注意，返回的事件都是各种标志位的组合，可能需要具体标志位分析
;;;475    	switch (I2C_GetLastEvent(I2C1))//获得最近一次事件
0005bc  489b              LDR      r0,|L1.2092|
0005be  f7fffffe          BL       I2C_GetLastEvent
0005c2  4aad              LDR      r2,|L1.2168|
0005c4  1a81              SUBS     r1,r0,r2
0005c6  4290              CMP      r0,r2
0005c8  d07d              BEQ      |L1.1734|
0005ca  dc08              BGT      |L1.1502|
0005cc  f46f3140          MVN      r1,#0x30000
0005d0  4408              ADD      r0,r0,r1
0005d2  b148              CBZ      r0,|L1.1512|
0005d4  2801              CMP      r0,#1
0005d6  d034              BEQ      |L1.1602|
0005d8  283f              CMP      r0,#0x3f
                  |L1.1498|
0005da  d131              BNE      |L1.1600|
0005dc  e044              B        |L1.1640|
                  |L1.1502|
0005de  2902              CMP      r1,#2
0005e0  d054              BEQ      |L1.1676|
0005e2  2904              CMP      r1,#4
0005e4  d1f9              BNE      |L1.1498|
0005e6  e0d1              B        |L1.1932|
                  |L1.1512|
;;;476    	{
;;;477    		//起始条件已发送
;;;478    		case I2C_EVENT_MASTER_MODE_SELECT:	//EV5
;;;479    		{
;;;480    			if(!check_begin)
0005e8  4893              LDR      r0,|L1.2104|
0005ea  7800              LDRB     r0,[r0,#0]  ; check_begin
0005ec  b910              CBNZ     r0,|L1.1524|
;;;481    			{
;;;482    				i2c_comm_state = COMM_IN_PROCESS;//通讯开始
0005ee  2002              MOVS     r0,#2
0005f0  4990              LDR      r1,|L1.2100|
0005f2  7008              STRB     r0,[r1,#0]
                  |L1.1524|
;;;483    			}
;;;484                
;;;485    			if (MasterDirection == Receiver) //i2c 接收
0005f4  48a1              LDR      r0,|L1.2172|
0005f6  7800              LDRB     r0,[r0,#0]  ; MasterDirection
0005f8  2801              CMP      r0,#1
0005fa  d115              BNE      |L1.1576|
;;;486    			{
;;;487    				if (!OffsetDone)//数据地址未发完
0005fc  48a0              LDR      r0,|L1.2176|
0005fe  7800              LDRB     r0,[r0,#0]  ; OffsetDone
000600  b938              CBNZ     r0,|L1.1554|
;;;488    				{
;;;489    					I2C_Send7bitAddress(I2C1,SlaveADDR,I2C_Direction_Transmitter);	//发从机地址，写操作
000602  48a0              LDR      r0,|L1.2180|
000604  8800              LDRH     r0,[r0,#0]  ; SlaveADDR
000606  b2c1              UXTB     r1,r0
000608  2200              MOVS     r2,#0
00060a  4888              LDR      r0,|L1.2092|
00060c  f7fffffe          BL       I2C_Send7bitAddress
000610  e011              B        |L1.1590|
                  |L1.1554|
;;;490    				}
;;;491    				else	
;;;492    				{
;;;493    					I2C_Send7bitAddress(I2C1, SlaveADDR, I2C_Direction_Receiver); 	//发从机地址，读操作
000612  489c              LDR      r0,|L1.2180|
000614  8800              LDRH     r0,[r0,#0]  ; SlaveADDR
000616  b2c1              UXTB     r1,r0
000618  2201              MOVS     r2,#1
00061a  4884              LDR      r0,|L1.2092|
00061c  f7fffffe          BL       I2C_Send7bitAddress
;;;494    					OffsetDone = FALSE;
000620  2000              MOVS     r0,#0
000622  4997              LDR      r1,|L1.2176|
000624  7008              STRB     r0,[r1,#0]
000626  e006              B        |L1.1590|
                  |L1.1576|
;;;495    				}
;;;496                }
;;;497    			else	//i2c 方向发送
;;;498    			{
;;;499    				I2C_Send7bitAddress(I2C1, SlaveADDR, I2C_Direction_Transmitter);	//发从机地址，写操作
000628  4896              LDR      r0,|L1.2180|
00062a  8800              LDRH     r0,[r0,#0]  ; SlaveADDR
00062c  b2c1              UXTB     r1,r0
00062e  2200              MOVS     r2,#0
000630  487e              LDR      r0,|L1.2092|
000632  f7fffffe          BL       I2C_Send7bitAddress
                  |L1.1590|
;;;500    			}
;;;501    			I2C_ITConfig(I2C1, I2C_IT_BUF , ENABLE);//使能缓存中断
000636  2201              MOVS     r2,#1
000638  0291              LSLS     r1,r2,#10
00063a  487c              LDR      r0,|L1.2092|
00063c  f7fffffe          BL       I2C_ITConfig
                  |L1.1600|
;;;502    		}
;;;503    		break;
000640  e0a5              B        |L1.1934|
                  |L1.1602|
;;;504                  
;;;505    		//主模式 接收事件
;;;506    		case I2C_EVENT_MASTER_RECEIVER_MODE_SELECTED:  //EV6，注意EV6_1没有这种事件
;;;507    		{
;;;508    			//LCD_ShowString("EV6R", 0 , 50, RED, FONT_48);
;;;509    			I2C_ITConfig(I2C1, I2C_IT_EVT | I2C_IT_BUF, DISABLE);	//禁能事件与缓存中断
000642  2200              MOVS     r2,#0
000644  f44f61c0          MOV      r1,#0x600
000648  4878              LDR      r0,|L1.2092|
00064a  f7fffffe          BL       I2C_ITConfig
;;;510    			//without it, no NAK signal on bus after last Data
;;;511    			//I2C data line would be hold low 		//sda被从机拉低，就是返回了ack
;;;512    			I2C_DMALastTransferCmd(I2C1, ENABLE);	//使得下次 DMA 传输为最后一次传输
00064e  2101              MOVS     r1,#1
000650  4876              LDR      r0,|L1.2092|
000652  f7fffffe          BL       I2C_DMALastTransferCmd
;;;513    			I2C_DMACmd(I2C1, ENABLE);				//使能i2c DMA请求
000656  2101              MOVS     r1,#1
000658  4874              LDR      r0,|L1.2092|
00065a  f7fffffe          BL       I2C_DMACmd
;;;514    			DMA_Cmd(DMA1_Channel7, ENABLE);			//打开DMA通道
00065e  2101              MOVS     r1,#1
000660  4889              LDR      r0,|L1.2184|
000662  f7fffffe          BL       DMA_Cmd
;;;515    		}			
;;;516    		break;
000666  e092              B        |L1.1934|
                  |L1.1640|
;;;517          
;;;518    		//主模式字节接收事件
;;;519    		case I2C_EVENT_MASTER_BYTE_RECEIVED:    //EV7
;;;520    		{
;;;521    			lcd_show_string("EV7", 0 , 100, RED, WHITE, font48);
000668  4a75              LDR      r2,|L1.2112|
00066a  e9d21000          LDRD     r1,r0,[r2,#0]
00066e  6892              LDR      r2,[r2,#8]  ; font48
000670  e9cd0202          STRD     r0,r2,[sp,#8]
000674  9101              STR      r1,[sp,#4]
000676  f64f70ff          MOV      r0,#0xffff
00067a  f44f4378          MOV      r3,#0xf800
00067e  2264              MOVS     r2,#0x64
000680  2100              MOVS     r1,#0
000682  9000              STR      r0,[sp,#0]
000684  a081              ADR      r0,|L1.2188|
000686  f7fffffe          BL       lcd_show_string
;;;522    		}
;;;523    		break;
00068a  e080              B        |L1.1934|
                  |L1.1676|
;;;524          
;;;525    		//主模式，发送事件
;;;526    		case I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED:	//EV6 与 EV8_1（i2c发送状态的ack返回，不仅仅是这个）
;;;527    		{
;;;528    			//LCD_ShowString("EV6S", 0 , 200, RED, FONT_48);
;;;529    			if (check_begin)
00068c  486a              LDR      r0,|L1.2104|
00068e  7800              LDRB     r0,[r0,#0]  ; check_begin
000690  b308              CBZ      r0,|L1.1750|
;;;530    			{
;;;531    				check_begin = FALSE;
000692  2000              MOVS     r0,#0
000694  4968              LDR      r1,|L1.2104|
000696  7008              STRB     r0,[r1,#0]
;;;532    				I2C_ITConfig(I2C1, I2C_IT_EVT | I2C_IT_BUF |I2C_IT_ERR, DISABLE);	//禁能i2c所有中断
000698  2200              MOVS     r2,#0
00069a  f44f61e0          MOV      r1,#0x700
00069e  4863              LDR      r0,|L1.2092|
0006a0  f7fffffe          BL       I2C_ITConfig
;;;533    				I2C_GenerateSTOP(I2C1, ENABLE);										//产生停止条件
0006a4  2101              MOVS     r1,#1
0006a6  4861              LDR      r0,|L1.2092|
0006a8  f7fffffe          BL       I2C_GenerateSTOP
;;;534    				//!! write over
;;;535    				I2C_EE_WriteOnePageCompleted();		//写入数据
0006ac  f7fffffe          BL       I2C_EE_WriteOnePageCompleted
;;;536    				
;;;537    				if(I2C_NumByteToWrite > 0)//数据未未写完
0006b0  4877              LDR      r0,|L1.2192|
0006b2  6800              LDR      r0,[r0,#0]  ; I2C_NumByteToWrite
0006b4  b158              CBZ      r0,|L1.1742|
;;;538    				{
;;;539    					I2C_EE_WriteOnePage(I2C_pBuffer,I2C_WriteAddr,I2C_NumByteToWrite);
0006b6  4876              LDR      r0,|L1.2192|
0006b8  8800              LDRH     r0,[r0,#0]  ; I2C_NumByteToWrite
0006ba  b282              UXTH     r2,r0
0006bc  4875              LDR      r0,|L1.2196|
0006be  8801              LDRH     r1,[r0,#0]  ; I2C_WriteAddr
0006c0  4875              LDR      r0,|L1.2200|
0006c2  6800              LDR      r0,[r0,#0]  ; I2C_pBuffer
0006c4  e000              B        |L1.1736|
                  |L1.1734|
0006c6  e01d              B        |L1.1796|
                  |L1.1736|
0006c8  f7fffffe          BL       I2C_EE_WriteOnePage
0006cc  e002              B        |L1.1748|
                  |L1.1742|
;;;540    				}
;;;541    				else	//数据写完
;;;542    				{
;;;543    					i2c_comm_state = COMM_DONE;
0006ce  2000              MOVS     r0,#0
0006d0  4958              LDR      r1,|L1.2100|
0006d2  7008              STRB     r0,[r1,#0]
                  |L1.1748|
;;;544    //					PV_flag_1 = 0;
;;;545    				}
;;;546    				break;//这里直接退出
0006d4  e05b              B        |L1.1934|
                  |L1.1750|
;;;547    			}
;;;548    
;;;549    			EE_Addr_Count++;//数据字节计数器
0006d6  4871              LDR      r0,|L1.2204|
0006d8  7800              LDRB     r0,[r0,#0]  ; EE_Addr_Count
0006da  1c40              ADDS     r0,r0,#1
0006dc  496f              LDR      r1,|L1.2204|
0006de  7008              STRB     r0,[r1,#0]
;;;550    			if (EE_Addr_Count < EE_ADDRESS_NUM)
0006e0  4608              MOV      r0,r1
0006e2  7800              LDRB     r0,[r0,#0]  ; EE_Addr_Count
0006e4  2802              CMP      r0,#2
0006e6  da06              BGE      |L1.1782|
;;;551    			{
;;;552    				I2C_SendData(I2C1, DeviceOffset>>8);//发送数据地址高字节
0006e8  486d              LDR      r0,|L1.2208|
0006ea  8800              LDRH     r0,[r0,#0]  ; DeviceOffset
0006ec  1201              ASRS     r1,r0,#8
0006ee  484f              LDR      r0,|L1.2092|
0006f0  f7fffffe          BL       I2C_SendData
0006f4  e005              B        |L1.1794|
                  |L1.1782|
;;;553    			}
;;;554    			else
;;;555    			{
;;;556    				I2C_SendData(I2C1, DeviceOffset);//发送数据地址低字节
0006f6  486a              LDR      r0,|L1.2208|
0006f8  8800              LDRH     r0,[r0,#0]  ; DeviceOffset
0006fa  b2c1              UXTB     r1,r0
0006fc  484b              LDR      r0,|L1.2092|
0006fe  f7fffffe          BL       I2C_SendData
                  |L1.1794|
;;;557    			}
;;;558    		}
;;;559    		break;
000702  e044              B        |L1.1934|
                  |L1.1796|
;;;560                  
;;;561    		case I2C_EVENT_MASTER_BYTE_TRANSMITTING:	//EV8
;;;562    		{
;;;563    			//LCD_ShowString("EV8", 0 , 250, RED, FONT_48);
;;;564    
;;;565    			if(!OffsetDone)//数据地址没发完，继续发
000704  485e              LDR      r0,|L1.2176|
000706  7800              LDRB     r0,[r0,#0]  ; OffsetDone
000708  b9b0              CBNZ     r0,|L1.1848|
;;;566    			{
;;;567    				if (EE_Addr_Count < EE_ADDRESS_NUM)
00070a  4864              LDR      r0,|L1.2204|
00070c  7800              LDRB     r0,[r0,#0]  ; EE_Addr_Count
00070e  2802              CMP      r0,#2
000710  da0b              BGE      |L1.1834|
;;;568    				{
;;;569    //					while(I2C_GetFlagStatus(I2C1, I2C_FLAG_STOPF));//读stop标志位 并清除(根据库函数缩写流程)
;;;570    //					I2C_GenerateSTART(I2C1, ENABLE);
;;;571    					I2C_SendData(I2C1, DeviceOffset);//发送数据地址低字节
000712  4863              LDR      r0,|L1.2208|
000714  8800              LDRH     r0,[r0,#0]  ; DeviceOffset
000716  b2c1              UXTB     r1,r0
000718  4844              LDR      r0,|L1.2092|
00071a  f7fffffe          BL       I2C_SendData
;;;572    					EE_Addr_Count++;	
00071e  485f              LDR      r0,|L1.2204|
000720  7800              LDRB     r0,[r0,#0]  ; EE_Addr_Count
000722  1c40              ADDS     r0,r0,#1
000724  495d              LDR      r1,|L1.2204|
000726  7008              STRB     r0,[r1,#0]
000728  e005              B        |L1.1846|
                  |L1.1834|
;;;573    				}
;;;574    				else
;;;575    				{
;;;576    					EE_Addr_Count = 0;
00072a  2000              MOVS     r0,#0
00072c  495b              LDR      r1,|L1.2204|
00072e  7008              STRB     r0,[r1,#0]
;;;577    					OffsetDone = TRUE;	//数据地址发送完
000730  2001              MOVS     r0,#1
000732  4953              LDR      r1,|L1.2176|
000734  7008              STRB     r0,[r1,#0]
                  |L1.1846|
;;;578    				}
;;;579    				break;
000736  e02a              B        |L1.1934|
                  |L1.1848|
;;;580    			}
;;;581    			
;;;582    			//上面已发送完成数据地址，下面开读数据或者写数据
;;;583    			if (MasterDirection == Receiver)	//读 e2prom
000738  4850              LDR      r0,|L1.2172|
00073a  7800              LDRB     r0,[r0,#0]  ; MasterDirection
00073c  2801              CMP      r0,#1
00073e  d110              BNE      |L1.1890|
;;;584    			{
;;;585    				
;;;586    				I2C_ITConfig(I2C1, I2C_IT_BUF , DISABLE);		//关缓冲中断
000740  2200              MOVS     r2,#0
000742  0281              LSLS     r1,r0,#10
000744  4839              LDR      r0,|L1.2092|
000746  f7fffffe          BL       I2C_ITConfig
;;;587    				//while ((I2C1->CR1 & 0x200) == 0x200); 		//已产生停止条件（这里应该是别的地方先发送停止条件，这里才能检查到）
;;;588    				while(I2C_GetFlagStatus(I2C1, I2C_FLAG_STOPF));	//检测到停止条件，等待硬件清除
00074a  bf00              NOP      
                  |L1.1868|
00074c  493b              LDR      r1,|L1.2108|
00074e  4837              LDR      r0,|L1.2092|
000750  f7fffffe          BL       I2C_GetFlagStatus
000754  2800              CMP      r0,#0
000756  d1f9              BNE      |L1.1868|
;;;589    				I2C_GenerateSTART(I2C1, ENABLE);				//发起始条件，重新开始一个流程
000758  2101              MOVS     r1,#1
00075a  4834              LDR      r0,|L1.2092|
00075c  f7fffffe          BL       I2C_GenerateSTART
000760  e013              B        |L1.1930|
                  |L1.1890|
;;;590    				//break;
;;;591    			}
;;;592    			else	//写 e2prom
;;;593    			{
;;;594    				t_evt ++;
000762  4850              LDR      r0,|L1.2212|
000764  6800              LDR      r0,[r0,#0]  ; t_evt
000766  1c40              ADDS     r0,r0,#1
000768  494e              LDR      r1,|L1.2212|
00076a  6008              STR      r0,[r1,#0]  ; t_evt
;;;595    
;;;596    				I2C_ITConfig(I2C1, I2C_IT_EVT | I2C_IT_BUF, DISABLE);	//关事件中断与缓冲中断
00076c  2200              MOVS     r2,#0
00076e  f44f61c0          MOV      r1,#0x600
000772  482e              LDR      r0,|L1.2092|
000774  f7fffffe          BL       I2C_ITConfig
;;;597    				I2C_DMACmd(I2C1, ENABLE);								//使能i2c的DMA请求
000778  2101              MOVS     r1,#1
00077a  482c              LDR      r0,|L1.2092|
00077c  f7fffffe          BL       I2C_DMACmd
;;;598    				DMA_Cmd(DMA1_Channel6, ENABLE);							//开DMA通道
000780  2101              MOVS     r1,#1
000782  4841              LDR      r0,|L1.2184|
000784  3814              SUBS     r0,r0,#0x14
000786  f7fffffe          BL       DMA_Cmd
                  |L1.1930|
;;;599    				//break;//直接退出
;;;600    			}
;;;601    		}
;;;602    		break;
00078a  e000              B        |L1.1934|
                  |L1.1932|
;;;603            
;;;604    		case I2C_EVENT_MASTER_BYTE_TRANSMITTED:       // EV8-2  要求设置停止位（这里1个从机的话不设置也行）
;;;605    		{
;;;606    			//LCD_ShowString("EV8-2", 0 , 300, RED, FONT_48);			
;;;607    		}
;;;608    		break;
00078c  bf00              NOP      
                  |L1.1934|
00078e  bf00              NOP                            ;503
;;;609    	}
;;;610    }
000790  bd1f              POP      {r0-r4,pc}
;;;611    
                          ENDP

                  I2C1_ER_IRQHandler PROC
;;;614    */
;;;615    void I2C1_ER_IRQHandler(void)
000792  b51f              PUSH     {r0-r4,lr}
;;;616    {
;;;617    	if (I2C_GetFlagStatus(I2C1, I2C_FLAG_AF))//应答错误，响应失败
000794  4944              LDR      r1,|L1.2216|
000796  4825              LDR      r0,|L1.2092|
000798  f7fffffe          BL       I2C_GetFlagStatus
00079c  b1e8              CBZ      r0,|L1.2010|
;;;618    	{
;;;619    		t_err ++;
00079e  4843              LDR      r0,|L1.2220|
0007a0  6800              LDR      r0,[r0,#0]  ; t_err
0007a2  1c40              ADDS     r0,r0,#1
0007a4  4941              LDR      r1,|L1.2220|
0007a6  6008              STR      r0,[r1,#0]  ; t_err
;;;620    		//LCD_ShowString("err1", 0 , 400, RED, FONT_48);
;;;621    		if (check_begin)
0007a8  4823              LDR      r0,|L1.2104|
0007aa  7800              LDRB     r0,[r0,#0]  ; check_begin
0007ac  b120              CBZ      r0,|L1.1976|
;;;622    			I2C_GenerateSTART(I2C1, ENABLE);
0007ae  2101              MOVS     r1,#1
0007b0  481e              LDR      r0,|L1.2092|
0007b2  f7fffffe          BL       I2C_GenerateSTART
0007b6  e00c              B        |L1.2002|
                  |L1.1976|
;;;623    		else
;;;624    		if (I2C1->SR2 &0x01)	//主模式
0007b8  481c              LDR      r0,|L1.2092|
0007ba  3018              ADDS     r0,r0,#0x18
0007bc  8800              LDRH     r0,[r0,#0]
0007be  f0000001          AND      r0,r0,#1
0007c2  b130              CBZ      r0,|L1.2002|
;;;625    		{	
;;;626    			//!! receive over
;;;627    			I2C_GenerateSTOP(I2C1, ENABLE);
0007c4  2101              MOVS     r1,#1
0007c6  4819              LDR      r0,|L1.2092|
0007c8  f7fffffe          BL       I2C_GenerateSTOP
;;;628    			i2c_comm_state = COMM_EXIT;
0007cc  2004              MOVS     r0,#4
0007ce  4919              LDR      r1,|L1.2100|
0007d0  7008              STRB     r0,[r1,#0]
                  |L1.2002|
;;;629    //			PV_flag_1 = 0;
;;;630    		}
;;;631    		I2C_ClearFlag(I2C1, I2C_FLAG_AF);
0007d2  4935              LDR      r1,|L1.2216|
0007d4  4815              LDR      r0,|L1.2092|
0007d6  f7fffffe          BL       I2C_ClearFlag
                  |L1.2010|
;;;632    	}
;;;633    
;;;634    	if (I2C_GetFlagStatus(I2C1, I2C_FLAG_BERR))//总线错误
0007da  4918              LDR      r1,|L1.2108|
0007dc  31f0              ADDS     r1,r1,#0xf0
0007de  4813              LDR      r0,|L1.2092|
0007e0  f7fffffe          BL       I2C_GetFlagStatus
0007e4  b300              CBZ      r0,|L1.2088|
;;;635    	{
;;;636    		lcd_show_string("err2", 0 , 400, RED, WHITE, font48);
0007e6  4a16              LDR      r2,|L1.2112|
0007e8  ca07              LDM      r2,{r0-r2}
0007ea  ab01              ADD      r3,sp,#4
0007ec  c307              STM      r3!,{r0-r2}
0007ee  f64f70ff          MOV      r0,#0xffff
0007f2  f44f4378          MOV      r3,#0xf800
0007f6  f44f72c8          MOV      r2,#0x190
0007fa  2100              MOVS     r1,#0
0007fc  9000              STR      r0,[sp,#0]
0007fe  a02c              ADR      r0,|L1.2224|
000800  f7fffffe          BL       lcd_show_string
;;;637    		if (I2C1->SR2 &0x01)
000804  4809              LDR      r0,|L1.2092|
000806  3018              ADDS     r0,r0,#0x18
000808  8800              LDRH     r0,[r0,#0]
00080a  f0000001          AND      r0,r0,#1
00080e  b130              CBZ      r0,|L1.2078|
;;;638    		{
;;;639    			I2C_GenerateSTOP(I2C1, ENABLE);
000810  2101              MOVS     r1,#1
000812  4806              LDR      r0,|L1.2092|
000814  f7fffffe          BL       I2C_GenerateSTOP
;;;640    			i2c_comm_state = COMM_EXIT;
000818  2004              MOVS     r0,#4
00081a  4906              LDR      r1,|L1.2100|
00081c  7008              STRB     r0,[r1,#0]
                  |L1.2078|
;;;641    //			PV_flag_1 = 0;
;;;642    		}
;;;643    		I2C_ClearFlag(I2C1, I2C_FLAG_BERR);
00081e  4907              LDR      r1,|L1.2108|
000820  31f0              ADDS     r1,r1,#0xf0
000822  4802              LDR      r0,|L1.2092|
000824  f7fffffe          BL       I2C_ClearFlag
                  |L1.2088|
;;;644    	}
;;;645    }
000828  bd1f              POP      {r0-r4,pc}
;;;646    
                          ENDP

00082a  0000              DCW      0x0000
                  |L1.2092|
                          DCD      0x40005400
                  |L1.2096|
                          DCD      MasterTransitionComplete
                  |L1.2100|
                          DCD      i2c_comm_state
                  |L1.2104|
                          DCD      check_begin
                  |L1.2108|
                          DCD      0x10000010
                  |L1.2112|
                          DCD      font48
                  |L1.2116|
000844  646d6136          DCB      "dma6 i2c slave mode ",0
000848  20693263
00084c  20736c61
000850  7665206d
000854  6f646520
000858  00      
000859  00                DCB      0
00085a  00                DCB      0
00085b  00                DCB      0
                  |L1.2140|
                          DCD      MasterReceptionComplete
                  |L1.2144|
000860  646d6137          DCB      "dma7 i2c slave mode ",0
000864  20693263
000868  20736c61
00086c  7665206d
000870  6f646520
000874  00      
000875  00                DCB      0
000876  00                DCB      0
000877  00                DCB      0
                  |L1.2168|
                          DCD      0x00070080
                  |L1.2172|
                          DCD      MasterDirection
                  |L1.2176|
                          DCD      OffsetDone
                  |L1.2180|
                          DCD      SlaveADDR
                  |L1.2184|
                          DCD      0x40020080
                  |L1.2188|
00088c  45563700          DCB      "EV7",0
                  |L1.2192|
                          DCD      I2C_NumByteToWrite
                  |L1.2196|
                          DCD      I2C_WriteAddr
                  |L1.2200|
                          DCD      I2C_pBuffer
                  |L1.2204|
                          DCD      EE_Addr_Count
                  |L1.2208|
                          DCD      DeviceOffset
                  |L1.2212|
                          DCD      t_evt
                  |L1.2216|
                          DCD      0x10000400
                  |L1.2220|
                          DCD      t_err
                  |L1.2224|
0008b0  65727232          DCB      "err2",0
0008b4  00      
0008b5  00                DCB      0
0008b6  00                DCB      0
0008b7  00                DCB      0

                          AREA ||.data||, DATA, ALIGN=2

                  MasterDirection
000000  0000              DCB      0x00,0x00
                  SlaveADDR
000002  0000              DCB      0x00,0x00
                  DeviceOffset
000004  0000              DCW      0x0000
                  check_begin
000006  00                DCB      0x00
                  OffsetDone
000007  00                DCB      0x00
                  MasterReceptionComplete
000008  00                DCB      0x00
                  MasterTransitionComplete
000009  000000            DCB      0x00,0x00,0x00
                  I2C_NumByteToWrite
                          DCD      0x00000000
                  I2C_WriteAddr
000010  0000              DCW      0x0000
                  I2C_NumByteWritingNow
000012  00                DCB      0x00
                  EE_Addr_Count
000013  00                DCB      0x00
                  I2C_pBuffer
                          DCD      0x00000000
                  i2c_comm_state
000018  00000000          DCB      0x00,0x00,0x00,0x00
                  sem_i2cbus_lock
                          DCD      0x00000000
                  t_evt
                          DCD      0x00000000
                  t_err
                          DCD      0x00000000
                  t_dma6
                          DCD      0x00000000
                  t_dma7
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "..\\bsp_lib\\i2c_ee_dma.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___12_i2c_ee_dma_c_a812b4bf____REV16|
#line 129 "C:\\Keil_v5\\ARM\\CMSIS\\Include\\core_cmInstr.h"
|__asm___12_i2c_ee_dma_c_a812b4bf____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___12_i2c_ee_dma_c_a812b4bf____REVSH|
#line 144
|__asm___12_i2c_ee_dma_c_a812b4bf____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
