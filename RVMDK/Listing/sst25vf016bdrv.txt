; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\output\sst25vf016bdrv.o --asm_dir=.\Listing\ --list_dir=.\Listing\ --depend=.\output\sst25vf016bdrv.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x -I..\bsp_lib -I..\UCOSII\port -I..\UCOSII\src -I..\UCOSII\uC-CPU -I..\Libraries\CMSIS -I..\User\INCLUDES -I..\LCD -I..\USR\Global -I..\USR -I..\USR\FSM -I..\USR\Commucation -I..\USR\Mdb -I..\USR\Drop -I..\USR\DriverBoard -I..\USR\Flash -I..\USR\Card -I..\USR\MSG -I..\USR\Bsp -I..\USR\SetPar -I..\User\QRCode -I..\USR\MEM -I..\USR\QRCode -I..\USR\SETUP -I..\USR\stm32 -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -IC:\Keil_v5\ARM\INC\ST\STM32F10x -D__MICROLIB -D__UVISION_VERSION=525 -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER --omf_browse=.\output\sst25vf016bdrv.crf ..\bsp_lib\SST25VF016BDrv.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  __f032bSendByte PROC
;;;41     */
;;;42     static uint8_t __f032bSendByte (uint8_t data)
000000  b510              PUSH     {r4,lr}
;;;43     {   
000002  4604              MOV      r4,r0
;;;44     	while(SPI_I2S_GetFlagStatus(SPI1, SPI_I2S_FLAG_TXE) == RESET)//等待发送空
000004  bf00              NOP      
                  |L1.6|
000006  2102              MOVS     r1,#2
000008  48f8              LDR      r0,|L1.1004|
00000a  f7fffffe          BL       SPI_I2S_GetFlagStatus
00000e  2800              CMP      r0,#0
000010  d0f9              BEQ      |L1.6|
;;;45     	{
;;;46     	}
;;;47     	SPI_I2S_SendData(SPI1, data);                                  //发送
000012  4621              MOV      r1,r4
000014  48f5              LDR      r0,|L1.1004|
000016  f7fffffe          BL       SPI_I2S_SendData
;;;48     
;;;49     	while(SPI_I2S_GetFlagStatus(SPI1, SPI_I2S_FLAG_RXNE) == RESET);    //等待接收完成
00001a  bf00              NOP      
                  |L1.28|
00001c  2101              MOVS     r1,#1
00001e  48f3              LDR      r0,|L1.1004|
000020  f7fffffe          BL       SPI_I2S_GetFlagStatus
000024  2800              CMP      r0,#0
000026  d0f9              BEQ      |L1.28|
;;;50     	return SPI_I2S_ReceiveData(SPI1);                              //返回接收的数据
000028  48f0              LDR      r0,|L1.1004|
00002a  f7fffffe          BL       SPI_I2S_ReceiveData
00002e  b2c0              UXTB     r0,r0
;;;51     }
000030  bd10              POP      {r4,pc}
;;;52     
                          ENDP

                  __f032bGetByte PROC
;;;55     */
;;;56     static uint8_t __f032bGetByte (uint8_t *pdata)
000032  b510              PUSH     {r4,lr}
;;;57     {
000034  4604              MOV      r4,r0
;;;58     	*pdata = __f032bSendByte(0xFF);//SPI器件返回需要先发送一个无意义数据，然后接收
000036  20ff              MOVS     r0,#0xff
000038  f7fffffe          BL       __f032bSendByte
00003c  7020              STRB     r0,[r4,#0]
;;;59         return F032BOK;
00003e  2001              MOVS     r0,#1
;;;60     }
000040  bd10              POP      {r4,pc}
;;;61     
                          ENDP

                  __WaitWrEnd PROC
;;;65     */
;;;66     static uint8_t __WaitWrEnd (void)
000042  b538              PUSH     {r3-r5,lr}
;;;67     {   
;;;68         uint8_t StatRgVal = 0;
000044  2000              MOVS     r0,#0
000046  9000              STR      r0,[sp,#0]
;;;69         
;;;70         int32_t n = 0x3ffff;
000048  4ce9              LDR      r4,|L1.1008|
;;;71         
;;;72         
;;;73         do {
00004a  bf00              NOP      
                  |L1.76|
;;;74             __F032B_CE_Low();      
00004c  2010              MOVS     r0,#0x10
00004e  49e9              LDR      r1,|L1.1012|
000050  6008              STR      r0,[r1,#0]
;;;75             __f032bSendByte(__RDSR);      //读状态寄存器             
000052  2005              MOVS     r0,#5
000054  f7fffffe          BL       __f032bSendByte
;;;76             __f032bGetByte(&StatRgVal);                                     /*  保存读得的状态寄存器值       */
000058  4668              MOV      r0,sp
00005a  f7fffffe          BL       __f032bGetByte
;;;77             __F032B_CE_High();
00005e  2010              MOVS     r0,#0x10
000060  49e4              LDR      r1,|L1.1012|
000062  1f09              SUBS     r1,r1,#4
000064  6008              STR      r0,[r1,#0]
;;;78             n--;
000066  1e64              SUBS     r4,r4,#1
;;;79             if (n == 0) {
000068  b904              CBNZ     r4,|L1.108|
;;;80                 break;
00006a  e005              B        |L1.120|
                  |L1.108|
;;;81             }                
;;;82         }
;;;83         while (StatRgVal & 0x1);                                           /*  一直等待，直到芯片空闲       */
00006c  f89d0000          LDRB     r0,[sp,#0]
000070  f0000001          AND      r0,r0,#1
000074  2800              CMP      r0,#0
000076  d1e9              BNE      |L1.76|
                  |L1.120|
000078  bf00              NOP                            ;80
;;;84         
;;;85         if (n > 0)
00007a  2c00              CMP      r4,#0
00007c  dd01              BLE      |L1.130|
;;;86     	{
;;;87             return F032BOK;
00007e  2001              MOVS     r0,#1
                  |L1.128|
;;;88         } 
;;;89     	else 
;;;90     	{
;;;91             return F032BERROR;
;;;92         }
;;;93     }
000080  bd38              POP      {r3-r5,pc}
                  |L1.130|
000082  2000              MOVS     r0,#0                 ;91
000084  e7fc              B        |L1.128|
;;;94     
                          ENDP

                  sst26vf032b_read PROC
;;;131    */
;;;132    uint8_t sst26vf032b_read(uint32_t Dst, uint32_t NByte, volatile uint8_t *RcvBufPt)
000086  e92d43f8          PUSH     {r3-r9,lr}
;;;133    {
00008a  4604              MOV      r4,r0
00008c  460d              MOV      r5,r1
00008e  4690              MOV      r8,r2
;;;134    	uint32_t i = 0 ,j = 0;
000090  2600              MOVS     r6,#0
000092  46b1              MOV      r9,r6
;;;135    	uint8_t err;
;;;136    	uint32_t addr = Dst;
000094  4627              MOV      r7,r4
;;;137        
;;;138        if (((Dst + NByte -1) > __F032B_MAX_ADDR) || (NByte == 0)) {        /*  检查入口参数                 */
000096  1960              ADDS     r0,r4,r5
000098  1e40              SUBS     r0,r0,#1
00009a  f5b00f80          CMP      r0,#0x400000
00009e  d200              BCS      |L1.162|
0000a0  b915              CBNZ     r5,|L1.168|
                  |L1.162|
;;;139            return (F032BERROR);
0000a2  2000              MOVS     r0,#0
                  |L1.164|
;;;140        }
;;;141    	
;;;142      	OSSemPend(SSP_SEM,0,&err);
;;;143    	
;;;144    	while(NByte != 0)
;;;145    	{
;;;146    		__WaitWrEnd();
;;;147    		
;;;148    		__F032B_CE_Low();
;;;149    		__f032bSendByte(__HREAD);    //104M 高速读
;;;150    		__f032bSendByte((uint8_t)((Dst & 0xFFFFFF) >> 16));                   /*  发送地址信息:3个字节组成     */
;;;151    		__f032bSendByte((uint8_t)((Dst & 0xFFFF) >> 8));
;;;152    		__f032bSendByte((uint8_t)(Dst & 0xFF));
;;;153    		__f032bSendByte(0xFF);                                              /*  发送一个哑字节以读取数据     */
;;;154    		
;;;155    		for (i = 0; i < NByte; i++, addr++, j++)
;;;156    		{
;;;157    			if (F032BERROR == __f032bGetByte((uint8_t*)(RcvBufPt + j))) 
;;;158    			{
;;;159    				OSSemPost(SSP_SEM);     
;;;160    				__F032B_CE_High(); 
;;;161    			  return F032BERROR;
;;;162    			} 
;;;163    			
;;;164    			if(addr % 256 == 0 && i != 0)//一次读 256 Byte
;;;165    			{
;;;166    				Dst = addr;
;;;167    				break;
;;;168    			}
;;;169    		}
;;;170    		__F032B_CE_High();//停止读
;;;171    		NByte -= i;
;;;172    
;;;173    
;;;174    //		for (j = 0; (NByte != 0 && j < 256); j++, NByte--)
;;;175    //		{
;;;176    //			if (F032BERROR == __f032bGetByte((uint8_t*)(RcvBufPt ++))) 
;;;177    //			{
;;;178    //				OSSemPost(SSP_SEM);     
;;;179    //				__F032B_CE_High(); 
;;;180    //				return F032BERROR;
;;;181    //			}
;;;182    //		}
;;;183    //		__F032B_CE_High();//停止读
;;;184    //		Dst += 256;
;;;185    	}
;;;186        OSSemPost(SSP_SEM);     
;;;187        return (F032BOK);
;;;188    }
0000a4  e8bd83f8          POP      {r3-r9,pc}
                  |L1.168|
0000a8  466a              MOV      r2,sp                 ;142
0000aa  2100              MOVS     r1,#0                 ;142
0000ac  48d2              LDR      r0,|L1.1016|
0000ae  6800              LDR      r0,[r0,#0]            ;142  ; SSP_SEM
0000b0  f7fffffe          BL       OSSemPend
0000b4  e037              B        |L1.294|
                  |L1.182|
0000b6  f7fffffe          BL       __WaitWrEnd
0000ba  2010              MOVS     r0,#0x10              ;148
0000bc  49cd              LDR      r1,|L1.1012|
0000be  6008              STR      r0,[r1,#0]            ;148
0000c0  200b              MOVS     r0,#0xb               ;149
0000c2  f7fffffe          BL       __f032bSendByte
0000c6  f3c44007          UBFX     r0,r4,#16,#8          ;150
0000ca  f7fffffe          BL       __f032bSendByte
0000ce  f3c42007          UBFX     r0,r4,#8,#8           ;151
0000d2  f7fffffe          BL       __f032bSendByte
0000d6  b2e0              UXTB     r0,r4                 ;152
0000d8  f7fffffe          BL       __f032bSendByte
0000dc  20ff              MOVS     r0,#0xff              ;153
0000de  f7fffffe          BL       __f032bSendByte
0000e2  2600              MOVS     r6,#0                 ;155
0000e4  e017              B        |L1.278|
                  |L1.230|
0000e6  eb080009          ADD      r0,r8,r9              ;157
0000ea  f7fffffe          BL       __f032bGetByte
0000ee  b948              CBNZ     r0,|L1.260|
0000f0  48c1              LDR      r0,|L1.1016|
0000f2  6800              LDR      r0,[r0,#0]            ;159  ; SSP_SEM
0000f4  f7fffffe          BL       OSSemPost
0000f8  2010              MOVS     r0,#0x10              ;160
0000fa  49be              LDR      r1,|L1.1012|
0000fc  1f09              SUBS     r1,r1,#4              ;160
0000fe  6008              STR      r0,[r1,#0]            ;160
000100  2000              MOVS     r0,#0                 ;161
000102  e7cf              B        |L1.164|
                  |L1.260|
000104  b2f8              UXTB     r0,r7                 ;164
000106  b910              CBNZ     r0,|L1.270|
000108  b10e              CBZ      r6,|L1.270|
00010a  463c              MOV      r4,r7                 ;166
00010c  e005              B        |L1.282|
                  |L1.270|
00010e  1c76              ADDS     r6,r6,#1              ;155
000110  1c7f              ADDS     r7,r7,#1              ;155
000112  f1090901          ADD      r9,r9,#1              ;155
                  |L1.278|
000116  42ae              CMP      r6,r5                 ;155
000118  d3e5              BCC      |L1.230|
                  |L1.282|
00011a  bf00              NOP                            ;167
00011c  2010              MOVS     r0,#0x10              ;170
00011e  49b5              LDR      r1,|L1.1012|
000120  1f09              SUBS     r1,r1,#4              ;170
000122  6008              STR      r0,[r1,#0]            ;170
000124  1bad              SUBS     r5,r5,r6              ;171
                  |L1.294|
000126  2d00              CMP      r5,#0                 ;144
000128  d1c5              BNE      |L1.182|
00012a  48b3              LDR      r0,|L1.1016|
00012c  6800              LDR      r0,[r0,#0]            ;186  ; SSP_SEM
00012e  f7fffffe          BL       OSSemPost
000132  2001              MOVS     r0,#1                 ;187
000134  e7b6              B        |L1.164|
;;;189    
                          ENDP

                  sst26vf032b_Jedec_ID_Read PROC
;;;192    */
;;;193    uint8_t sst26vf032b_Jedec_ID_Read (uint32_t *RcvbufPt)
000136  b51c              PUSH     {r2-r4,lr}
;;;194    {
000138  4604              MOV      r4,r0
;;;195        uint8_t temp[4] = {0};
00013a  2000              MOVS     r0,#0
00013c  9001              STR      r0,[sp,#4]
;;;196        uint8_t err;
;;;197    	
;;;198        OSSemPend(SSP_SEM,0,&err);
00013e  466a              MOV      r2,sp
000140  2100              MOVS     r1,#0
000142  48ad              LDR      r0,|L1.1016|
000144  6800              LDR      r0,[r0,#0]  ; SSP_SEM
000146  f7fffffe          BL       OSSemPend
;;;199    	
;;;200    	__WaitWrEnd();
00014a  f7fffffe          BL       __WaitWrEnd
;;;201    	__F032B_CE_Low();
00014e  2010              MOVS     r0,#0x10
000150  49a8              LDR      r1,|L1.1012|
000152  6008              STR      r0,[r1,#0]
;;;202    	__f032bSendByte(0x9F);      //发送读JEDEC ID命令(9Fh)
000154  209f              MOVS     r0,#0x9f
000156  f7fffffe          BL       __f032bSendByte
;;;203    	__f032bGetByte(temp + 2);	//制造商编号	0xBF
00015a  f10d0006          ADD      r0,sp,#6
00015e  f7fffffe          BL       __f032bGetByte
;;;204    	__f032bGetByte(temp + 1);	//设备类型	0x26
000162  f10d0005          ADD      r0,sp,#5
000166  f7fffffe          BL       __f032bGetByte
;;;205    	__f032bGetByte(temp);       //设备ID    0x42    
00016a  a801              ADD      r0,sp,#4
00016c  f7fffffe          BL       __f032bGetByte
;;;206    	__F032B_CE_High();      
000170  2010              MOVS     r0,#0x10
000172  49a0              LDR      r1,|L1.1012|
000174  1f09              SUBS     r1,r1,#4
000176  6008              STR      r0,[r1,#0]
;;;207    	*RcvbufPt = (uint32_t)(temp[0] | (temp[1] << 8) | (temp[2] << 16));
000178  f89d0004          LDRB     r0,[sp,#4]
00017c  f89d1005          LDRB     r1,[sp,#5]
000180  ea402001          ORR      r0,r0,r1,LSL #8
000184  f89d1006          LDRB     r1,[sp,#6]
000188  ea404001          ORR      r0,r0,r1,LSL #16
00018c  6020              STR      r0,[r4,#0]
;;;208    	
;;;209    	OSSemPost(SSP_SEM);
00018e  489a              LDR      r0,|L1.1016|
000190  6800              LDR      r0,[r0,#0]  ; SSP_SEM
000192  f7fffffe          BL       OSSemPost
;;;210    	return (F032BOK);
000196  2001              MOVS     r0,#1
;;;211    }
000198  bd1c              POP      {r2-r4,pc}
;;;212    
                          ENDP

                  sstf032b_IsExist PROC
;;;225    **********************************************************************************************************/
;;;226    uint8_t sstf032b_IsExist (void)
00019a  b508              PUSH     {r3,lr}
;;;227    {
;;;228        uint32_t FId = 0;
00019c  2000              MOVS     r0,#0
00019e  9000              STR      r0,[sp,#0]
;;;229    	
;;;230    	__WaitWrEnd();
0001a0  f7fffffe          BL       __WaitWrEnd
;;;231        if (F032BOK == sst26vf032b_Jedec_ID_Read(&FId)) 
0001a4  4668              MOV      r0,sp
0001a6  f7fffffe          BL       sst26vf032b_Jedec_ID_Read
0001aa  2801              CMP      r0,#1
0001ac  d109              BNE      |L1.450|
;;;232    	{
;;;233            if (0xBF2600 == (FId & 0x00ffff00)) 
0001ae  4993              LDR      r1,|L1.1020|
0001b0  9800              LDR      r0,[sp,#0]
0001b2  4008              ANDS     r0,r0,r1
0001b4  4992              LDR      r1,|L1.1024|
0001b6  4288              CMP      r0,r1
0001b8  d101              BNE      |L1.446|
;;;234    		{
;;;235                return F032BOK;
0001ba  2001              MOVS     r0,#1
                  |L1.444|
;;;236            } 
;;;237    		else 
;;;238    		{
;;;239                return F032BERROR;
;;;240            }
;;;241        } 
;;;242    	else 
;;;243    	{
;;;244            return F032BERROR;
;;;245        }
;;;246    }
0001bc  bd08              POP      {r3,pc}
                  |L1.446|
0001be  2000              MOVS     r0,#0                 ;239
0001c0  e7fc              B        |L1.444|
                  |L1.450|
0001c2  2000              MOVS     r0,#0                 ;244
0001c4  e7fa              B        |L1.444|
;;;247    
                          ENDP

                  sst26vf032b_write PROC
;;;253    */
;;;254    uint8_t sst26vf032b_write (uint32_t Dst, volatile uint8_t *SndbufPt, uint32_t NByte)
0001c6  e92d43f8          PUSH     {r3-r9,lr}
;;;255    {
0001ca  4604              MOV      r4,r0
0001cc  460f              MOV      r7,r1
0001ce  4615              MOV      r5,r2
;;;256        uint32_t i = 0;
0001d0  f04f0800          MOV      r8,#0
;;;257        uint8_t err, status = FALSE;
0001d4  46c1              MOV      r9,r8
;;;258        uint32_t addr = Dst;
0001d6  4626              MOV      r6,r4
;;;259    	
;;;260        
;;;261        if (((Dst + NByte - 1) > __F032B_MAX_ADDR) || (NByte == 0)) {       /*  检查入口参数                 */
0001d8  1960              ADDS     r0,r4,r5
0001da  1e40              SUBS     r0,r0,#1
0001dc  f5b00f80          CMP      r0,#0x400000
0001e0  d200              BCS      |L1.484|
0001e2  b915              CBNZ     r5,|L1.490|
                  |L1.484|
;;;262            return (F032BERROR);                                            
0001e4  2000              MOVS     r0,#0
                  |L1.486|
;;;263        }
;;;264        OSSemPend(SSP_SEM, 0, &err);
;;;265    
;;;266    //	__WaitWrEnd();
;;;267    //	__F032B_CE_Low();     
;;;268    //	__f032bSendByte(__ULBPR);//全局块保护解锁
;;;269    //	__F032B_CE_High();
;;;270    	
;;;271    	while(NByte != 0)//注意，一次写入最多256字节，地址的低8位 A[7:0]需要为0
;;;272    	{
;;;273    		__WaitWrEnd();
;;;274    		
;;;275    		__F032B_CE_Low();     
;;;276    		__f032bSendByte(__WREN);      //首先发送写使能
;;;277    		__F032B_CE_High();
;;;278    		
;;;279    //		__WaitWrOk();
;;;280    		
;;;281    		__F032B_CE_Low();     
;;;282    		__f032bSendByte(__PP);	//页编程
;;;283    		__f032bSendByte((uint8_t)(((Dst & 0xFFFFFF) >> 16)));             /*  发送3个字节的地址信息        */
;;;284    		__f032bSendByte((uint8_t)(((Dst & 0xFFFF) >> 8)));
;;;285    		__f032bSendByte((uint8_t)(Dst & 0xFF));
;;;286    		
;;;287    		for( i = 0; ( NByte != 0 && i < 256 ); (i++, NByte--,addr++) ) //一次最多写256字节
;;;288    		{
;;;289    			if((addr % 256 == 0) && (i != 0) )
;;;290    			{
;;;291    				Dst = addr; 
;;;292    				status = TRUE;
;;;293    				break;
;;;294    			}
;;;295    			__f032bSendByte((uint8_t)(*SndbufPt++));                      /*  发送被烧写的数据             */
;;;296    		}
;;;297    		__F032B_CE_High(); 
;;;298    		__WaitWrEnd();	//等待写完成
;;;299    		
;;;300    		if(NByte != 0)
;;;301    		{
;;;302    			if(status == TRUE)
;;;303    			{
;;;304    				status = FALSE;
;;;305    			}
;;;306    			else
;;;307    			{
;;;308    				Dst += 256;//如果写完256字节后，地址需要加上，再写256字节
;;;309    			}
;;;310    		}
;;;311    
;;;312    
;;;313    //		for( i = 0; ( NByte != 0 && i < 256 ); (i++, NByte--)) //一次最多写256字节
;;;314    //		{
;;;315    //			__f032bSendByte( (uint8_t)(*(SndbufPt++)) );  //缓冲区数据
;;;316    //		}
;;;317    //		__F032B_CE_High();
;;;318    //		__WaitWrEnd();	//等待写完成
;;;319    //		addr += 256;
;;;320    	} 
;;;321    		
;;;322    	__F032B_CE_Low();
;;;323    	__f032bSendByte(__WRDI);      //写禁能
;;;324    	__F032B_CE_High();    
;;;325    	OSSemPost(SSP_SEM);
;;;326        return (F032BOK);   
;;;327    }
0001e6  e8bd83f8          POP      {r3-r9,pc}
                  |L1.490|
0001ea  466a              MOV      r2,sp                 ;264
0001ec  2100              MOVS     r1,#0                 ;264
0001ee  4882              LDR      r0,|L1.1016|
0001f0  6800              LDR      r0,[r0,#0]            ;264  ; SSP_SEM
0001f2  f7fffffe          BL       OSSemPend
0001f6  e043              B        |L1.640|
                  |L1.504|
0001f8  f7fffffe          BL       __WaitWrEnd
0001fc  2010              MOVS     r0,#0x10              ;275
0001fe  497d              LDR      r1,|L1.1012|
000200  6008              STR      r0,[r1,#0]            ;275
000202  2006              MOVS     r0,#6                 ;276
000204  f7fffffe          BL       __f032bSendByte
000208  2010              MOVS     r0,#0x10              ;277
00020a  497a              LDR      r1,|L1.1012|
00020c  1f09              SUBS     r1,r1,#4              ;277
00020e  6008              STR      r0,[r1,#0]            ;277
000210  1d09              ADDS     r1,r1,#4              ;281
000212  6008              STR      r0,[r1,#0]            ;281
000214  2002              MOVS     r0,#2                 ;282
000216  f7fffffe          BL       __f032bSendByte
00021a  f3c44007          UBFX     r0,r4,#16,#8          ;283
00021e  f7fffffe          BL       __f032bSendByte
000222  f3c42007          UBFX     r0,r4,#8,#8           ;284
000226  f7fffffe          BL       __f032bSendByte
00022a  b2e0              UXTB     r0,r4                 ;285
00022c  f7fffffe          BL       __f032bSendByte
000230  f04f0800          MOV      r8,#0                 ;287
000234  e010              B        |L1.600|
                  |L1.566|
000236  b2f0              UXTB     r0,r6                 ;289
000238  b930              CBNZ     r0,|L1.584|
00023a  f1b80f00          CMP      r8,#0                 ;289
00023e  d003              BEQ      |L1.584|
000240  4634              MOV      r4,r6                 ;291
000242  f04f0901          MOV      r9,#1                 ;292
000246  e00b              B        |L1.608|
                  |L1.584|
000248  f8170b01          LDRB     r0,[r7],#1            ;295
00024c  f7fffffe          BL       __f032bSendByte
000250  f1080801          ADD      r8,r8,#1              ;287
000254  1e6d              SUBS     r5,r5,#1              ;287
000256  1c76              ADDS     r6,r6,#1              ;287
                  |L1.600|
000258  b115              CBZ      r5,|L1.608|
00025a  f1b80fff          CMP      r8,#0xff              ;287
00025e  d9ea              BLS      |L1.566|
                  |L1.608|
000260  bf00              NOP                            ;293
000262  2010              MOVS     r0,#0x10              ;297
000264  4963              LDR      r1,|L1.1012|
000266  1f09              SUBS     r1,r1,#4              ;297
000268  6008              STR      r0,[r1,#0]            ;297
00026a  f7fffffe          BL       __WaitWrEnd
00026e  b13d              CBZ      r5,|L1.640|
000270  f1b90f01          CMP      r9,#1                 ;302
000274  d102              BNE      |L1.636|
000276  f04f0900          MOV      r9,#0                 ;304
00027a  e001              B        |L1.640|
                  |L1.636|
00027c  f5047480          ADD      r4,r4,#0x100          ;308
                  |L1.640|
000280  2d00              CMP      r5,#0                 ;271
000282  d1b9              BNE      |L1.504|
000284  2010              MOVS     r0,#0x10              ;322
000286  495b              LDR      r1,|L1.1012|
000288  6008              STR      r0,[r1,#0]            ;322
00028a  2004              MOVS     r0,#4                 ;323
00028c  f7fffffe          BL       __f032bSendByte
000290  2010              MOVS     r0,#0x10              ;324
000292  4958              LDR      r1,|L1.1012|
000294  1f09              SUBS     r1,r1,#4              ;324
000296  6008              STR      r0,[r1,#0]            ;324
000298  4857              LDR      r0,|L1.1016|
00029a  6800              LDR      r0,[r0,#0]            ;325  ; SSP_SEM
00029c  f7fffffe          BL       OSSemPost
0002a0  2001              MOVS     r0,#1                 ;326
0002a2  e7a0              B        |L1.486|
;;;328    
                          ENDP

                  sst26vf032b_erase PROC
;;;336    **********************************************************************************************************/
;;;337    uint8_t sst26vf032b_erase (uint32_t sec1, uint32_t sec2)
0002a4  e92d43f8          PUSH     {r3-r9,lr}
;;;338    {
0002a8  4604              MOV      r4,r0
0002aa  460d              MOV      r5,r1
;;;339        uint8_t  err;
;;;340        uint32_t temp        = 0;
0002ac  f04f0900          MOV      r9,#0
;;;341        uint32_t SecnHdAddr  = 0;          
0002b0  2600              MOVS     r6,#0
;;;342        uint32_t no_SecsToEr = 0;                                             /*  要擦除的扇区数目             */
0002b2  2700              MOVS     r7,#0
;;;343        uint32_t CurSecToEr  = 0;                                             /*  当前要擦除的扇区号           */
0002b4  46b0              MOV      r8,r6
;;;344        
;;;345        if ((sec1 > __F032B_SEC_MAX) || (sec2 > __F032B_SEC_MAX)) {
0002b6  f5b46f80          CMP      r4,#0x400
0002ba  d202              BCS      |L1.706|
0002bc  f5b56f80          CMP      r5,#0x400
0002c0  d302              BCC      |L1.712|
                  |L1.706|
;;;346            return (F032BERROR);  
0002c2  2000              MOVS     r0,#0
                  |L1.708|
;;;347        }
;;;348    	
;;;349        OSSemPend(SSP_SEM, 0, &err);
;;;350    	
;;;351        if (sec1 > sec2) {                                                  /*  如果用户输入的起始扇区号大于 */
;;;352                                                                            /*  终止扇区号，则在内部作出调整 */
;;;353            temp = sec1;
;;;354            sec1 = sec2;
;;;355            sec2 = temp;
;;;356        } 
;;;357     
;;;358        if (sec1 == sec2) {                                                 /*  起止扇区号相等则擦除单个扇区 */
;;;359            SecnHdAddr = __F032B_SEC_SIZE * sec1;                           /*  计算扇区的起始地址           */
;;;360    		__WaitWrEnd();
;;;361    		
;;;362    		__F032B_CE_Low();     
;;;363    		__f032bSendByte(__WREN);        //写使能
;;;364    		__F032B_CE_High();      
;;;365    		
;;;366    //		__WaitWrOk();
;;;367    
;;;368    		__F032B_CE_Low();     
;;;369            __f032bSendByte(__SE);        //扇区擦除指令，擦除4k指令
;;;370            __f032bSendByte((uint8_t)(((SecnHdAddr & 0xFFFFFF) >> 16)));   //发送擦除起始地址
;;;371            __f032bSendByte((uint8_t)(((SecnHdAddr & 0xFFFF) >> 8)));
;;;372            __f032bSendByte((uint8_t)(SecnHdAddr & 0xFF));
;;;373            __F032B_CE_High();      
;;;374            __WaitWrEnd();
;;;375            goto EraseEnd;     
;;;376        }
;;;377      
;;;378    
;;;379    	//擦除整片
;;;380        if ((sec2 - sec1) == __F032B_SEC_MAX) {                             /*  根据起始扇区和终止扇区间距调 */
;;;381                                                                            /*  用最快速的擦除功能           */ 
;;;382    		__WaitWrEnd();
;;;383    		
;;;384    //		__F032B_CE_Low();     
;;;385    //		__f032bSendByte(__ULBPR);//全局块保护解锁
;;;386    //		__F032B_CE_High();
;;;387    		
;;;388    		__F032B_CE_Low();
;;;389    		__f032bSendByte(__WREN);        //写使能
;;;390    		__F032B_CE_High();
;;;391    		
;;;392    //		__WaitWrOk();
;;;393    		
;;;394    		__F032B_CE_Low();
;;;395            __f032bSendByte(0xC7);  //擦除整片 0xc7
;;;396            __F032B_CE_High();
;;;397            __WaitWrEnd();
;;;398            goto EraseEnd;
;;;399        }
;;;400      
;;;401        no_SecsToEr = sec2 - sec1 + 1;                                      /*  获取要擦除的扇区数目         */
;;;402        CurSecToEr  = sec1;                                                 /*  从起始扇区开始擦除           */
;;;403      
;;;404        while (no_SecsToEr >= 1) {                                          /*  用扇区擦除算法擦除剩余扇区   */
;;;405            SecnHdAddr = __F032B_SEC_SIZE * CurSecToEr;                     /*  计算扇区的起始地址           */
;;;406    
;;;407    		__WaitWrEnd();
;;;408    		
;;;409    		__F032B_CE_Low();     
;;;410    		__f032bSendByte(__WREN);        //写使能
;;;411    		__F032B_CE_High();
;;;412    		
;;;413    //		__WaitWrOk();
;;;414    		
;;;415    		__F032B_CE_Low(); 
;;;416            __f032bSendByte(__SE);     //发送扇区擦除指令  0x20
;;;417            __f032bSendByte((uint8_t)(((SecnHdAddr & 0xFFFFFF) >> 16)));      /*  发送3个字节的地址信息        */
;;;418            __f032bSendByte((uint8_t)(((SecnHdAddr & 0xFFFF) >> 8)));
;;;419            __f032bSendByte((uint8_t)(SecnHdAddr & 0xFF));
;;;420            __F032B_CE_High();      
;;;421            __WaitWrEnd();		//等待完成
;;;422            CurSecToEr  += 1;
;;;423            no_SecsToEr -= 1;
;;;424        }
;;;425        
;;;426    EraseEnd:
;;;427        __F032B_CE_Low();  
;;;428        __f032bSendByte(__WRDI);   //发送写禁能 0x04
;;;429        __F032B_CE_High();      
;;;430    
;;;431        OSSemPost(SSP_SEM);
;;;432        return (F032BOK);
;;;433    }
0002c4  e8bd83f8          POP      {r3-r9,pc}
                  |L1.712|
0002c8  466a              MOV      r2,sp                 ;349
0002ca  2100              MOVS     r1,#0                 ;349
0002cc  484a              LDR      r0,|L1.1016|
0002ce  6800              LDR      r0,[r0,#0]            ;349  ; SSP_SEM
0002d0  f7fffffe          BL       OSSemPend
0002d4  42ac              CMP      r4,r5                 ;351
0002d6  d902              BLS      |L1.734|
0002d8  46a1              MOV      r9,r4                 ;353
0002da  462c              MOV      r4,r5                 ;354
0002dc  464d              MOV      r5,r9                 ;355
                  |L1.734|
0002de  42ac              CMP      r4,r5                 ;358
0002e0  d123              BNE      |L1.810|
0002e2  0326              LSLS     r6,r4,#12             ;359
0002e4  f7fffffe          BL       __WaitWrEnd
0002e8  2010              MOVS     r0,#0x10              ;362
0002ea  4942              LDR      r1,|L1.1012|
0002ec  6008              STR      r0,[r1,#0]            ;362
0002ee  2006              MOVS     r0,#6                 ;363
0002f0  f7fffffe          BL       __f032bSendByte
0002f4  2010              MOVS     r0,#0x10              ;364
0002f6  493f              LDR      r1,|L1.1012|
0002f8  1f09              SUBS     r1,r1,#4              ;364
0002fa  6008              STR      r0,[r1,#0]            ;364
0002fc  1d09              ADDS     r1,r1,#4              ;368
0002fe  6008              STR      r0,[r1,#0]            ;368
000300  2020              MOVS     r0,#0x20              ;369
000302  f7fffffe          BL       __f032bSendByte
000306  f3c64007          UBFX     r0,r6,#16,#8          ;370
00030a  f7fffffe          BL       __f032bSendByte
00030e  f3c62007          UBFX     r0,r6,#8,#8           ;371
000312  f7fffffe          BL       __f032bSendByte
000316  b2f0              UXTB     r0,r6                 ;372
000318  f7fffffe          BL       __f032bSendByte
00031c  2010              MOVS     r0,#0x10              ;373
00031e  4935              LDR      r1,|L1.1012|
000320  1f09              SUBS     r1,r1,#4              ;373
000322  6008              STR      r0,[r1,#0]            ;373
000324  f7fffffe          BL       __WaitWrEnd
000328  e04a              B        |L1.960|
                  |L1.810|
00032a  1b28              SUBS     r0,r5,r4              ;380
00032c  f24031ff          MOV      r1,#0x3ff             ;380
000330  4288              CMP      r0,r1                 ;380
000332  d117              BNE      |L1.868|
000334  f7fffffe          BL       __WaitWrEnd
000338  2010              MOVS     r0,#0x10              ;388
00033a  492e              LDR      r1,|L1.1012|
00033c  6008              STR      r0,[r1,#0]            ;388
00033e  2006              MOVS     r0,#6                 ;389
000340  f7fffffe          BL       __f032bSendByte
000344  2010              MOVS     r0,#0x10              ;390
000346  492b              LDR      r1,|L1.1012|
000348  1f09              SUBS     r1,r1,#4              ;390
00034a  6008              STR      r0,[r1,#0]            ;390
00034c  1d09              ADDS     r1,r1,#4              ;394
00034e  6008              STR      r0,[r1,#0]            ;394
000350  20c7              MOVS     r0,#0xc7              ;395
000352  f7fffffe          BL       __f032bSendByte
000356  2010              MOVS     r0,#0x10              ;396
000358  4926              LDR      r1,|L1.1012|
00035a  1f09              SUBS     r1,r1,#4              ;396
00035c  6008              STR      r0,[r1,#0]            ;396
00035e  f7fffffe          BL       __WaitWrEnd
000362  e02d              B        |L1.960|
                  |L1.868|
000364  1b28              SUBS     r0,r5,r4              ;401
000366  1c47              ADDS     r7,r0,#1              ;401
000368  46a0              MOV      r8,r4                 ;402
00036a  e026              B        |L1.954|
                  |L1.876|
00036c  ea4f3608          LSL      r6,r8,#12             ;405
000370  f7fffffe          BL       __WaitWrEnd
000374  2010              MOVS     r0,#0x10              ;409
000376  491f              LDR      r1,|L1.1012|
000378  6008              STR      r0,[r1,#0]            ;409
00037a  2006              MOVS     r0,#6                 ;410
00037c  f7fffffe          BL       __f032bSendByte
000380  2010              MOVS     r0,#0x10              ;411
000382  491c              LDR      r1,|L1.1012|
000384  1f09              SUBS     r1,r1,#4              ;411
000386  6008              STR      r0,[r1,#0]            ;411
000388  1d09              ADDS     r1,r1,#4              ;415
00038a  6008              STR      r0,[r1,#0]            ;415
00038c  2020              MOVS     r0,#0x20              ;416
00038e  f7fffffe          BL       __f032bSendByte
000392  f3c64007          UBFX     r0,r6,#16,#8          ;417
000396  f7fffffe          BL       __f032bSendByte
00039a  f3c62007          UBFX     r0,r6,#8,#8           ;418
00039e  f7fffffe          BL       __f032bSendByte
0003a2  b2f0              UXTB     r0,r6                 ;419
0003a4  f7fffffe          BL       __f032bSendByte
0003a8  2010              MOVS     r0,#0x10              ;420
0003aa  4912              LDR      r1,|L1.1012|
0003ac  1f09              SUBS     r1,r1,#4              ;420
0003ae  6008              STR      r0,[r1,#0]            ;420
0003b0  f7fffffe          BL       __WaitWrEnd
0003b4  f1080801          ADD      r8,r8,#1              ;422
0003b8  1e7f              SUBS     r7,r7,#1              ;423
                  |L1.954|
0003ba  2f00              CMP      r7,#0                 ;404
0003bc  d1d6              BNE      |L1.876|
0003be  bf00              NOP                            ;426
                  |L1.960|
0003c0  2010              MOVS     r0,#0x10              ;427
0003c2  490c              LDR      r1,|L1.1012|
0003c4  6008              STR      r0,[r1,#0]            ;427
0003c6  2004              MOVS     r0,#4                 ;428
0003c8  f7fffffe          BL       __f032bSendByte
0003cc  2010              MOVS     r0,#0x10              ;429
0003ce  4909              LDR      r1,|L1.1012|
0003d0  1f09              SUBS     r1,r1,#4              ;429
0003d2  6008              STR      r0,[r1,#0]            ;429
0003d4  4808              LDR      r0,|L1.1016|
0003d6  6800              LDR      r0,[r0,#0]            ;431  ; SSP_SEM
0003d8  f7fffffe          BL       OSSemPost
0003dc  2001              MOVS     r0,#1                 ;432
0003de  e771              B        |L1.708|
;;;434    
                          ENDP

                  sst26vf32b_test1 PROC
;;;444    */
;;;445    void sst26vf32b_test1(void)
0003e0  b530              PUSH     {r4,r5,lr}
;;;446    {
0003e2  b081              SUB      sp,sp,#4
0003e4  f5ad5d00          SUB      sp,sp,#0x2000
;;;447    	uint32_t i,j ;
;;;448    	uint8_t recv[4096], str[4096];
;;;449    	for(j = 0; j < 0x400; j++)
0003e8  2500              MOVS     r5,#0
0003ea  e065              B        |L1.1208|
                  |L1.1004|
                          DCD      0x40013000
                  |L1.1008|
                          DCD      0x0003ffff
                  |L1.1012|
                          DCD      0x40010814
                  |L1.1016|
                          DCD      SSP_SEM
                  |L1.1020|
                          DCD      0x00ffff00
                  |L1.1024|
                          DCD      0x00bf2600
                  |L1.1028|
;;;450    	{
;;;451    		for(i = 0; i<4096; i++)
000404  2400              MOVS     r4,#0
000406  e006              B        |L1.1046|
                  |L1.1032|
;;;452    		{
;;;453    			str[i] = i; 
000408  a901              ADD      r1,sp,#4
00040a  550c              STRB     r4,[r1,r4]
;;;454    			recv[i] = 3; 
00040c  2003              MOVS     r0,#3
00040e  f5015180          ADD      r1,r1,#0x1000
000412  5508              STRB     r0,[r1,r4]
000414  1c64              ADDS     r4,r4,#1              ;451
                  |L1.1046|
000416  f5b45f80          CMP      r4,#0x1000            ;451
00041a  d3f5              BCC      |L1.1032|
;;;455    			
;;;456    		}
;;;457    		sst26vf032b_erase(0, j);
00041c  4629              MOV      r1,r5
00041e  2000              MOVS     r0,#0
000420  f7fffffe          BL       sst26vf032b_erase
;;;458    		sst26vf032b_read(j  ,4096 , recv);
000424  f2410204          MOV      r2,#0x1004
000428  446a              ADD      r2,r2,sp
00042a  f44f5180          MOV      r1,#0x1000
00042e  4628              MOV      r0,r5
000430  f7fffffe          BL       sst26vf032b_read
;;;459    		for(i = 0; i<4096; i++)
000434  2400              MOVS     r4,#0
000436  e007              B        |L1.1096|
                  |L1.1080|
;;;460    		{
;;;461    			if(recv[i] != 0xff)
000438  f2410004          MOV      r0,#0x1004
00043c  4468              ADD      r0,r0,sp
00043e  5d00              LDRB     r0,[r0,r4]
000440  28ff              CMP      r0,#0xff
000442  d000              BEQ      |L1.1094|
;;;462    			 i = i;
000444  bf00              NOP      
                  |L1.1094|
000446  1c64              ADDS     r4,r4,#1              ;459
                  |L1.1096|
000448  f5b45f80          CMP      r4,#0x1000            ;459
00044c  d3f4              BCC      |L1.1080|
;;;463    		}
;;;464    		sst26vf032b_write(j , str ,4096);
00044e  f44f5280          MOV      r2,#0x1000
000452  a901              ADD      r1,sp,#4
000454  4628              MOV      r0,r5
000456  f7fffffe          BL       sst26vf032b_write
;;;465    		sst26vf032b_read(j  ,4096 , recv);
00045a  f2410204          MOV      r2,#0x1004
00045e  446a              ADD      r2,r2,sp
000460  f44f5180          MOV      r1,#0x1000
000464  4628              MOV      r0,r5
000466  f7fffffe          BL       sst26vf032b_read
;;;466    		for(i = 0; i<4096; i++)
00046a  2400              MOVS     r4,#0
00046c  e009              B        |L1.1154|
                  |L1.1134|
;;;467    		{
;;;468    			if(recv[i] != str[i])
00046e  f2410004          MOV      r0,#0x1004
000472  4468              ADD      r0,r0,sp
000474  5d00              LDRB     r0,[r0,r4]
000476  a901              ADD      r1,sp,#4
000478  5d09              LDRB     r1,[r1,r4]
00047a  4288              CMP      r0,r1
00047c  d000              BEQ      |L1.1152|
;;;469    			 i = i;
00047e  bf00              NOP      
                  |L1.1152|
000480  1c64              ADDS     r4,r4,#1              ;466
                  |L1.1154|
000482  f5b45f80          CMP      r4,#0x1000            ;466
000486  d3f2              BCC      |L1.1134|
;;;470    		}
;;;471    		sst26vf032b_read(j  ,4096 , recv);
000488  f2410204          MOV      r2,#0x1004
00048c  446a              ADD      r2,r2,sp
00048e  f44f5180          MOV      r1,#0x1000
000492  4628              MOV      r0,r5
000494  f7fffffe          BL       sst26vf032b_read
;;;472    		for(i = 0; i<4096; i++)
000498  2400              MOVS     r4,#0
00049a  e009              B        |L1.1200|
                  |L1.1180|
;;;473    		{
;;;474    			if(recv[i] != str[i])
00049c  f2410004          MOV      r0,#0x1004
0004a0  4468              ADD      r0,r0,sp
0004a2  5d00              LDRB     r0,[r0,r4]
0004a4  a901              ADD      r1,sp,#4
0004a6  5d09              LDRB     r1,[r1,r4]
0004a8  4288              CMP      r0,r1
0004aa  d000              BEQ      |L1.1198|
;;;475    			 i = i;
0004ac  bf00              NOP      
                  |L1.1198|
0004ae  1c64              ADDS     r4,r4,#1              ;472
                  |L1.1200|
0004b0  f5b45f80          CMP      r4,#0x1000            ;472
0004b4  d3f2              BCC      |L1.1180|
0004b6  1c6d              ADDS     r5,r5,#1              ;449
                  |L1.1208|
0004b8  f5b56f80          CMP      r5,#0x400             ;449
0004bc  d3a2              BCC      |L1.1028|
;;;476    		}
;;;477    	}
;;;478    	OSTimeDly(1000);
0004be  f44f707a          MOV      r0,#0x3e8
0004c2  f7fffffe          BL       OSTimeDly
;;;479    }
0004c6  b001              ADD      sp,sp,#4
0004c8  f50d5d00          ADD      sp,sp,#0x2000
0004cc  bd30              POP      {r4,r5,pc}
;;;480    /*
                          ENDP

                  sst26vf32b_test2 PROC
;;;485    
;;;486    void sst26vf32b_test2(void)
0004ce  f5ad5d00          SUB      sp,sp,#0x2000
;;;487    {
;;;488    	uint8_t recv[4096], str[4096];
;;;489    	while(1)
0004d2  e103              B        |L1.1756|
                  |L1.1236|
;;;490    	{
;;;491    		for(j = 0; j < 0x3ff; j++)
0004d4  2000              MOVS     r0,#0
0004d6  49b7              LDR      r1,|L1.1972|
0004d8  6008              STR      r0,[r1,#0]  ; j
0004da  e0f0              B        |L1.1726|
                  |L1.1244|
;;;492    		{
;;;493    			for(i = 0; i<4096; i++)
0004dc  2000              MOVS     r0,#0
0004de  49b6              LDR      r1,|L1.1976|
0004e0  6008              STR      r0,[r1,#0]  ; i
0004e2  e010              B        |L1.1286|
                  |L1.1252|
;;;494    			{
;;;495    				str[i] = i; 
0004e4  48b4              LDR      r0,|L1.1976|
0004e6  7800              LDRB     r0,[r0,#0]  ; i
0004e8  4ab3              LDR      r2,|L1.1976|
0004ea  6812              LDR      r2,[r2,#0]  ; i
0004ec  f80d0002          STRB     r0,[sp,r2]
;;;496    				recv[i] = 0; 
0004f0  2000              MOVS     r0,#0
0004f2  f50d5180          ADD      r1,sp,#0x1000
0004f6  4ab0              LDR      r2,|L1.1976|
0004f8  6812              LDR      r2,[r2,#0]  ; i
0004fa  5488              STRB     r0,[r1,r2]
0004fc  48ae              LDR      r0,|L1.1976|
0004fe  6800              LDR      r0,[r0,#0]            ;493  ; i
000500  1c40              ADDS     r0,r0,#1              ;493
000502  49ad              LDR      r1,|L1.1976|
000504  6008              STR      r0,[r1,#0]            ;493  ; i
                  |L1.1286|
000506  48ac              LDR      r0,|L1.1976|
000508  6800              LDR      r0,[r0,#0]            ;493  ; i
00050a  f5b05f80          CMP      r0,#0x1000            ;493
00050e  d3e9              BCC      |L1.1252|
;;;497    				
;;;498    			}
;;;499    			sst26vf032b_erase(j, j+1);
000510  48a8              LDR      r0,|L1.1972|
000512  6801              LDR      r1,[r0,#0]  ; j
000514  1c49              ADDS     r1,r1,#1
000516  6800              LDR      r0,[r0,#0]  ; j
000518  f7fffffe          BL       sst26vf032b_erase
;;;500    			sst26vf032b_write(j*4096 + 13 , str, 4096);
00051c  49a5              LDR      r1,|L1.1972|
00051e  6809              LDR      r1,[r1,#0]  ; j
000520  220d              MOVS     r2,#0xd
000522  eb023001          ADD      r0,r2,r1,LSL #12
000526  f44f5280          MOV      r2,#0x1000
00052a  4669              MOV      r1,sp
00052c  f7fffffe          BL       sst26vf032b_write
;;;501    			sst26vf032b_read(j*4096 + 13  ,4096 , recv);
000530  49a0              LDR      r1,|L1.1972|
000532  6809              LDR      r1,[r1,#0]  ; j
000534  220d              MOVS     r2,#0xd
000536  eb023001          ADD      r0,r2,r1,LSL #12
00053a  f50d5280          ADD      r2,sp,#0x1000
00053e  f44f5180          MOV      r1,#0x1000
000542  f7fffffe          BL       sst26vf032b_read
;;;502    			for(i = 0; i < 63; i++)
000546  2000              MOVS     r0,#0
000548  499b              LDR      r1,|L1.1976|
00054a  6008              STR      r0,[r1,#0]  ; i
00054c  e013              B        |L1.1398|
                  |L1.1358|
;;;503    			{
;;;504    				if(str[i] != recv[i])
00054e  499a              LDR      r1,|L1.1976|
000550  6809              LDR      r1,[r1,#0]  ; i
000552  f81d0001          LDRB     r0,[sp,r1]
000556  f50d5180          ADD      r1,sp,#0x1000
00055a  4a97              LDR      r2,|L1.1976|
00055c  6812              LDR      r2,[r2,#0]  ; i
00055e  5c89              LDRB     r1,[r1,r2]
000560  4288              CMP      r0,r1
000562  d003              BEQ      |L1.1388|
;;;505    				{
;;;506    					i = i;
000564  4894              LDR      r0,|L1.1976|
000566  6800              LDR      r0,[r0,#0]  ; i
000568  4993              LDR      r1,|L1.1976|
00056a  6008              STR      r0,[r1,#0]  ; i
                  |L1.1388|
00056c  4892              LDR      r0,|L1.1976|
00056e  6800              LDR      r0,[r0,#0]            ;502  ; i
000570  1c40              ADDS     r0,r0,#1              ;502
000572  4991              LDR      r1,|L1.1976|
000574  6008              STR      r0,[r1,#0]            ;502  ; i
                  |L1.1398|
000576  4890              LDR      r0,|L1.1976|
000578  6800              LDR      r0,[r0,#0]            ;502  ; i
00057a  283f              CMP      r0,#0x3f              ;502
00057c  d3e7              BCC      |L1.1358|
;;;507    				}
;;;508    			}
;;;509    
;;;510    			if(j > 1)
00057e  488d              LDR      r0,|L1.1972|
000580  6800              LDR      r0,[r0,#0]  ; j
000582  2801              CMP      r0,#1
000584  d90e              BLS      |L1.1444|
;;;511    			sst26vf032b_erase(j*4093/4096 - 1, j+1);
000586  498b              LDR      r1,|L1.1972|
000588  6809              LDR      r1,[r1,#0]  ; j
00058a  eb010241          ADD      r2,r1,r1,LSL #1
00058e  ebc23101          RSB      r1,r2,r1,LSL #12
000592  2201              MOVS     r2,#1
000594  ebc23011          RSB      r0,r2,r1,LSR #12
000598  4986              LDR      r1,|L1.1972|
00059a  6809              LDR      r1,[r1,#0]  ; j
00059c  1c49              ADDS     r1,r1,#1
00059e  f7fffffe          BL       sst26vf032b_erase
0005a2  e005              B        |L1.1456|
                  |L1.1444|
;;;512    			else
;;;513    			sst26vf032b_erase(0, j+1);
0005a4  4883              LDR      r0,|L1.1972|
0005a6  6801              LDR      r1,[r0,#0]  ; j
0005a8  1c49              ADDS     r1,r1,#1
0005aa  2000              MOVS     r0,#0
0005ac  f7fffffe          BL       sst26vf032b_erase
                  |L1.1456|
;;;514    			
;;;515    			sst26vf032b_read(j*4093  ,4096 , recv);
0005b0  4980              LDR      r1,|L1.1972|
0005b2  6809              LDR      r1,[r1,#0]  ; j
0005b4  eb010241          ADD      r2,r1,r1,LSL #1
0005b8  ebc23001          RSB      r0,r2,r1,LSL #12
0005bc  f50d5280          ADD      r2,sp,#0x1000
0005c0  f44f5180          MOV      r1,#0x1000
0005c4  f7fffffe          BL       sst26vf032b_read
;;;516    			for(i = 0; i<4096; i++)
0005c8  2000              MOVS     r0,#0
0005ca  497b              LDR      r1,|L1.1976|
0005cc  6008              STR      r0,[r1,#0]  ; i
0005ce  e00f              B        |L1.1520|
                  |L1.1488|
;;;517    			{
;;;518    				if(recv[i] != 0xff)
0005d0  f50d5080          ADD      r0,sp,#0x1000
0005d4  4978              LDR      r1,|L1.1976|
0005d6  6809              LDR      r1,[r1,#0]  ; i
0005d8  5c40              LDRB     r0,[r0,r1]
0005da  28ff              CMP      r0,#0xff
0005dc  d003              BEQ      |L1.1510|
;;;519    				 i = i;
0005de  4876              LDR      r0,|L1.1976|
0005e0  6800              LDR      r0,[r0,#0]  ; i
0005e2  4975              LDR      r1,|L1.1976|
0005e4  6008              STR      r0,[r1,#0]  ; i
                  |L1.1510|
0005e6  4874              LDR      r0,|L1.1976|
0005e8  6800              LDR      r0,[r0,#0]            ;516  ; i
0005ea  1c40              ADDS     r0,r0,#1              ;516
0005ec  4972              LDR      r1,|L1.1976|
0005ee  6008              STR      r0,[r1,#0]            ;516  ; i
                  |L1.1520|
0005f0  4871              LDR      r0,|L1.1976|
0005f2  6800              LDR      r0,[r0,#0]            ;516  ; i
0005f4  f5b05f80          CMP      r0,#0x1000            ;516
0005f8  d3ea              BCC      |L1.1488|
;;;520    			}
;;;521    			sst26vf032b_write(j*4093 , str ,4096);
0005fa  496e              LDR      r1,|L1.1972|
0005fc  6809              LDR      r1,[r1,#0]  ; j
0005fe  eb010241          ADD      r2,r1,r1,LSL #1
000602  ebc23001          RSB      r0,r2,r1,LSL #12
000606  f44f5280          MOV      r2,#0x1000
00060a  4669              MOV      r1,sp
00060c  f7fffffe          BL       sst26vf032b_write
;;;522    			sst26vf032b_read(j*4093  ,4096 , recv);
000610  4968              LDR      r1,|L1.1972|
000612  6809              LDR      r1,[r1,#0]  ; j
000614  eb010241          ADD      r2,r1,r1,LSL #1
000618  ebc23001          RSB      r0,r2,r1,LSL #12
00061c  f50d5280          ADD      r2,sp,#0x1000
000620  f44f5180          MOV      r1,#0x1000
000624  f7fffffe          BL       sst26vf032b_read
;;;523    			for(i = 0; i<4096; i++)
000628  2000              MOVS     r0,#0
00062a  4963              LDR      r1,|L1.1976|
00062c  6008              STR      r0,[r1,#0]  ; i
00062e  e013              B        |L1.1624|
                  |L1.1584|
;;;524    			{
;;;525    				if(recv[i] != str[i])
000630  f50d5080          ADD      r0,sp,#0x1000
000634  4960              LDR      r1,|L1.1976|
000636  6809              LDR      r1,[r1,#0]  ; i
000638  5c40              LDRB     r0,[r0,r1]
00063a  4a5f              LDR      r2,|L1.1976|
00063c  6812              LDR      r2,[r2,#0]  ; i
00063e  f81d1002          LDRB     r1,[sp,r2]
000642  4288              CMP      r0,r1
000644  d003              BEQ      |L1.1614|
;;;526    				 i = i;
000646  485c              LDR      r0,|L1.1976|
000648  6800              LDR      r0,[r0,#0]  ; i
00064a  495b              LDR      r1,|L1.1976|
00064c  6008              STR      r0,[r1,#0]  ; i
                  |L1.1614|
00064e  485a              LDR      r0,|L1.1976|
000650  6800              LDR      r0,[r0,#0]            ;523  ; i
000652  1c40              ADDS     r0,r0,#1              ;523
000654  4958              LDR      r1,|L1.1976|
000656  6008              STR      r0,[r1,#0]            ;523  ; i
                  |L1.1624|
000658  4857              LDR      r0,|L1.1976|
00065a  6800              LDR      r0,[r0,#0]            ;523  ; i
00065c  f5b05f80          CMP      r0,#0x1000            ;523
000660  d3e6              BCC      |L1.1584|
;;;527    			}
;;;528    			sst26vf032b_read(j*4093  ,4096 , recv);
000662  4954              LDR      r1,|L1.1972|
000664  6809              LDR      r1,[r1,#0]  ; j
000666  eb010241          ADD      r2,r1,r1,LSL #1
00066a  ebc23001          RSB      r0,r2,r1,LSL #12
00066e  f50d5280          ADD      r2,sp,#0x1000
000672  f44f5180          MOV      r1,#0x1000
000676  f7fffffe          BL       sst26vf032b_read
;;;529    			for(i = 0; i<4096; i++)
00067a  2000              MOVS     r0,#0
00067c  494e              LDR      r1,|L1.1976|
00067e  6008              STR      r0,[r1,#0]  ; i
000680  e013              B        |L1.1706|
                  |L1.1666|
;;;530    			{
;;;531    				if(recv[i] != str[i])
000682  f50d5080          ADD      r0,sp,#0x1000
000686  494c              LDR      r1,|L1.1976|
000688  6809              LDR      r1,[r1,#0]  ; i
00068a  5c40              LDRB     r0,[r0,r1]
00068c  4a4a              LDR      r2,|L1.1976|
00068e  6812              LDR      r2,[r2,#0]  ; i
000690  f81d1002          LDRB     r1,[sp,r2]
000694  4288              CMP      r0,r1
000696  d003              BEQ      |L1.1696|
;;;532    				 i = i;
000698  4847              LDR      r0,|L1.1976|
00069a  6800              LDR      r0,[r0,#0]  ; i
00069c  4946              LDR      r1,|L1.1976|
00069e  6008              STR      r0,[r1,#0]  ; i
                  |L1.1696|
0006a0  4845              LDR      r0,|L1.1976|
0006a2  6800              LDR      r0,[r0,#0]            ;529  ; i
0006a4  1c40              ADDS     r0,r0,#1              ;529
0006a6  4944              LDR      r1,|L1.1976|
0006a8  6008              STR      r0,[r1,#0]            ;529  ; i
                  |L1.1706|
0006aa  4843              LDR      r0,|L1.1976|
0006ac  6800              LDR      r0,[r0,#0]            ;529  ; i
0006ae  f5b05f80          CMP      r0,#0x1000            ;529
0006b2  d3e6              BCC      |L1.1666|
0006b4  483f              LDR      r0,|L1.1972|
0006b6  6800              LDR      r0,[r0,#0]            ;491  ; j
0006b8  1c40              ADDS     r0,r0,#1              ;491
0006ba  493e              LDR      r1,|L1.1972|
0006bc  6008              STR      r0,[r1,#0]            ;491  ; j
                  |L1.1726|
0006be  483d              LDR      r0,|L1.1972|
0006c0  6800              LDR      r0,[r0,#0]            ;491  ; j
0006c2  f24031ff          MOV      r1,#0x3ff             ;491
0006c6  4288              CMP      r0,r1                 ;491
0006c8  f4ffaf08          BCC      |L1.1244|
;;;533    			}
;;;534    		}
;;;535    	i=i; 
0006cc  483a              LDR      r0,|L1.1976|
0006ce  6800              LDR      r0,[r0,#0]  ; i
0006d0  4939              LDR      r1,|L1.1976|
0006d2  6008              STR      r0,[r1,#0]  ; i
;;;536    	OSTimeDly(1000); 
0006d4  f44f707a          MOV      r0,#0x3e8
0006d8  f7fffffe          BL       OSTimeDly
                  |L1.1756|
0006dc  e6fa              B        |L1.1236|
;;;537    	}
;;;538    
;;;539    }
;;;540    
                          ENDP

                  sst26vf032b_init PROC
;;;544    */
;;;545    static void sst26vf032b_init()  //SPI1 configuration
0006de  b510              PUSH     {r4,lr}
;;;546    {
;;;547    
;;;548    	
;;;549    	
;;;550    	//复位flash
;;;551    	//复位使能
;;;552    //	__F032B_CE_Low();     
;;;553    //	__f032bSendByte(0x66);
;;;554    //	__F032B_CE_High();
;;;555    //	__F032B_CE_Low();     
;;;556    //	__f032bSendByte(0x99);
;;;557    //	__F032B_CE_High();
;;;558    	
;;;559    	//写状态寄存器
;;;560    //	__F032B_CE_Low();     
;;;561    //	__f032bSendByte(0X01);
;;;562    //	__f032bSendByte(0X08);//第1 字节是没有作用的
;;;563    //	__f032bSendByte(0X08);//第2 字节写状态寄存器
;;;564    //	__F032B_CE_High();
;;;565    	
;;;566    	//解除falsh块保护
;;;567    	__WaitWrEnd();
0006e0  f7fffffe          BL       __WaitWrEnd
;;;568    	
;;;569    	__F032B_CE_Low();     
0006e4  2010              MOVS     r0,#0x10
0006e6  4935              LDR      r1,|L1.1980|
0006e8  6008              STR      r0,[r1,#0]
;;;570    	__f032bSendByte(__WREN);        //写使能
0006ea  2006              MOVS     r0,#6
0006ec  f7fffffe          BL       __f032bSendByte
;;;571    	__F032B_CE_High();
0006f0  2010              MOVS     r0,#0x10
0006f2  4932              LDR      r1,|L1.1980|
0006f4  1f09              SUBS     r1,r1,#4
0006f6  6008              STR      r0,[r1,#0]
;;;572    	
;;;573    //	__WaitWrOk();
;;;574    	
;;;575    	__F032B_CE_Low();     
0006f8  1d09              ADDS     r1,r1,#4
0006fa  6008              STR      r0,[r1,#0]
;;;576    	__f032bSendByte(__ULBPR);//全局块保护解锁
0006fc  2098              MOVS     r0,#0x98
0006fe  f7fffffe          BL       __f032bSendByte
;;;577    	__F032B_CE_High();
000702  2010              MOVS     r0,#0x10
000704  492d              LDR      r1,|L1.1980|
000706  1f09              SUBS     r1,r1,#4
000708  6008              STR      r0,[r1,#0]
;;;578    	__WaitWrEnd();
00070a  f7fffffe          BL       __WaitWrEnd
;;;579    }
00070e  bd10              POP      {r4,pc}
;;;580    
                          ENDP

                  Spi_Flash_Configuration PROC
;;;584    */
;;;585    void  Spi_Flash_Configuration (void)
000710  b500              PUSH     {lr}
;;;586    {  
000712  b087              SUB      sp,sp,#0x1c
;;;587    	GPIO_InitTypeDef GPIO_InitStructure;
;;;588    	SPI_InitTypeDef  SPI_InitStructure;
;;;589    	
;;;590    	RCC_APB2PeriphClockCmd(RCC_APB2Periph_SPI1 | RCC_APB2Periph_GPIOB, ENABLE);//打开GPIO时钟与SPI1时钟
000714  2101              MOVS     r1,#1
000716  f2410008          MOV      r0,#0x1008
00071a  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;591    	
;;;592    	/*
;;;593    	引脚初始化
;;;594    	*/
;;;595    	//PA5--SPI1_SCK    PA6--SPI1--MISO    PA7--SPI1--MOSI
;;;596    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_5 | GPIO_Pin_6 | GPIO_Pin_7;
00071e  20e0              MOVS     r0,#0xe0
000720  f8ad0018          STRH     r0,[sp,#0x18]
;;;597    	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
000724  2003              MOVS     r0,#3
000726  f88d001a          STRB     r0,[sp,#0x1a]
;;;598    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
00072a  2018              MOVS     r0,#0x18
00072c  f88d001b          STRB     r0,[sp,#0x1b]
;;;599    	GPIO_Init(GPIOA, &GPIO_InitStructure);
000730  a906              ADD      r1,sp,#0x18
000732  4822              LDR      r0,|L1.1980|
000734  3814              SUBS     r0,r0,#0x14
000736  f7fffffe          BL       GPIO_Init
;;;600    
;;;601    	//PA4--SPI1_NSS
;;;602    	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
00073a  2003              MOVS     r0,#3
00073c  f88d001a          STRB     r0,[sp,#0x1a]
;;;603    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
000740  2010              MOVS     r0,#0x10
000742  f88d001b          STRB     r0,[sp,#0x1b]
;;;604    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_4;  						//#CE 引脚
000746  f8ad0018          STRH     r0,[sp,#0x18]
;;;605    	GPIO_Init(GPIOA, &GPIO_InitStructure);                          
00074a  a906              ADD      r1,sp,#0x18
00074c  481b              LDR      r0,|L1.1980|
00074e  3814              SUBS     r0,r0,#0x14
000750  f7fffffe          BL       GPIO_Init
;;;606    	
;;;607    	/*
;;;608    	SPI寄存器初始化
;;;609    	*/
;;;610    	SPI_I2S_DeInit(SPI1); //SPI1寄存器复位
000754  481a              LDR      r0,|L1.1984|
000756  f7fffffe          BL       SPI_I2S_DeInit
;;;611    	SPI_InitStructure.SPI_Direction = SPI_Direction_2Lines_FullDuplex;   //SPI双线双向双全工
00075a  2000              MOVS     r0,#0
00075c  f8ad0004          STRH     r0,[sp,#4]
;;;612    	SPI_InitStructure.SPI_Mode = SPI_Mode_Master;                        //主模式
000760  f44f7082          MOV      r0,#0x104
000764  f8ad0006          STRH     r0,[sp,#6]
;;;613    	SPI_InitStructure.SPI_DataSize = SPI_DataSize_8b;                    //SPI 8bit 位宽
000768  2000              MOVS     r0,#0
00076a  f8ad0008          STRH     r0,[sp,#8]
;;;614    	SPI_InitStructure.SPI_CPOL = SPI_CPOL_High;                          //时钟悬空高	(模式3)
00076e  2002              MOVS     r0,#2
000770  f8ad000a          STRH     r0,[sp,#0xa]
;;;615    	SPI_InitStructure.SPI_CPHA = SPI_CPHA_2Edge;                         //第 2 个时钟沿捕获数据
000774  2001              MOVS     r0,#1
000776  f8ad000c          STRH     r0,[sp,#0xc]
;;;616    //	SPI_InitStructure.SPI_CPHA = SPI_CPHA_1Edge;                         //第 1 个时钟沿捕获数据
;;;617    	SPI_InitStructure.SPI_NSS = SPI_NSS_Soft;                            //软控制
00077a  0240              LSLS     r0,r0,#9
00077c  f8ad000e          STRH     r0,[sp,#0xe]
;;;618    	SPI_InitStructure.SPI_BaudRatePrescaler = SPI_BaudRatePrescaler_4;   //4分频时钟(最高 18M，可提高到36M，但是不一定稳定)
000780  2008              MOVS     r0,#8
000782  f8ad0010          STRH     r0,[sp,#0x10]
;;;619    	SPI_InitStructure.SPI_FirstBit = SPI_FirstBit_MSB;                   //先传送高位
000786  2000              MOVS     r0,#0
000788  f8ad0012          STRH     r0,[sp,#0x12]
;;;620    	SPI_InitStructure.SPI_CRCPolynomial = 2;                             //CRC校验多项式7.
00078c  2002              MOVS     r0,#2
00078e  f8ad0014          STRH     r0,[sp,#0x14]
;;;621    	SPI_Init(SPI1, &SPI_InitStructure);
000792  a901              ADD      r1,sp,#4
000794  480a              LDR      r0,|L1.1984|
000796  f7fffffe          BL       SPI_Init
;;;622    	SPI_Cmd(SPI1, ENABLE);                                               //使能 SPI1
00079a  2101              MOVS     r1,#1
00079c  4808              LDR      r0,|L1.1984|
00079e  f7fffffe          BL       SPI_Cmd
;;;623    	
;;;624        SSP_SEM = OSSemCreate(1);//创建互斥型信号量
0007a2  2001              MOVS     r0,#1
0007a4  f7fffffe          BL       OSSemCreate
0007a8  4906              LDR      r1,|L1.1988|
0007aa  6008              STR      r0,[r1,#0]  ; SSP_SEM
;;;625    	sst26vf032b_init();
0007ac  f7fffffe          BL       sst26vf032b_init
;;;626    }
0007b0  b007              ADD      sp,sp,#0x1c
0007b2  bd00              POP      {pc}
;;;627    
                          ENDP

                  |L1.1972|
                          DCD      j
                  |L1.1976|
                          DCD      i
                  |L1.1980|
                          DCD      0x40010814
                  |L1.1984|
                          DCD      0x40013000
                  |L1.1988|
                          DCD      SSP_SEM

                          AREA ||.data||, DATA, ALIGN=2

                  SSP_SEM
                          DCD      0x00000000
                  i
                          DCD      0x00000000
                  j
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "..\\bsp_lib\\SST25VF016BDrv.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___16_SST25VF016BDrv_c_f44baf35____REV16|
#line 129 "C:\\Keil_v5\\ARM\\CMSIS\\Include\\core_cmInstr.h"
|__asm___16_SST25VF016BDrv_c_f44baf35____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___16_SST25VF016BDrv_c_f44baf35____REVSH|
#line 144
|__asm___16_SST25VF016BDrv_c_f44baf35____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
