; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\output\sys_config.o --asm_dir=.\Listing\ --list_dir=.\Listing\ --depend=.\output\sys_config.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x -I..\bsp_lib -I..\UCOSII\port -I..\UCOSII\src -I..\UCOSII\uC-CPU -I..\Libraries\CMSIS -I..\User\INCLUDES -I..\LCD -I..\USR\Global -I..\USR -I..\USR\FSM -I..\USR\Commucation -I..\USR\Mdb -I..\USR\Drop -I..\USR\DriverBoard -I..\USR\Flash -I..\USR\Card -I..\USR\MSG -I..\USR\Bsp -I..\USR\SetPar -I..\User\QRCode -I..\USR\MEM -I..\USR\QRCode -I..\USR\SETUP -I..\USR\stm32 -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -IC:\Keil_v5\ARM\INC\ST\STM32F10x -D__MICROLIB -D__UVISION_VERSION=525 -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER --omf_browse=.\output\sys_config.crf ..\bsp_lib\sys_config.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  RCC_Configuration PROC
;;;15     *******************************************************************************************/
;;;16     void RCC_Configuration(void) 
000000  b510              PUSH     {r4,lr}
;;;17     {
;;;18     	/* RCC system reset(for debug purpose) */
;;;19       	RCC_DeInit();
000002  f7fffffe          BL       RCC_DeInit
;;;20     
;;;21       	/* Enable HSE */
;;;22       	RCC_HSEConfig(RCC_HSE_ON);	//设置外部告诉晶振
000006  f44f3080          MOV      r0,#0x10000
00000a  f7fffffe          BL       RCC_HSEConfig
;;;23     
;;;24       	/* Wait till HSE is ready */
;;;25       	while (RCC_GetFlagStatus(RCC_FLAG_HSERDY) == RESET);
00000e  bf00              NOP      
                  |L1.16|
000010  2031              MOVS     r0,#0x31
000012  f7fffffe          BL       RCC_GetFlagStatus
000016  2800              CMP      r0,#0
000018  d0fa              BEQ      |L1.16|
;;;26     
;;;27         /* Enable Prefetch Buffer */
;;;28         FLASH_PrefetchBufferCmd(FLASH_PrefetchBuffer_Enable);	//使能预取指缓存
00001a  2010              MOVS     r0,#0x10
00001c  f7fffffe          BL       FLASH_PrefetchBufferCmd
;;;29     
;;;30         /* Flash 2 wait state */
;;;31         FLASH_SetLatency(FLASH_Latency_2);	//设置flash 延时时钟
000020  2002              MOVS     r0,#2
000022  f7fffffe          BL       FLASH_SetLatency
;;;32      
;;;33         /* HCLK = SYSCLK */
;;;34         RCC_HCLKConfig(RCC_SYSCLK_Div1);	//设置AHB 时钟 = 系统时钟
000026  2000              MOVS     r0,#0
000028  f7fffffe          BL       RCC_HCLKConfig
;;;35       
;;;36         /* PCLK2 = HCLK */
;;;37         RCC_PCLK2Config(RCC_HCLK_Div1);		//APB2 时钟= HCLK
00002c  2000              MOVS     r0,#0
00002e  f7fffffe          BL       RCC_PCLK2Config
;;;38     
;;;39         /* PCLK1 = HCLK/2 */
;;;40         RCC_PCLK1Config(RCC_HCLK_Div2);		//APB1 时钟= HCLK/2
000032  f44f6080          MOV      r0,#0x400
000036  f7fffffe          BL       RCC_PCLK1Config
;;;41     
;;;42         /* PLLCLK = 8MHz * 9 = 72 MHz */
;;;43         RCC_PLLConfig(RCC_PLLSource_HSE_Div1, RCC_PLLMul_9);	//选择外部晶振，9倍频
00003a  f44f11e0          MOV      r1,#0x1c0000
00003e  f44f3080          MOV      r0,#0x10000
000042  f7fffffe          BL       RCC_PLLConfig
;;;44     
;;;45         /* Enable PLL */ 
;;;46         RCC_PLLCmd(ENABLE);		//使能 PLL
000046  2001              MOVS     r0,#1
000048  f7fffffe          BL       RCC_PLLCmd
;;;47     
;;;48         /* Wait till PLL is ready */
;;;49         while(RCC_GetFlagStatus(RCC_FLAG_PLLRDY) == RESET);	//检查RCC标志
00004c  bf00              NOP      
                  |L1.78|
00004e  2039              MOVS     r0,#0x39
000050  f7fffffe          BL       RCC_GetFlagStatus
000054  2800              CMP      r0,#0
000056  d0fa              BEQ      |L1.78|
;;;50     
;;;51         /* Select PLL as system clock source */
;;;52         RCC_SYSCLKConfig(RCC_SYSCLKSource_PLLCLK);			//选择RCC为PLL时钟
000058  2002              MOVS     r0,#2
00005a  f7fffffe          BL       RCC_SYSCLKConfig
;;;53     
;;;54         /* Wait till PLL is used as system clock source */
;;;55     		while(RCC_GetSYSCLKSource() != 0x08);	//等待 PLL时钟 稳定
00005e  bf00              NOP      
                  |L1.96|
000060  f7fffffe          BL       RCC_GetSYSCLKSource
000064  2808              CMP      r0,#8
000066  d1fb              BNE      |L1.96|
;;;56     	
;;;57     	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA | RCC_APB2Periph_GPIOB |RCC_APB2Periph_GPIOC 
000068  2101              MOVS     r1,#1
00006a  f24410fd          MOV      r0,#0x41fd
00006e  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;58     						| RCC_APB2Periph_GPIOD | RCC_APB2Periph_GPIOE | RCC_APB2Periph_GPIOF 
;;;59     						| RCC_APB2Periph_GPIOG | RCC_APB2Periph_AFIO | RCC_APB2Periph_USART1, 
;;;60     						ENABLE);
;;;61     	
;;;62     }
000072  bd10              POP      {r4,pc}
;;;63     
                          ENDP

                  NVIC_Configuration PROC
;;;65     
;;;66     void NVIC_Configuration(void)
000074  b510              PUSH     {r4,lr}
;;;67     {
;;;68     	#ifdef  VECT_TAB_RAM  
;;;69     	  /* Set the Vector Table base location at 0x20000000 */ 
;;;70     	  NVIC_SetVectorTable(NVIC_VectTab_RAM, 0x0); 
;;;71     	#else  /* VECT_TAB_FLASH  */
;;;72     	  /* Set the Vector Table base location at 0x08000000 */ 
;;;73     	  NVIC_SetVectorTable(NVIC_VectTab_FLASH, 0x0);   
000076  2100              MOVS     r1,#0
000078  f04f6000          MOV      r0,#0x8000000
00007c  f7fffffe          BL       NVIC_SetVectorTable
;;;74     	#endif	
;;;75     }
000080  bd10              POP      {r4,pc}
;;;76     //系统时钟定时器初始化
                          ENDP

                  SysTick_Configuration PROC
;;;77     void  SysTick_Configuration(void)
000082  b570              PUSH     {r4-r6,lr}
;;;78     {
000084  b086              SUB      sp,sp,#0x18
;;;79         RCC_ClocksTypeDef  rcc_clocks;
;;;80         uint32_t	       cnts;
;;;81     
;;;82         RCC_GetClocksFreq(&rcc_clocks);	//读取时钟频率
000086  a801              ADD      r0,sp,#4
000088  f7fffffe          BL       RCC_GetClocksFreq
;;;83         cnts = (INT32U)rcc_clocks.HCLK_Frequency/OS_TICKS_PER_SEC;
00008c  f44f717a          MOV      r1,#0x3e8
000090  9802              LDR      r0,[sp,#8]
000092  fbb0f4f1          UDIV     r4,r0,r1
;;;84         SysTick_CLKSourceConfig(SysTick_CLKSource_HCLK);
000096  2004              MOVS     r0,#4
000098  f7fffffe          BL       SysTick_CLKSourceConfig
;;;85     	SysTick_Config(cnts);
00009c  4621              MOV      r1,r4
00009e  1e48              SUBS     r0,r1,#1
0000a0  f1b07f80          CMP      r0,#0x1000000
0000a4  d300              BCC      |L1.168|
0000a6  e01b              B        |L1.224|
                  |L1.168|
0000a8  1e48              SUBS     r0,r1,#1
0000aa  f04f22e0          MOV      r2,#0xe000e000
0000ae  6150              STR      r0,[r2,#0x14]
0000b0  1750              ASRS     r0,r2,#29
0000b2  220f              MOVS     r2,#0xf
0000b4  2800              CMP      r0,#0
0000b6  da07              BGE      |L1.200|
0000b8  0713              LSLS     r3,r2,#28
0000ba  0e1e              LSRS     r6,r3,#24
0000bc  4b43              LDR      r3,|L1.460|
0000be  f000050f          AND      r5,r0,#0xf
0000c2  1f2d              SUBS     r5,r5,#4
0000c4  555e              STRB     r6,[r3,r5]
0000c6  e003              B        |L1.208|
                  |L1.200|
0000c8  0713              LSLS     r3,r2,#28
0000ca  0e1d              LSRS     r5,r3,#24
0000cc  4b40              LDR      r3,|L1.464|
0000ce  541d              STRB     r5,[r3,r0]
                  |L1.208|
0000d0  bf00              NOP      
0000d2  2000              MOVS     r0,#0
0000d4  f04f22e0          MOV      r2,#0xe000e000
0000d8  6190              STR      r0,[r2,#0x18]
0000da  2007              MOVS     r0,#7
0000dc  6110              STR      r0,[r2,#0x10]
0000de  bf00              NOP      
                  |L1.224|
;;;86     }
0000e0  b006              ADD      sp,sp,#0x18
0000e2  bd70              POP      {r4-r6,pc}
;;;87     
                          ENDP

                  BUZZER_Configuration PROC
;;;88     void BUZZER_Configuration(void)
0000e4  b508              PUSH     {r3,lr}
;;;89     {
;;;90     	GPIO_InitTypeDef GPIO_InitStructure;
;;;91     	//蜂鸣器PA8
;;;92     	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_8;
0000e6  f44f7080          MOV      r0,#0x100
0000ea  f8ad0000          STRH     r0,[sp,#0]
;;;93     	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
0000ee  2010              MOVS     r0,#0x10
0000f0  f88d0003          STRB     r0,[sp,#3]
;;;94     	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
0000f4  2003              MOVS     r0,#3
0000f6  f88d0002          STRB     r0,[sp,#2]
;;;95     	GPIO_Init(GPIOA,&GPIO_InitStructure);
0000fa  4669              MOV      r1,sp
0000fc  4835              LDR      r0,|L1.468|
0000fe  f7fffffe          BL       GPIO_Init
;;;96     	GPIO_ResetBits(GPIOA,GPIO_Pin_8);
000102  f44f7180          MOV      r1,#0x100
000106  4833              LDR      r0,|L1.468|
000108  f7fffffe          BL       GPIO_ResetBits
;;;97     }
00010c  bd08              POP      {r3,pc}
;;;98     
                          ENDP

                  LED_Configuration PROC
;;;99     void LED_Configuration(void)
00010e  b508              PUSH     {r3,lr}
;;;100    {
;;;101    	GPIO_InitTypeDef GPIO_InitStructure;
;;;102    	//LED 呼吸灯 PC4 下载灯。PC5
;;;103    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_4 | GPIO_Pin_5;
000110  2030              MOVS     r0,#0x30
000112  f8ad0000          STRH     r0,[sp,#0]
;;;104    	GPIO_InitStructure.GPIO_Mode=GPIO_Mode_Out_PP;
000116  2010              MOVS     r0,#0x10
000118  f88d0003          STRB     r0,[sp,#3]
;;;105    	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
00011c  2003              MOVS     r0,#3
00011e  f88d0002          STRB     r0,[sp,#2]
;;;106    	GPIO_Init(GPIOC,&GPIO_InitStructure);
000122  4669              MOV      r1,sp
000124  482c              LDR      r0,|L1.472|
000126  f7fffffe          BL       GPIO_Init
;;;107    	GPIO_SetBits(GPIOC,GPIO_InitStructure.GPIO_Pin);
00012a  f8bd1000          LDRH     r1,[sp,#0]
00012e  482a              LDR      r0,|L1.472|
000130  f7fffffe          BL       GPIO_SetBits
;;;108    	
;;;109    	//LED USB指示灯  PA11
;;;110    	GPIO_InitStructure.GPIO_Pin=GPIO_Pin_11;
000134  f44f6000          MOV      r0,#0x800
000138  f8ad0000          STRH     r0,[sp,#0]
;;;111    	GPIO_InitStructure.GPIO_Mode=GPIO_Mode_Out_PP;
00013c  2010              MOVS     r0,#0x10
00013e  f88d0003          STRB     r0,[sp,#3]
;;;112    	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
000142  2003              MOVS     r0,#3
000144  f88d0002          STRB     r0,[sp,#2]
;;;113    	GPIO_Init(GPIOA,&GPIO_InitStructure);
000148  4669              MOV      r1,sp
00014a  4822              LDR      r0,|L1.468|
00014c  f7fffffe          BL       GPIO_Init
;;;114    	GPIO_SetBits(GPIOA,GPIO_InitStructure.GPIO_Pin);
000150  f8bd1000          LDRH     r1,[sp,#0]
000154  481f              LDR      r0,|L1.468|
000156  f7fffffe          BL       GPIO_SetBits
;;;115    }
00015a  bd08              POP      {r3,pc}
;;;116    
                          ENDP

                  Gpio_Configuration PROC
;;;118    
;;;119    void Gpio_Configuration(void)
00015c  b510              PUSH     {r4,lr}
;;;120    {
;;;121    	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA 
00015e  2100              MOVS     r1,#0
000160  f24010fd          MOV      r0,#0x1fd
000164  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;122    						 | RCC_APB2Periph_GPIOB 
;;;123    						 | RCC_APB2Periph_GPIOC 
;;;124    						 | RCC_APB2Periph_GPIOD 
;;;125    						 | RCC_APB2Periph_GPIOE 
;;;126    						 | RCC_APB2Periph_GPIOF 
;;;127    						 | RCC_APB2Periph_GPIOG 
;;;128    						 | RCC_APB2Periph_AFIO , DISABLE);//注意这个复用时钟其实只在 I2C1 用了下
;;;129    	GPIO_DeInit(GPIOA);
000168  481a              LDR      r0,|L1.468|
00016a  f7fffffe          BL       GPIO_DeInit
;;;130    	GPIO_DeInit(GPIOB);
00016e  481b              LDR      r0,|L1.476|
000170  f7fffffe          BL       GPIO_DeInit
;;;131    	GPIO_DeInit(GPIOC);
000174  4818              LDR      r0,|L1.472|
000176  f7fffffe          BL       GPIO_DeInit
;;;132    	GPIO_DeInit(GPIOD);
00017a  4819              LDR      r0,|L1.480|
00017c  f7fffffe          BL       GPIO_DeInit
;;;133    	GPIO_DeInit(GPIOE);
000180  4818              LDR      r0,|L1.484|
000182  f7fffffe          BL       GPIO_DeInit
;;;134    	GPIO_DeInit(GPIOF);
000186  4818              LDR      r0,|L1.488|
000188  f7fffffe          BL       GPIO_DeInit
;;;135    	GPIO_DeInit(GPIOG);
00018c  4817              LDR      r0,|L1.492|
00018e  f7fffffe          BL       GPIO_DeInit
;;;136    	GPIO_AFIODeInit();
000192  f7fffffe          BL       GPIO_AFIODeInit
;;;137    	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA 
000196  2101              MOVS     r1,#1
000198  f24010fd          MOV      r0,#0x1fd
00019c  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;138    					 | RCC_APB2Periph_GPIOB 
;;;139    					 | RCC_APB2Periph_GPIOC 
;;;140    					 | RCC_APB2Periph_GPIOD 
;;;141    					 | RCC_APB2Periph_GPIOE 
;;;142    					 | RCC_APB2Periph_GPIOF 
;;;143    					 | RCC_APB2Periph_GPIOG 
;;;144    					 | RCC_APB2Periph_AFIO , ENABLE);//注意这个复用时钟其实只在 I2C1 用了下
;;;145    	BUZZER_Configuration();
0001a0  f7fffffe          BL       BUZZER_Configuration
;;;146    	LED_Configuration();
0001a4  f7fffffe          BL       LED_Configuration
;;;147    }
0001a8  bd10              POP      {r4,pc}
;;;148    
                          ENDP

                  fputc PROC
;;;152    
;;;153    int fputc(int ch, FILE *f)
0001aa  b570              PUSH     {r4-r6,lr}
;;;154    {
0001ac  4604              MOV      r4,r0
0001ae  460d              MOV      r5,r1
;;;155    	USART_SendData(USART1, (uint8_t) ch);
0001b0  b2e1              UXTB     r1,r4
0001b2  480f              LDR      r0,|L1.496|
0001b4  f7fffffe          BL       USART_SendData
;;;156    
;;;157    	while(USART_GetFlagStatus(USART1, USART_FLAG_TC) == RESET)
0001b8  bf00              NOP      
                  |L1.442|
0001ba  2140              MOVS     r1,#0x40
0001bc  480c              LDR      r0,|L1.496|
0001be  f7fffffe          BL       USART_GetFlagStatus
0001c2  2800              CMP      r0,#0
0001c4  d0f9              BEQ      |L1.442|
;;;158    	{
;;;159    	}
;;;160    	return ch;
0001c6  4620              MOV      r0,r4
;;;161    }
0001c8  bd70              POP      {r4-r6,pc}
;;;162    
                          ENDP

0001ca  0000              DCW      0x0000
                  |L1.460|
                          DCD      0xe000ed18
                  |L1.464|
                          DCD      0xe000e400
                  |L1.468|
                          DCD      0x40010800
                  |L1.472|
                          DCD      0x40011000
                  |L1.476|
                          DCD      0x40010c00
                  |L1.480|
                          DCD      0x40011400
                  |L1.484|
                          DCD      0x40011800
                  |L1.488|
                          DCD      0x40011c00
                  |L1.492|
                          DCD      0x40012000
                  |L1.496|
                          DCD      0x40013800

;*** Start embedded assembler ***

#line 1 "..\\bsp_lib\\sys_config.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___12_sys_config_c_e3831934____REV16|
#line 129 "C:\\Keil_v5\\ARM\\CMSIS\\Include\\core_cmInstr.h"
|__asm___12_sys_config_c_e3831934____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___12_sys_config_c_e3831934____REVSH|
#line 144
|__asm___12_sys_config_c_e3831934____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
