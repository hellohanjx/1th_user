; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\output\setup.o --asm_dir=.\Listing\ --list_dir=.\Listing\ --depend=.\output\setup.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x -I..\bsp_lib -I..\UCOSII\port -I..\UCOSII\src -I..\UCOSII\uC-CPU -I..\Libraries\CMSIS -I..\User\INCLUDES -I..\LCD -I..\USR\Global -I..\USR -I..\USR\FSM -I..\USR\Commucation -I..\USR\Mdb -I..\USR\Drop -I..\USR\DriverBoard -I..\USR\Flash -I..\USR\Card -I..\USR\MSG -I..\USR\Bsp -I..\USR\SetPar -I..\User\QRCode -I..\USR\MEM -I..\USR\QRCode -I..\USR\SETUP -I..\USR\stm32 -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -IC:\Keil_v5\ARM\INC\ST\STM32F10x -D__MICROLIB -D__UVISION_VERSION=525 -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER --omf_browse=.\output\setup.crf ..\USR\SETUP\setup.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  e2p_get_vminfo PROC
;;;15     */
;;;16     void e2p_get_vminfo(SETUP_DEVICE *pt)
000000  b510              PUSH     {r4,lr}
;;;17     {
000002  4604              MOV      r4,r0
;;;18     	if(pt != 0)
000004  b124              CBZ      r4,|L1.16|
;;;19     	{
;;;20     		I2C_EE_ReadBuffer((uint8_t*)pt,SETUP_DEVICE_ADDR,sizeof(SETUP_DEVICE));
000006  220c              MOVS     r2,#0xc
000008  2110              MOVS     r1,#0x10
00000a  4620              MOV      r0,r4
00000c  f7fffffe          BL       I2C_EE_ReadBuffer
                  |L1.16|
;;;21     	}
;;;22     }
000010  bd10              POP      {r4,pc}
;;;23     
                          ENDP

                  e2p_get_common PROC
;;;26     */
;;;27     void e2p_get_common(SETUP_COMMON* pt)
000012  b510              PUSH     {r4,lr}
;;;28     {
000014  4604              MOV      r4,r0
;;;29     	if(pt != 0)
000016  b124              CBZ      r4,|L1.34|
;;;30     	{
;;;31     		I2C_EE_ReadBuffer((uint8_t*)pt,SETUP_COMMON_ADDR,sizeof(SETUP_COMMON));
000018  2210              MOVS     r2,#0x10
00001a  2120              MOVS     r1,#0x20
00001c  4620              MOV      r0,r4
00001e  f7fffffe          BL       I2C_EE_ReadBuffer
                  |L1.34|
;;;32     	}
;;;33     	
;;;34     }
000022  bd10              POP      {r4,pc}
;;;35     /*
                          ENDP

                  e2p_get_cashless PROC
;;;37     */
;;;38     void e2p_get_cashless(SETUP_CASHLESS* pt)
000024  b510              PUSH     {r4,lr}
;;;39     {
000026  4604              MOV      r4,r0
;;;40     	if(pt != 0)
000028  b124              CBZ      r4,|L1.52|
;;;41     	{
;;;42     		I2C_EE_ReadBuffer((uint8_t*)pt,SETUP_CASHLESS_ADDR,sizeof(SETUP_CASHLESS));
00002a  2208              MOVS     r2,#8
00002c  2130              MOVS     r1,#0x30
00002e  4620              MOV      r0,r4
000030  f7fffffe          BL       I2C_EE_ReadBuffer
                  |L1.52|
;;;43     	}
;;;44     }
000034  bd10              POP      {r4,pc}
;;;45     
                          ENDP

                  e2p_get_cash PROC
;;;49     */
;;;50     void e2p_get_cash(SETUP_CASH* pt)
000036  b510              PUSH     {r4,lr}
;;;51     {
000038  4604              MOV      r4,r0
;;;52     	if(pt != 0)
00003a  b124              CBZ      r4,|L1.70|
;;;53     	{
;;;54     		I2C_EE_ReadBuffer((uint8_t*)pt,SETUP_CASH_ADDR,sizeof(SETUP_CASH));
00003c  2201              MOVS     r2,#1
00003e  2140              MOVS     r1,#0x40
000040  4620              MOV      r0,r4
000042  f7fffffe          BL       I2C_EE_ReadBuffer
                  |L1.70|
;;;55     	}
;;;56     }
000046  bd10              POP      {r4,pc}
;;;57     
                          ENDP

                  e2p_get_ex1 PROC
;;;61     */
;;;62     void e2p_get_ex1(SETUP_EX1* pt)
000048  b510              PUSH     {r4,lr}
;;;63     {
00004a  4604              MOV      r4,r0
;;;64     	if(pt != 0)
00004c  b124              CBZ      r4,|L1.88|
;;;65     	{
;;;66     		I2C_EE_ReadBuffer((uint8_t*)pt,SETUP_EX1_ADDR,sizeof(SETUP_EX1));
00004e  220e              MOVS     r2,#0xe
000050  2150              MOVS     r1,#0x50
000052  4620              MOV      r0,r4
000054  f7fffffe          BL       I2C_EE_ReadBuffer
                  |L1.88|
;;;67     	}
;;;68     }
000058  bd10              POP      {r4,pc}
;;;69     
                          ENDP

                  e2p_get_ex2 PROC
;;;73     */
;;;74     void e2p_get_ex2(SETUP_EX2* pt)
00005a  b510              PUSH     {r4,lr}
;;;75     {
00005c  4604              MOV      r4,r0
;;;76     	if(pt != 0)
00005e  b124              CBZ      r4,|L1.106|
;;;77     	{
;;;78     		I2C_EE_ReadBuffer((uint8_t*)pt,SETUP_EX2_ADDR,sizeof(SETUP_EX2));
000060  220c              MOVS     r2,#0xc
000062  2160              MOVS     r1,#0x60
000064  4620              MOV      r0,r4
000066  f7fffffe          BL       I2C_EE_ReadBuffer
                  |L1.106|
;;;79     	}
;;;80     }
00006a  bd10              POP      {r4,pc}
;;;81     
                          ENDP

                  e2p_get_commucation PROC
;;;85     */
;;;86     void e2p_get_commucation(SETUP_COMMUCATION* pt)
00006c  b510              PUSH     {r4,lr}
;;;87     {
00006e  4604              MOV      r4,r0
;;;88     	if(pt != 0)
000070  b124              CBZ      r4,|L1.124|
;;;89     	{
;;;90     		I2C_EE_ReadBuffer((uint8_t*)pt, SETUP_COMMUCATION_ADDR, sizeof(SETUP_COMMUCATION));
000072  2208              MOVS     r2,#8
000074  2170              MOVS     r1,#0x70
000076  4620              MOV      r0,r4
000078  f7fffffe          BL       I2C_EE_ReadBuffer
                  |L1.124|
;;;91     	}
;;;92     }
00007c  bd10              POP      {r4,pc}
;;;93     
                          ENDP

                  e2p_get_channel PROC
;;;97     */
;;;98     void e2p_get_channel(uint16_t channel, SETUP_CHANNEL* pt)
00007e  b570              PUSH     {r4-r6,lr}
;;;99     {
000080  4604              MOV      r4,r0
000082  460d              MOV      r5,r1
;;;100    	if(pt != 0)
000084  b1a5              CBZ      r5,|L1.176|
;;;101    	{
;;;102    		//注意，每个机柜只有80个电机，所以这里要转换一下
;;;103    		I2C_EE_ReadBuffer((uint8_t*)pt, (SETUP_CHANNEL_ADDR + EEPROM_PAGE_SIZE*(channel%100) + (channel/100)*EEPROM_PAGE_SIZE*MAX_CHANNEL_SIZE ) ,sizeof(SETUP_CHANNEL));
000086  2064              MOVS     r0,#0x64
000088  fb94f1f0          SDIV     r1,r4,r0
00008c  fb004011          MLS      r0,r0,r1,r4
000090  0100              LSLS     r0,r0,#4
000092  3080              ADDS     r0,r0,#0x80
000094  2164              MOVS     r1,#0x64
000096  fb94f1f1          SDIV     r1,r4,r1
00009a  0109              LSLS     r1,r1,#4
00009c  eb010181          ADD      r1,r1,r1,LSL #2
0000a0  eb001001          ADD      r0,r0,r1,LSL #4
0000a4  b286              UXTH     r6,r0
0000a6  2210              MOVS     r2,#0x10
0000a8  4631              MOV      r1,r6
0000aa  4628              MOV      r0,r5
0000ac  f7fffffe          BL       I2C_EE_ReadBuffer
                  |L1.176|
;;;104    	}
;;;105    }
0000b0  bd70              POP      {r4-r6,pc}
;;;106    
                          ENDP

                  e2p_get_channelState PROC
;;;116    ******************/
;;;117    bool e2p_get_channelState(uint16_t channel, uint8_t *dat)
0000b2  e92d43f8          PUSH     {r3-r9,lr}
;;;118    {
0000b6  4604              MOV      r4,r0
0000b8  460d              MOV      r5,r1
;;;119    	bool rs = FALSE;
0000ba  2600              MOVS     r6,#0
;;;120    	uint8_t chk = 0xff, i = 0;
0000bc  20ff              MOVS     r0,#0xff
0000be  9000              STR      r0,[sp,#0]
0000c0  2700              MOVS     r7,#0
;;;121    	
;;;122    	if(dat != 0)
0000c2  b3ed              CBZ      r5,|L1.320|
;;;123    	{
;;;124    		//最多读取5遍确认
;;;125    		do{
0000c4  bf00              NOP      
                  |L1.198|
;;;126    			I2C_EE_ReadBuffer((uint8_t*)dat, (SETUP_COLUMN_ADDR + CHANNEL_STATE_OFFSET + EEPROM_PAGE_SIZE*(channel%100) + (channel/100)*EEPROM_PAGE_SIZE*MAX_CHANNEL_SIZE ) ,1);
0000c6  2064              MOVS     r0,#0x64
0000c8  fb94f1f0          SDIV     r1,r4,r0
0000cc  fb004011          MLS      r0,r0,r1,r4
0000d0  f6425188          MOV      r1,#0x2d88
0000d4  2210              MOVS     r2,#0x10
0000d6  fb021000          MLA      r0,r2,r0,r1
0000da  2164              MOVS     r1,#0x64
0000dc  fb94f1f1          SDIV     r1,r4,r1
0000e0  0109              LSLS     r1,r1,#4
0000e2  eb010181          ADD      r1,r1,r1,LSL #2
0000e6  eb001001          ADD      r0,r0,r1,LSL #4
0000ea  fa1ff880          UXTH     r8,r0
0000ee  2201              MOVS     r2,#1
0000f0  4641              MOV      r1,r8
0000f2  4628              MOV      r0,r5
0000f4  f7fffffe          BL       I2C_EE_ReadBuffer
;;;127    			I2C_EE_ReadBuffer((uint8_t*)&chk, (SETUP_COLUMN_ADDR + CHANNEL_STATE_OFFSET + EEPROM_PAGE_SIZE*(channel%100) + (channel/100)*EEPROM_PAGE_SIZE*MAX_CHANNEL_SIZE ) ,1);
0000f8  2064              MOVS     r0,#0x64
0000fa  fb94f1f0          SDIV     r1,r4,r0
0000fe  fb004011          MLS      r0,r0,r1,r4
000102  f6425188          MOV      r1,#0x2d88
000106  2210              MOVS     r2,#0x10
000108  fb021000          MLA      r0,r2,r0,r1
00010c  2164              MOVS     r1,#0x64
00010e  fb94f1f1          SDIV     r1,r4,r1
000112  0109              LSLS     r1,r1,#4
000114  eb010181          ADD      r1,r1,r1,LSL #2
000118  eb001001          ADD      r0,r0,r1,LSL #4
00011c  fa1ff880          UXTH     r8,r0
000120  2201              MOVS     r2,#1
000122  4641              MOV      r1,r8
000124  4668              MOV      r0,sp
000126  f7fffffe          BL       I2C_EE_ReadBuffer
;;;128    			if(chk == (*dat))
00012a  7828              LDRB     r0,[r5,#0]
00012c  f89d1000          LDRB     r1,[sp,#0]
000130  4288              CMP      r0,r1
000132  d100              BNE      |L1.310|
;;;129    				rs = TRUE;
000134  2601              MOVS     r6,#1
                  |L1.310|
;;;130    		}while(rs == FALSE && i++ < 5);
000136  b91e              CBNZ     r6,|L1.320|
000138  4638              MOV      r0,r7
00013a  1c79              ADDS     r1,r7,#1
00013c  b2cf              UXTB     r7,r1
00013e  e000              B        |L1.322|
                  |L1.320|
000140  e001              B        |L1.326|
                  |L1.322|
000142  2805              CMP      r0,#5
000144  dbbf              BLT      |L1.198|
                  |L1.326|
;;;131    	}
;;;132    	return rs;
000146  4630              MOV      r0,r6
;;;133    }
000148  e8bd83f8          POP      {r3-r9,pc}
;;;134    /******************
                          ENDP

                  e2p_set_channelState PROC
;;;138    ******************/
;;;139    bool e2p_set_channelState(uint16_t channel, uint8_t *dat)
00014c  e92d43f8          PUSH     {r3-r9,lr}
;;;140    {
000150  4604              MOV      r4,r0
000152  460d              MOV      r5,r1
;;;141    	
;;;142    	uint8_t chk = 0xff, i = 0; 
000154  20ff              MOVS     r0,#0xff
000156  9000              STR      r0,[sp,#0]
000158  2700              MOVS     r7,#0
;;;143    	bool rs = FALSE;
00015a  2600              MOVS     r6,#0
;;;144    	
;;;145    	if(dat != 0)
00015c  b3f5              CBZ      r5,|L1.476|
;;;146    	{
;;;147    		do{
00015e  bf00              NOP      
                  |L1.352|
;;;148    			I2C_EE_WriteBuffer((uint8_t*)dat, (SETUP_COLUMN_ADDR + CHANNEL_STATE_OFFSET + EEPROM_PAGE_SIZE*(channel%100) + (channel/100)*EEPROM_PAGE_SIZE*MAX_CHANNEL_SIZE ) ,1);
000160  2064              MOVS     r0,#0x64
000162  fb94f1f0          SDIV     r1,r4,r0
000166  fb004011          MLS      r0,r0,r1,r4
00016a  f6425188          MOV      r1,#0x2d88
00016e  2210              MOVS     r2,#0x10
000170  fb021000          MLA      r0,r2,r0,r1
000174  2164              MOVS     r1,#0x64
000176  fb94f1f1          SDIV     r1,r4,r1
00017a  0109              LSLS     r1,r1,#4
00017c  eb010181          ADD      r1,r1,r1,LSL #2
000180  eb001001          ADD      r0,r0,r1,LSL #4
000184  fa1ff880          UXTH     r8,r0
000188  2201              MOVS     r2,#1
00018a  4641              MOV      r1,r8
00018c  4628              MOV      r0,r5
00018e  f7fffffe          BL       I2C_EE_WriteBuffer
;;;149    			I2C_EE_ReadBuffer((uint8_t*)&chk, (SETUP_COLUMN_ADDR + CHANNEL_STATE_OFFSET + EEPROM_PAGE_SIZE*(channel%100) + (channel/100)*EEPROM_PAGE_SIZE*MAX_CHANNEL_SIZE ) ,1);
000192  2064              MOVS     r0,#0x64
000194  fb94f1f0          SDIV     r1,r4,r0
000198  fb004011          MLS      r0,r0,r1,r4
00019c  f6425188          MOV      r1,#0x2d88
0001a0  2210              MOVS     r2,#0x10
0001a2  fb021000          MLA      r0,r2,r0,r1
0001a6  2164              MOVS     r1,#0x64
0001a8  fb94f1f1          SDIV     r1,r4,r1
0001ac  0109              LSLS     r1,r1,#4
0001ae  eb010181          ADD      r1,r1,r1,LSL #2
0001b2  eb001001          ADD      r0,r0,r1,LSL #4
0001b6  fa1ff880          UXTH     r8,r0
0001ba  2201              MOVS     r2,#1
0001bc  4641              MOV      r1,r8
0001be  4668              MOV      r0,sp
0001c0  f7fffffe          BL       I2C_EE_ReadBuffer
;;;150    			if(chk == (*dat))
0001c4  7828              LDRB     r0,[r5,#0]
0001c6  f89d1000          LDRB     r1,[sp,#0]
0001ca  4288              CMP      r0,r1
0001cc  d100              BNE      |L1.464|
;;;151    				rs = TRUE;
0001ce  2601              MOVS     r6,#1
                  |L1.464|
;;;152    		}while(rs == FALSE && i++ < 5);
0001d0  b926              CBNZ     r6,|L1.476|
0001d2  4638              MOV      r0,r7
0001d4  1c79              ADDS     r1,r7,#1
0001d6  b2cf              UXTB     r7,r1
0001d8  2805              CMP      r0,#5
0001da  e000              B        |L1.478|
                  |L1.476|
0001dc  e000              B        |L1.480|
                  |L1.478|
0001de  dbbf              BLT      |L1.352|
                  |L1.480|
;;;153    	}
;;;154    	return rs;
0001e0  4630              MOV      r0,r6
;;;155    }
0001e2  e8bd83f8          POP      {r3-r9,pc}
;;;156    
                          ENDP

                  e2p_get_price PROC
;;;165    */
;;;166    bool e2p_get_price(uint16_t channel, uint32_t *dat)
0001e6  e92d43f8          PUSH     {r3-r9,lr}
;;;167    {
0001ea  4605              MOV      r5,r0
0001ec  460c              MOV      r4,r1
;;;168    	bool rs = FALSE;
0001ee  2600              MOVS     r6,#0
;;;169    	uint32_t  i = 0;
0001f0  46b0              MOV      r8,r6
;;;170    	uint8_t chk = 0xff, contrast;//注意这里为单字节和校验，不允许超过0xff
0001f2  20ff              MOVS     r0,#0xff
0001f4  9000              STR      r0,[sp,#0]
;;;171    	if(dat != 0)
0001f6  b3ec              CBZ      r4,|L1.628|
;;;172    	{
;;;173    		do{
0001f8  bf00              NOP      
                  |L1.506|
;;;174    			I2C_EE_ReadBuffer((uint8_t*)dat, (SETUP_CHANNEL_ADDR + EEPROM_PAGE_SIZE*(channel%100) + (channel/100)*EEPROM_PAGE_SIZE*MAX_CHANNEL_SIZE ) ,4);
0001fa  2064              MOVS     r0,#0x64
0001fc  fb95f1f0          SDIV     r1,r5,r0
000200  fb005011          MLS      r0,r0,r1,r5
000204  0100              LSLS     r0,r0,#4
000206  3080              ADDS     r0,r0,#0x80
000208  2164              MOVS     r1,#0x64
00020a  fb95f1f1          SDIV     r1,r5,r1
00020e  0109              LSLS     r1,r1,#4
000210  eb010181          ADD      r1,r1,r1,LSL #2
000214  eb001001          ADD      r0,r0,r1,LSL #4
000218  fa1ff980          UXTH     r9,r0
00021c  2204              MOVS     r2,#4
00021e  4649              MOV      r1,r9
000220  4620              MOV      r0,r4
000222  f7fffffe          BL       I2C_EE_ReadBuffer
;;;175    			I2C_EE_ReadBuffer((uint8_t*)&chk, (SETUP_CHANNEL_ADDR + CHANNEL_PRICEBKP_OFFSET + EEPROM_PAGE_SIZE*(channel%100) + (channel/100)*EEPROM_PAGE_SIZE*MAX_CHANNEL_SIZE ) ,1);
000226  2064              MOVS     r0,#0x64
000228  fb95f1f0          SDIV     r1,r5,r0
00022c  fb005011          MLS      r0,r0,r1,r5
000230  0100              LSLS     r0,r0,#4
000232  308e              ADDS     r0,r0,#0x8e
000234  2164              MOVS     r1,#0x64
000236  fb95f1f1          SDIV     r1,r5,r1
00023a  0109              LSLS     r1,r1,#4
00023c  eb010181          ADD      r1,r1,r1,LSL #2
000240  eb001001          ADD      r0,r0,r1,LSL #4
000244  fa1ff980          UXTH     r9,r0
000248  2201              MOVS     r2,#1
00024a  4649              MOV      r1,r9
00024c  4668              MOV      r0,sp
00024e  f7fffffe          BL       I2C_EE_ReadBuffer
;;;176    			contrast = (((*dat) >> 24)&0xff) + (((*dat) >> 16)&0xff) + (((*dat) >> 8)&0xff) + ((*dat)&0xff);
000252  6820              LDR      r0,[r4,#0]
000254  0c00              LSRS     r0,r0,#16
000256  6821              LDR      r1,[r4,#0]
000258  eb006011          ADD      r0,r0,r1,LSR #24
00025c  8821              LDRH     r1,[r4,#0]
00025e  eb002011          ADD      r0,r0,r1,LSR #8
000262  7821              LDRB     r1,[r4,#0]
000264  4408              ADD      r0,r0,r1
000266  b2c7              UXTB     r7,r0
;;;177    			if(chk == contrast)
000268  f89d0000          LDRB     r0,[sp,#0]
00026c  42b8              CMP      r0,r7
00026e  d100              BNE      |L1.626|
;;;178    				rs = TRUE;
000270  2601              MOVS     r6,#1
                  |L1.626|
;;;179    		}while(rs == FALSE && i++ < 5);
000272  e000              B        |L1.630|
                  |L1.628|
000274  e005              B        |L1.642|
                  |L1.630|
000276  b926              CBNZ     r6,|L1.642|
000278  4640              MOV      r0,r8
00027a  f1080801          ADD      r8,r8,#1
00027e  2805              CMP      r0,#5
000280  d3bb              BCC      |L1.506|
                  |L1.642|
;;;180    	}
;;;181    	return rs;
000282  4630              MOV      r0,r6
;;;182    }
000284  e8bd83f8          POP      {r3-r9,pc}
;;;183    /*
                          ENDP

                  e2p_get_channelEnable PROC
;;;185    */
;;;186    bool e2p_get_channelEnable(uint16_t channel, uint8_t *dat)
000288  e92d43f8          PUSH     {r3-r9,lr}
;;;187    {
00028c  4604              MOV      r4,r0
00028e  460d              MOV      r5,r1
;;;188    	bool rs = FALSE;
000290  2600              MOVS     r6,#0
;;;189    	uint8_t chk = 0xff, i = 0;
000292  20ff              MOVS     r0,#0xff
000294  9000              STR      r0,[sp,#0]
000296  2700              MOVS     r7,#0
;;;190    	
;;;191    	if(dat != 0)
000298  b3c5              CBZ      r5,|L1.780|
;;;192    	{
;;;193    		//最多读取5遍确认
;;;194    		do{
00029a  bf00              NOP      
                  |L1.668|
;;;195    			I2C_EE_ReadBuffer((uint8_t*)dat, (SETUP_CHANNEL_ADDR + CHANNEL_ENABLE_OFFSET + EEPROM_PAGE_SIZE*(channel%100) + (channel/100)*EEPROM_PAGE_SIZE*MAX_CHANNEL_SIZE ) ,1);
00029c  2064              MOVS     r0,#0x64
00029e  fb94f1f0          SDIV     r1,r4,r0
0002a2  fb004011          MLS      r0,r0,r1,r4
0002a6  0100              LSLS     r0,r0,#4
0002a8  308f              ADDS     r0,r0,#0x8f
0002aa  2164              MOVS     r1,#0x64
0002ac  fb94f1f1          SDIV     r1,r4,r1
0002b0  0109              LSLS     r1,r1,#4
0002b2  eb010181          ADD      r1,r1,r1,LSL #2
0002b6  eb001001          ADD      r0,r0,r1,LSL #4
0002ba  fa1ff880          UXTH     r8,r0
0002be  2201              MOVS     r2,#1
0002c0  4641              MOV      r1,r8
0002c2  4628              MOV      r0,r5
0002c4  f7fffffe          BL       I2C_EE_ReadBuffer
;;;196    			I2C_EE_ReadBuffer((uint8_t*)&chk, (SETUP_CHANNEL_ADDR + CHANNEL_ENABLE_OFFSET + EEPROM_PAGE_SIZE*(channel%100) + (channel/100)*EEPROM_PAGE_SIZE*MAX_CHANNEL_SIZE ) ,1);
0002c8  2064              MOVS     r0,#0x64
0002ca  fb94f1f0          SDIV     r1,r4,r0
0002ce  fb004011          MLS      r0,r0,r1,r4
0002d2  0100              LSLS     r0,r0,#4
0002d4  308f              ADDS     r0,r0,#0x8f
0002d6  2164              MOVS     r1,#0x64
0002d8  fb94f1f1          SDIV     r1,r4,r1
0002dc  0109              LSLS     r1,r1,#4
0002de  eb010181          ADD      r1,r1,r1,LSL #2
0002e2  eb001001          ADD      r0,r0,r1,LSL #4
0002e6  fa1ff880          UXTH     r8,r0
0002ea  2201              MOVS     r2,#1
0002ec  4641              MOV      r1,r8
0002ee  4668              MOV      r0,sp
0002f0  f7fffffe          BL       I2C_EE_ReadBuffer
;;;197    			if(chk == (*dat))
0002f4  7828              LDRB     r0,[r5,#0]
0002f6  f89d1000          LDRB     r1,[sp,#0]
0002fa  4288              CMP      r0,r1
0002fc  d100              BNE      |L1.768|
;;;198    				rs = TRUE;
0002fe  2601              MOVS     r6,#1
                  |L1.768|
;;;199    		}while(rs == FALSE && i++ < 5);
000300  b926              CBNZ     r6,|L1.780|
000302  4638              MOV      r0,r7
000304  1c79              ADDS     r1,r7,#1
000306  b2cf              UXTB     r7,r1
000308  2805              CMP      r0,#5
00030a  dbc7              BLT      |L1.668|
                  |L1.780|
;;;200    	}
;;;201    	return rs;
00030c  4630              MOV      r0,r6
;;;202    }
00030e  e8bd83f8          POP      {r3-r9,pc}
;;;203    /*
                          ENDP

                  e2p_get_store PROC
;;;205    */
;;;206    bool e2p_get_store(uint16_t channel, uint16_t* dat)
000312  e92d43f8          PUSH     {r3-r9,lr}
;;;207    {
000316  4604              MOV      r4,r0
000318  460d              MOV      r5,r1
;;;208    	bool rs = FALSE;
00031a  2600              MOVS     r6,#0
;;;209    	uint16_t chk = 0xff, i = 0;
00031c  20ff              MOVS     r0,#0xff
00031e  9000              STR      r0,[sp,#0]
000320  2700              MOVS     r7,#0
;;;210    	
;;;211    	if(dat != 0)
000322  b3c5              CBZ      r5,|L1.918|
;;;212    	{
;;;213    		//最多读取5遍确认
;;;214    		do{
000324  bf00              NOP      
                  |L1.806|
;;;215    			I2C_EE_ReadBuffer((uint8_t*)dat, (SETUP_CHANNEL_ADDR + CHANNEL_STORE_OFFSET + EEPROM_PAGE_SIZE*(channel%100) + (channel/100)*EEPROM_PAGE_SIZE*MAX_CHANNEL_SIZE ) ,2 );
000326  2064              MOVS     r0,#0x64
000328  fb94f1f0          SDIV     r1,r4,r0
00032c  fb004011          MLS      r0,r0,r1,r4
000330  0100              LSLS     r0,r0,#4
000332  3088              ADDS     r0,r0,#0x88
000334  2164              MOVS     r1,#0x64
000336  fb94f1f1          SDIV     r1,r4,r1
00033a  0109              LSLS     r1,r1,#4
00033c  eb010181          ADD      r1,r1,r1,LSL #2
000340  eb001001          ADD      r0,r0,r1,LSL #4
000344  fa1ff880          UXTH     r8,r0
000348  2202              MOVS     r2,#2
00034a  4641              MOV      r1,r8
00034c  4628              MOV      r0,r5
00034e  f7fffffe          BL       I2C_EE_ReadBuffer
;;;216    			I2C_EE_ReadBuffer((uint8_t*)&chk, (SETUP_CHANNEL_ADDR + CHANNEL_STORE_OFFSET + EEPROM_PAGE_SIZE*(channel%100) + (channel/100)*EEPROM_PAGE_SIZE*MAX_CHANNEL_SIZE ) ,2 );
000352  2064              MOVS     r0,#0x64
000354  fb94f1f0          SDIV     r1,r4,r0
000358  fb004011          MLS      r0,r0,r1,r4
00035c  0100              LSLS     r0,r0,#4
00035e  3088              ADDS     r0,r0,#0x88
000360  2164              MOVS     r1,#0x64
000362  fb94f1f1          SDIV     r1,r4,r1
000366  0109              LSLS     r1,r1,#4
000368  eb010181          ADD      r1,r1,r1,LSL #2
00036c  eb001001          ADD      r0,r0,r1,LSL #4
000370  fa1ff880          UXTH     r8,r0
000374  2202              MOVS     r2,#2
000376  4641              MOV      r1,r8
000378  4668              MOV      r0,sp
00037a  f7fffffe          BL       I2C_EE_ReadBuffer
;;;217    			if(chk == (*dat))
00037e  8828              LDRH     r0,[r5,#0]
000380  f8bd1000          LDRH     r1,[sp,#0]
000384  4288              CMP      r0,r1
000386  d100              BNE      |L1.906|
;;;218    				rs = TRUE;
000388  2601              MOVS     r6,#1
                  |L1.906|
;;;219    		}while(rs == FALSE && i++ < 5);
00038a  b926              CBNZ     r6,|L1.918|
00038c  4638              MOV      r0,r7
00038e  1c79              ADDS     r1,r7,#1
000390  b28f              UXTH     r7,r1
000392  2805              CMP      r0,#5
000394  dbc7              BLT      |L1.806|
                  |L1.918|
;;;220    	}
;;;221    	return rs;
000396  4630              MOV      r0,r6
;;;222    }
000398  e8bd83f8          POP      {r3-r9,pc}
;;;223    /*
                          ENDP

                  e2p_get_storeBkp PROC
;;;225    */
;;;226    bool e2p_get_storeBkp(uint16_t channel, uint16_t* dat)
00039c  e92d43f8          PUSH     {r3-r9,lr}
;;;227    {
0003a0  4604              MOV      r4,r0
0003a2  460d              MOV      r5,r1
;;;228    	bool rs = FALSE;
0003a4  2600              MOVS     r6,#0
;;;229    	uint16_t chk = 0xff, i = 0;
0003a6  20ff              MOVS     r0,#0xff
0003a8  9000              STR      r0,[sp,#0]
0003aa  2700              MOVS     r7,#0
;;;230    	
;;;231    	if(dat != 0)
0003ac  b3c5              CBZ      r5,|L1.1056|
;;;232    	{
;;;233    		do
0003ae  bf00              NOP      
                  |L1.944|
;;;234    		{
;;;235    			I2C_EE_ReadBuffer((uint8_t*)dat, (SETUP_CHANNEL_ADDR + CHANNEL_STOREBKP_OFFSET + EEPROM_PAGE_SIZE*(channel%100) + (channel/100)*EEPROM_PAGE_SIZE*MAX_CHANNEL_SIZE ) ,2 );
0003b0  2064              MOVS     r0,#0x64
0003b2  fb94f1f0          SDIV     r1,r4,r0
0003b6  fb004011          MLS      r0,r0,r1,r4
0003ba  0100              LSLS     r0,r0,#4
0003bc  308a              ADDS     r0,r0,#0x8a
0003be  2164              MOVS     r1,#0x64
0003c0  fb94f1f1          SDIV     r1,r4,r1
0003c4  0109              LSLS     r1,r1,#4
0003c6  eb010181          ADD      r1,r1,r1,LSL #2
0003ca  eb001001          ADD      r0,r0,r1,LSL #4
0003ce  fa1ff880          UXTH     r8,r0
0003d2  2202              MOVS     r2,#2
0003d4  4641              MOV      r1,r8
0003d6  4628              MOV      r0,r5
0003d8  f7fffffe          BL       I2C_EE_ReadBuffer
;;;236    			I2C_EE_ReadBuffer((uint8_t*)&chk, (SETUP_CHANNEL_ADDR + CHANNEL_STOREBKP_OFFSET + EEPROM_PAGE_SIZE*(channel%100) + (channel/100)*EEPROM_PAGE_SIZE*MAX_CHANNEL_SIZE ) ,2 );
0003dc  2064              MOVS     r0,#0x64
0003de  fb94f1f0          SDIV     r1,r4,r0
0003e2  fb004011          MLS      r0,r0,r1,r4
0003e6  0100              LSLS     r0,r0,#4
0003e8  308a              ADDS     r0,r0,#0x8a
0003ea  2164              MOVS     r1,#0x64
0003ec  fb94f1f1          SDIV     r1,r4,r1
0003f0  0109              LSLS     r1,r1,#4
0003f2  eb010181          ADD      r1,r1,r1,LSL #2
0003f6  eb001001          ADD      r0,r0,r1,LSL #4
0003fa  fa1ff880          UXTH     r8,r0
0003fe  2202              MOVS     r2,#2
000400  4641              MOV      r1,r8
000402  4668              MOV      r0,sp
000404  f7fffffe          BL       I2C_EE_ReadBuffer
;;;237    			if(chk == (*dat))
000408  8828              LDRH     r0,[r5,#0]
00040a  f8bd1000          LDRH     r1,[sp,#0]
00040e  4288              CMP      r0,r1
000410  d100              BNE      |L1.1044|
;;;238    				rs = TRUE;
000412  2601              MOVS     r6,#1
                  |L1.1044|
;;;239    		}while(rs == FALSE && i++ < 5);
000414  b926              CBNZ     r6,|L1.1056|
000416  4638              MOV      r0,r7
000418  1c79              ADDS     r1,r7,#1
00041a  b28f              UXTH     r7,r1
00041c  2805              CMP      r0,#5
00041e  dbc7              BLT      |L1.944|
                  |L1.1056|
;;;240    	}
;;;241    	return rs;
000420  4630              MOV      r0,r6
;;;242    }
000422  e8bd83f8          POP      {r3-r9,pc}
;;;243    /*
                          ENDP

                  e2p_get_spring PROC
;;;245    */
;;;246    bool e2p_get_spring(uint16_t channel, uint16_t* dat)
000426  e92d43f8          PUSH     {r3-r9,lr}
;;;247    {
00042a  4604              MOV      r4,r0
00042c  460d              MOV      r5,r1
;;;248    	bool rs = FALSE;
00042e  2600              MOVS     r6,#0
;;;249    	uint16_t chk, i = 0;
000430  2700              MOVS     r7,#0
;;;250    	
;;;251    	if(dat != 0)
000432  b3c5              CBZ      r5,|L1.1190|
;;;252    	{
;;;253    		do{
000434  bf00              NOP      
                  |L1.1078|
;;;254    			I2C_EE_ReadBuffer((uint8_t*)dat, (SETUP_CHANNEL_ADDR + CHANNEL_SPRING_OFFSET + EEPROM_PAGE_SIZE*(channel%100) + (channel/100)*EEPROM_PAGE_SIZE*MAX_CHANNEL_SIZE ) ,2 );
000436  2064              MOVS     r0,#0x64
000438  fb94f1f0          SDIV     r1,r4,r0
00043c  fb004011          MLS      r0,r0,r1,r4
000440  0100              LSLS     r0,r0,#4
000442  308c              ADDS     r0,r0,#0x8c
000444  2164              MOVS     r1,#0x64
000446  fb94f1f1          SDIV     r1,r4,r1
00044a  0109              LSLS     r1,r1,#4
00044c  eb010181          ADD      r1,r1,r1,LSL #2
000450  eb001001          ADD      r0,r0,r1,LSL #4
000454  fa1ff880          UXTH     r8,r0
000458  2202              MOVS     r2,#2
00045a  4641              MOV      r1,r8
00045c  4628              MOV      r0,r5
00045e  f7fffffe          BL       I2C_EE_ReadBuffer
;;;255    			I2C_EE_ReadBuffer((uint8_t*)&chk, (SETUP_CHANNEL_ADDR + CHANNEL_SPRING_OFFSET + EEPROM_PAGE_SIZE*(channel%100) + (channel/100)*EEPROM_PAGE_SIZE*MAX_CHANNEL_SIZE ) ,2 );
000462  2064              MOVS     r0,#0x64
000464  fb94f1f0          SDIV     r1,r4,r0
000468  fb004011          MLS      r0,r0,r1,r4
00046c  0100              LSLS     r0,r0,#4
00046e  308c              ADDS     r0,r0,#0x8c
000470  2164              MOVS     r1,#0x64
000472  fb94f1f1          SDIV     r1,r4,r1
000476  0109              LSLS     r1,r1,#4
000478  eb010181          ADD      r1,r1,r1,LSL #2
00047c  eb001001          ADD      r0,r0,r1,LSL #4
000480  fa1ff880          UXTH     r8,r0
000484  2202              MOVS     r2,#2
000486  4641              MOV      r1,r8
000488  4668              MOV      r0,sp
00048a  f7fffffe          BL       I2C_EE_ReadBuffer
;;;256    			if(chk == (*dat))
00048e  8828              LDRH     r0,[r5,#0]
000490  f8bd1000          LDRH     r1,[sp,#0]
000494  4288              CMP      r0,r1
000496  d100              BNE      |L1.1178|
;;;257    				rs = TRUE;
000498  2601              MOVS     r6,#1
                  |L1.1178|
;;;258    		}while(rs == FALSE && i++ < 5);
00049a  b926              CBNZ     r6,|L1.1190|
00049c  4638              MOV      r0,r7
00049e  1c79              ADDS     r1,r7,#1
0004a0  b28f              UXTH     r7,r1
0004a2  2805              CMP      r0,#5
0004a4  dbc7              BLT      |L1.1078|
                  |L1.1190|
;;;259    	}
;;;260    	return rs;
0004a6  4630              MOV      r0,r6
;;;261    }
0004a8  e8bd83f8          POP      {r3-r9,pc}
;;;262    /*
                          ENDP

                  e2p_get_channelCode PROC
;;;264    */
;;;265    bool e2p_get_channelCode(uint16_t channel, uint32_t* dat)
0004ac  e92d43f8          PUSH     {r3-r9,lr}
;;;266    {
0004b0  4604              MOV      r4,r0
0004b2  460d              MOV      r5,r1
;;;267    	bool rs = FALSE;
0004b4  2600              MOVS     r6,#0
;;;268    	uint32_t chk, i = 0;
0004b6  2700              MOVS     r7,#0
;;;269    	
;;;270    	if(dat != 0)
0004b8  b3b5              CBZ      r5,|L1.1320|
;;;271    	{
;;;272    		do{
0004ba  bf00              NOP      
                  |L1.1212|
;;;273    			I2C_EE_ReadBuffer((uint8_t*)dat, (SETUP_CHANNEL_ADDR + CHANNEL_CODE_OFFSET + EEPROM_PAGE_SIZE*(channel%100) + (channel/100)*EEPROM_PAGE_SIZE*MAX_CHANNEL_SIZE ) ,4 );
0004bc  2064              MOVS     r0,#0x64
0004be  fb94f1f0          SDIV     r1,r4,r0
0004c2  fb004011          MLS      r0,r0,r1,r4
0004c6  0100              LSLS     r0,r0,#4
0004c8  3084              ADDS     r0,r0,#0x84
0004ca  2164              MOVS     r1,#0x64
0004cc  fb94f1f1          SDIV     r1,r4,r1
0004d0  0109              LSLS     r1,r1,#4
0004d2  eb010181          ADD      r1,r1,r1,LSL #2
0004d6  eb001001          ADD      r0,r0,r1,LSL #4
0004da  fa1ff880          UXTH     r8,r0
0004de  2204              MOVS     r2,#4
0004e0  4641              MOV      r1,r8
0004e2  4628              MOV      r0,r5
0004e4  f7fffffe          BL       I2C_EE_ReadBuffer
;;;274    			I2C_EE_ReadBuffer((uint8_t*)&chk, (SETUP_CHANNEL_ADDR + CHANNEL_CODE_OFFSET + EEPROM_PAGE_SIZE*(channel%100) + (channel/100)*EEPROM_PAGE_SIZE*MAX_CHANNEL_SIZE ) ,4 );
0004e8  2064              MOVS     r0,#0x64
0004ea  fb94f1f0          SDIV     r1,r4,r0
0004ee  fb004011          MLS      r0,r0,r1,r4
0004f2  0100              LSLS     r0,r0,#4
0004f4  3084              ADDS     r0,r0,#0x84
0004f6  2164              MOVS     r1,#0x64
0004f8  fb94f1f1          SDIV     r1,r4,r1
0004fc  0109              LSLS     r1,r1,#4
0004fe  eb010181          ADD      r1,r1,r1,LSL #2
000502  eb001001          ADD      r0,r0,r1,LSL #4
000506  fa1ff880          UXTH     r8,r0
00050a  2204              MOVS     r2,#4
00050c  4641              MOV      r1,r8
00050e  4668              MOV      r0,sp
000510  f7fffffe          BL       I2C_EE_ReadBuffer
;;;275    			if(chk == (*dat))
000514  6828              LDR      r0,[r5,#0]
000516  9900              LDR      r1,[sp,#0]
000518  4288              CMP      r0,r1
00051a  d100              BNE      |L1.1310|
;;;276    				rs = TRUE;
00051c  2601              MOVS     r6,#1
                  |L1.1310|
;;;277    		}while(rs == FALSE && i++ < 5);
00051e  b91e              CBNZ     r6,|L1.1320|
000520  4638              MOV      r0,r7
000522  1c7f              ADDS     r7,r7,#1
000524  2805              CMP      r0,#5
000526  d3c9              BCC      |L1.1212|
                  |L1.1320|
;;;278    	}
;;;279    	return rs;
000528  4630              MOV      r0,r6
;;;280    }
00052a  e8bd83f8          POP      {r3-r9,pc}
;;;281    
                          ENDP

                  e2p_get_channelStatistic PROC
;;;284    */
;;;285    bool e2p_get_channelStatistic(uint16_t channel, uint32_t* num, uint32_t *val)
00052e  e92d47fc          PUSH     {r2-r10,lr}
;;;286    {
000532  4604              MOV      r4,r0
000534  460d              MOV      r5,r1
000536  4616              MOV      r6,r2
;;;287    	bool rs = FALSE;
000538  2700              MOVS     r7,#0
;;;288    	uint32_t chk1, chk2, i = 0;
00053a  46b8              MOV      r8,r7
;;;289    	
;;;290    	if(num != 0 && val != 0)
00053c  2d00              CMP      r5,#0
00053e  d071              BEQ      |L1.1572|
000540  2e00              CMP      r6,#0
000542  d06f              BEQ      |L1.1572|
;;;291    	{
;;;292    		do{
000544  bf00              NOP      
                  |L1.1350|
;;;293    			I2C_EE_ReadBuffer((uint8_t*)num,   (SETUP_COLUMN_ADDR + EEPROM_PAGE_SIZE*(channel%100) + (channel/100)*EEPROM_PAGE_SIZE*MAX_CHANNEL_SIZE ) ,4 );
000546  2064              MOVS     r0,#0x64
000548  fb94f1f0          SDIV     r1,r4,r0
00054c  fb004011          MLS      r0,r0,r1,r4
000550  0100              LSLS     r0,r0,#4
000552  f5005036          ADD      r0,r0,#0x2d80
000556  2164              MOVS     r1,#0x64
000558  fb94f1f1          SDIV     r1,r4,r1
00055c  0109              LSLS     r1,r1,#4
00055e  eb010181          ADD      r1,r1,r1,LSL #2
000562  eb001001          ADD      r0,r0,r1,LSL #4
000566  fa1ff980          UXTH     r9,r0
00056a  2204              MOVS     r2,#4
00056c  4649              MOV      r1,r9
00056e  4628              MOV      r0,r5
000570  f7fffffe          BL       I2C_EE_ReadBuffer
;;;294    			I2C_EE_ReadBuffer((uint8_t*)&chk1, (SETUP_COLUMN_ADDR + EEPROM_PAGE_SIZE*(channel%100) + (channel/100)*EEPROM_PAGE_SIZE*MAX_CHANNEL_SIZE ) ,4 );
000574  2064              MOVS     r0,#0x64
000576  fb94f1f0          SDIV     r1,r4,r0
00057a  fb004011          MLS      r0,r0,r1,r4
00057e  0100              LSLS     r0,r0,#4
000580  f5005036          ADD      r0,r0,#0x2d80
000584  2164              MOVS     r1,#0x64
000586  fb94f1f1          SDIV     r1,r4,r1
00058a  0109              LSLS     r1,r1,#4
00058c  eb010181          ADD      r1,r1,r1,LSL #2
000590  eb001001          ADD      r0,r0,r1,LSL #4
000594  fa1ff980          UXTH     r9,r0
000598  2204              MOVS     r2,#4
00059a  4649              MOV      r1,r9
00059c  a801              ADD      r0,sp,#4
00059e  f7fffffe          BL       I2C_EE_ReadBuffer
;;;295    			I2C_EE_ReadBuffer((uint8_t*)val,   (SETUP_COLUMN_ADDR + 4 + EEPROM_PAGE_SIZE*(channel%100) + (channel/100)*EEPROM_PAGE_SIZE*MAX_CHANNEL_SIZE ) ,4 );
0005a2  2064              MOVS     r0,#0x64
0005a4  fb94f1f0          SDIV     r1,r4,r0
0005a8  fb004011          MLS      r0,r0,r1,r4
0005ac  f6425184          MOV      r1,#0x2d84
0005b0  2210              MOVS     r2,#0x10
0005b2  fb021000          MLA      r0,r2,r0,r1
0005b6  2164              MOVS     r1,#0x64
0005b8  fb94f1f1          SDIV     r1,r4,r1
0005bc  0109              LSLS     r1,r1,#4
0005be  eb010181          ADD      r1,r1,r1,LSL #2
0005c2  eb001001          ADD      r0,r0,r1,LSL #4
0005c6  fa1ff980          UXTH     r9,r0
0005ca  2204              MOVS     r2,#4
0005cc  4649              MOV      r1,r9
0005ce  4630              MOV      r0,r6
0005d0  f7fffffe          BL       I2C_EE_ReadBuffer
;;;296    			I2C_EE_ReadBuffer((uint8_t*)&chk2, (SETUP_COLUMN_ADDR + 4 + EEPROM_PAGE_SIZE*(channel%100) + (channel/100)*EEPROM_PAGE_SIZE*MAX_CHANNEL_SIZE ) ,4 );
0005d4  2064              MOVS     r0,#0x64
0005d6  fb94f1f0          SDIV     r1,r4,r0
0005da  fb004011          MLS      r0,r0,r1,r4
0005de  f6425184          MOV      r1,#0x2d84
0005e2  2210              MOVS     r2,#0x10
0005e4  fb021000          MLA      r0,r2,r0,r1
0005e8  2164              MOVS     r1,#0x64
0005ea  fb94f1f1          SDIV     r1,r4,r1
0005ee  0109              LSLS     r1,r1,#4
0005f0  eb010181          ADD      r1,r1,r1,LSL #2
0005f4  eb001001          ADD      r0,r0,r1,LSL #4
0005f8  fa1ff980          UXTH     r9,r0
0005fc  2204              MOVS     r2,#4
0005fe  4649              MOV      r1,r9
000600  4668              MOV      r0,sp
000602  f7fffffe          BL       I2C_EE_ReadBuffer
;;;297    			if(chk1 == (*num) && chk2 == (*val))
000606  6828              LDR      r0,[r5,#0]
000608  9901              LDR      r1,[sp,#4]
00060a  4288              CMP      r0,r1
00060c  d104              BNE      |L1.1560|
00060e  6830              LDR      r0,[r6,#0]
000610  9900              LDR      r1,[sp,#0]
000612  4288              CMP      r0,r1
000614  d100              BNE      |L1.1560|
;;;298    				rs = TRUE;
000616  2701              MOVS     r7,#1
                  |L1.1560|
;;;299    		}while(rs == FALSE && i++ < 5);
000618  b927              CBNZ     r7,|L1.1572|
00061a  4640              MOV      r0,r8
00061c  f1080801          ADD      r8,r8,#1
000620  2805              CMP      r0,#5
000622  d390              BCC      |L1.1350|
                  |L1.1572|
;;;300    	}
;;;301    	return rs;
000624  4638              MOV      r0,r7
;;;302    }
000626  e8bd87fc          POP      {r2-r10,pc}
;;;303    
                          ENDP

                  e2p_set_vminfo PROC
;;;312    */
;;;313    void e2p_set_vminfo(SETUP_DEVICE *pt)
00062a  b510              PUSH     {r4,lr}
;;;314    {
00062c  4604              MOV      r4,r0
;;;315    	if(pt != 0)
00062e  b124              CBZ      r4,|L1.1594|
;;;316    	{
;;;317    		I2C_EE_WriteBuffer((uint8_t*)pt,SETUP_DEVICE_ADDR,sizeof(SETUP_DEVICE));
000630  220c              MOVS     r2,#0xc
000632  2110              MOVS     r1,#0x10
000634  4620              MOV      r0,r4
000636  f7fffffe          BL       I2C_EE_WriteBuffer
                  |L1.1594|
;;;318    	}
;;;319    }
00063a  bd10              POP      {r4,pc}
;;;320    
                          ENDP

                  e2p_set_common PROC
;;;323    */
;;;324    void e2p_set_common(SETUP_COMMON* pt)
00063c  b510              PUSH     {r4,lr}
;;;325    {
00063e  4604              MOV      r4,r0
;;;326    	if(pt != 0)
000640  b124              CBZ      r4,|L1.1612|
;;;327    	{
;;;328    		I2C_EE_WriteBuffer((uint8_t*)pt,SETUP_COMMON_ADDR,sizeof(SETUP_COMMON));
000642  2210              MOVS     r2,#0x10
000644  2120              MOVS     r1,#0x20
000646  4620              MOV      r0,r4
000648  f7fffffe          BL       I2C_EE_WriteBuffer
                  |L1.1612|
;;;329    	}
;;;330    	
;;;331    }
00064c  bd10              POP      {r4,pc}
;;;332    
                          ENDP

                  e2p_set_cashless PROC
;;;335    */
;;;336    void e2p_set_cashless(SETUP_CASHLESS* pt)
00064e  b510              PUSH     {r4,lr}
;;;337    {
000650  4604              MOV      r4,r0
;;;338    	if(pt != 0)
000652  b124              CBZ      r4,|L1.1630|
;;;339    	{
;;;340    		I2C_EE_WriteBuffer((uint8_t*)pt,SETUP_CASHLESS_ADDR,sizeof(SETUP_CASHLESS)); 
000654  2208              MOVS     r2,#8
000656  2130              MOVS     r1,#0x30
000658  4620              MOV      r0,r4
00065a  f7fffffe          BL       I2C_EE_WriteBuffer
                  |L1.1630|
;;;341    	}
;;;342    }
00065e  bd10              POP      {r4,pc}
;;;343    
                          ENDP

                  e2p_set_cash PROC
;;;346    */
;;;347    void e2p_set_cash(SETUP_CASH* pt)
000660  b510              PUSH     {r4,lr}
;;;348    {
000662  4604              MOV      r4,r0
;;;349    	if(pt != 0)
000664  b124              CBZ      r4,|L1.1648|
;;;350    	{
;;;351    		I2C_EE_WriteBuffer((uint8_t*)pt,SETUP_CASH_ADDR,sizeof(SETUP_CASH)); 
000666  2201              MOVS     r2,#1
000668  2140              MOVS     r1,#0x40
00066a  4620              MOV      r0,r4
00066c  f7fffffe          BL       I2C_EE_WriteBuffer
                  |L1.1648|
;;;352    	}
;;;353    }
000670  bd10              POP      {r4,pc}
;;;354    
                          ENDP

                  e2p_set_ex1 PROC
;;;358    */
;;;359    void e2p_set_ex1(SETUP_EX1* pt)
000672  b510              PUSH     {r4,lr}
;;;360    {
000674  4604              MOV      r4,r0
;;;361    	if(pt != 0)
000676  b124              CBZ      r4,|L1.1666|
;;;362    	{
;;;363    		I2C_EE_WriteBuffer((uint8_t*)pt,SETUP_EX1_ADDR,sizeof(SETUP_EX1)); 
000678  220e              MOVS     r2,#0xe
00067a  2150              MOVS     r1,#0x50
00067c  4620              MOV      r0,r4
00067e  f7fffffe          BL       I2C_EE_WriteBuffer
                  |L1.1666|
;;;364    	}
;;;365    }
000682  bd10              POP      {r4,pc}
;;;366    
                          ENDP

                  e2p_set_ex2 PROC
;;;369    */
;;;370    void e2p_set_ex2(SETUP_EX2* pt)
000684  b510              PUSH     {r4,lr}
;;;371    {
000686  4604              MOV      r4,r0
;;;372    	if(pt != 0)
000688  b124              CBZ      r4,|L1.1684|
;;;373    	{
;;;374    		I2C_EE_WriteBuffer((uint8_t*)pt,SETUP_EX2_ADDR,sizeof(SETUP_EX2)); 
00068a  220c              MOVS     r2,#0xc
00068c  2160              MOVS     r1,#0x60
00068e  4620              MOV      r0,r4
000690  f7fffffe          BL       I2C_EE_WriteBuffer
                  |L1.1684|
;;;375    	}
;;;376    }
000694  bd10              POP      {r4,pc}
;;;377    
                          ENDP

                  e2p_set_commucation PROC
;;;380    */
;;;381    void e2p_set_commucation(SETUP_COMMUCATION* pt)
000696  b510              PUSH     {r4,lr}
;;;382    {
000698  4604              MOV      r4,r0
;;;383    	if(pt != 0)
00069a  b124              CBZ      r4,|L1.1702|
;;;384    	{
;;;385    		I2C_EE_WriteBuffer((uint8_t*)pt,SETUP_COMMUCATION_ADDR,sizeof(SETUP_COMMUCATION)); 
00069c  2208              MOVS     r2,#8
00069e  2170              MOVS     r1,#0x70
0006a0  4620              MOV      r0,r4
0006a2  f7fffffe          BL       I2C_EE_WriteBuffer
                  |L1.1702|
;;;386    	}
;;;387    }
0006a6  bd10              POP      {r4,pc}
;;;388    
                          ENDP

                  e2p_set_channel PROC
;;;395    */
;;;396    bool e2p_set_channel(uint16_t channel, SETUP_CHANNEL* pt)
0006a8  e92d41ff          PUSH     {r0-r8,lr}
;;;397    {
0006ac  4605              MOV      r5,r0
0006ae  460c              MOV      r4,r1
;;;398    	bool rs = FALSE;
0006b0  2600              MOVS     r6,#0
;;;399    	uint8_t i = 0; 
0006b2  2700              MOVS     r7,#0
;;;400    	SETUP_CHANNEL tmp;
;;;401    	
;;;402    	if(pt != 0)
0006b4  2c00              CMP      r4,#0
0006b6  d054              BEQ      |L1.1890|
;;;403    	{
;;;404    		//注意这里每个机柜只有80个货道
;;;405    		do
0006b8  bf00              NOP      
                  |L1.1722|
;;;406    		{
;;;407    			I2C_EE_WriteBuffer((uint8_t*)pt, (SETUP_CHANNEL_ADDR + EEPROM_PAGE_SIZE*(channel%100) + (channel/100)*EEPROM_PAGE_SIZE*MAX_CHANNEL_SIZE ) ,sizeof(SETUP_CHANNEL));
0006ba  2064              MOVS     r0,#0x64
0006bc  fb95f1f0          SDIV     r1,r5,r0
0006c0  fb005011          MLS      r0,r0,r1,r5
0006c4  0100              LSLS     r0,r0,#4
0006c6  3080              ADDS     r0,r0,#0x80
0006c8  2164              MOVS     r1,#0x64
0006ca  fb95f1f1          SDIV     r1,r5,r1
0006ce  0109              LSLS     r1,r1,#4
0006d0  eb010181          ADD      r1,r1,r1,LSL #2
0006d4  eb001001          ADD      r0,r0,r1,LSL #4
0006d8  fa1ff880          UXTH     r8,r0
0006dc  2210              MOVS     r2,#0x10
0006de  4641              MOV      r1,r8
0006e0  4620              MOV      r0,r4
0006e2  f7fffffe          BL       I2C_EE_WriteBuffer
;;;408    			I2C_EE_ReadBuffer((uint8_t*)&tmp, (SETUP_CHANNEL_ADDR + EEPROM_PAGE_SIZE*(channel%100) + (channel/100)*EEPROM_PAGE_SIZE*MAX_CHANNEL_SIZE ) ,sizeof(SETUP_CHANNEL));
0006e6  2064              MOVS     r0,#0x64
0006e8  fb95f1f0          SDIV     r1,r5,r0
0006ec  fb005011          MLS      r0,r0,r1,r5
0006f0  0100              LSLS     r0,r0,#4
0006f2  3080              ADDS     r0,r0,#0x80
0006f4  2164              MOVS     r1,#0x64
0006f6  fb95f1f1          SDIV     r1,r5,r1
0006fa  0109              LSLS     r1,r1,#4
0006fc  eb010181          ADD      r1,r1,r1,LSL #2
000700  eb001001          ADD      r0,r0,r1,LSL #4
000704  fa1ff880          UXTH     r8,r0
000708  2210              MOVS     r2,#0x10
00070a  4641              MOV      r1,r8
00070c  4668              MOV      r0,sp
00070e  f7fffffe          BL       I2C_EE_ReadBuffer
;;;409    			if(tmp.code == pt->code && tmp.price == pt->price && tmp.priceCHK == pt->priceCHK && tmp.spring == pt->spring 
000712  9801              LDR      r0,[sp,#4]
000714  6861              LDR      r1,[r4,#4]
000716  4288              CMP      r0,r1
000718  d11d              BNE      |L1.1878|
00071a  9800              LDR      r0,[sp,#0]
00071c  6821              LDR      r1,[r4,#0]
00071e  4288              CMP      r0,r1
000720  d119              BNE      |L1.1878|
000722  f89d000e          LDRB     r0,[sp,#0xe]
000726  7ba1              LDRB     r1,[r4,#0xe]
000728  4288              CMP      r0,r1
00072a  d114              BNE      |L1.1878|
00072c  f8bd000c          LDRH     r0,[sp,#0xc]
000730  89a1              LDRH     r1,[r4,#0xc]
000732  4288              CMP      r0,r1
000734  d10f              BNE      |L1.1878|
;;;410    				&& tmp.store == pt->store && tmp.storeBkp == pt->storeBkp && tmp.type == pt->type)
000736  f8bd0008          LDRH     r0,[sp,#8]
00073a  8921              LDRH     r1,[r4,#8]
00073c  4288              CMP      r0,r1
00073e  d10a              BNE      |L1.1878|
000740  f8bd000a          LDRH     r0,[sp,#0xa]
000744  8961              LDRH     r1,[r4,#0xa]
000746  4288              CMP      r0,r1
000748  d105              BNE      |L1.1878|
00074a  f89d000f          LDRB     r0,[sp,#0xf]
00074e  7be1              LDRB     r1,[r4,#0xf]
000750  4288              CMP      r0,r1
000752  d100              BNE      |L1.1878|
;;;411    				rs = TRUE;
000754  2601              MOVS     r6,#1
                  |L1.1878|
;;;412    		}while(rs == FALSE && i++ < 5);
000756  b926              CBNZ     r6,|L1.1890|
000758  4638              MOV      r0,r7
00075a  1c79              ADDS     r1,r7,#1
00075c  b2cf              UXTB     r7,r1
00075e  2805              CMP      r0,#5
000760  dbab              BLT      |L1.1722|
                  |L1.1890|
;;;413    	}
;;;414    	return rs;
000762  4630              MOV      r0,r6
;;;415    }
000764  b004              ADD      sp,sp,#0x10
000766  e8bd81f0          POP      {r4-r8,pc}
;;;416    
                          ENDP

                  e2p_set_price PROC
;;;420    */
;;;421    bool e2p_set_price(uint16_t channel, uint32_t *dat)
00076a  e92d43fe          PUSH     {r1-r9,lr}
;;;422    {
00076e  4604              MOV      r4,r0
000770  460d              MOV      r5,r1
;;;423    	uint32_t price = 0xff;
000772  20ff              MOVS     r0,#0xff
000774  9002              STR      r0,[sp,#8]
;;;424    	uint8_t i = 0, bkp = 0xff, bkpChk = 0xff;
000776  2700              MOVS     r7,#0
000778  9001              STR      r0,[sp,#4]
00077a  9000              STR      r0,[sp,#0]
;;;425    	bool rs = FALSE;
00077c  2600              MOVS     r6,#0
;;;426    	
;;;427    	if(dat != 0)
00077e  2d00              CMP      r5,#0
000780  d075              BEQ      |L1.2158|
;;;428    	{
;;;429    		//写入验证5次
;;;430    		bkp = (((*dat) >> 24)&0xff) + (((*dat) >> 16)&0xff) + (((*dat) >> 8)&0xff) + ((*dat)&0xff);
000782  6828              LDR      r0,[r5,#0]
000784  0c00              LSRS     r0,r0,#16
000786  6829              LDR      r1,[r5,#0]
000788  eb006011          ADD      r0,r0,r1,LSR #24
00078c  8829              LDRH     r1,[r5,#0]
00078e  eb002011          ADD      r0,r0,r1,LSR #8
000792  7829              LDRB     r1,[r5,#0]
000794  4408              ADD      r0,r0,r1
000796  b2c0              UXTB     r0,r0
000798  9001              STR      r0,[sp,#4]
;;;431    		do{
00079a  bf00              NOP      
                  |L1.1948|
;;;432    			//写入价格
;;;433    			I2C_EE_WriteBuffer((uint8_t*)dat, (SETUP_CHANNEL_ADDR + EEPROM_PAGE_SIZE*(channel%100) + (channel/100)*EEPROM_PAGE_SIZE*MAX_CHANNEL_SIZE ) ,4);
00079c  2064              MOVS     r0,#0x64
00079e  fb94f1f0          SDIV     r1,r4,r0
0007a2  fb004011          MLS      r0,r0,r1,r4
0007a6  0100              LSLS     r0,r0,#4
0007a8  3080              ADDS     r0,r0,#0x80
0007aa  2164              MOVS     r1,#0x64
0007ac  fb94f1f1          SDIV     r1,r4,r1
0007b0  0109              LSLS     r1,r1,#4
0007b2  eb010181          ADD      r1,r1,r1,LSL #2
0007b6  eb001001          ADD      r0,r0,r1,LSL #4
0007ba  fa1ff880          UXTH     r8,r0
0007be  2204              MOVS     r2,#4
0007c0  4641              MOV      r1,r8
0007c2  4628              MOV      r0,r5
0007c4  f7fffffe          BL       I2C_EE_WriteBuffer
;;;434    			I2C_EE_ReadBuffer((uint8_t*)&price, (SETUP_CHANNEL_ADDR + EEPROM_PAGE_SIZE*(channel%100) + (channel/100)*EEPROM_PAGE_SIZE*MAX_CHANNEL_SIZE ) ,4);
0007c8  2064              MOVS     r0,#0x64
0007ca  fb94f1f0          SDIV     r1,r4,r0
0007ce  fb004011          MLS      r0,r0,r1,r4
0007d2  0100              LSLS     r0,r0,#4
0007d4  3080              ADDS     r0,r0,#0x80
0007d6  2164              MOVS     r1,#0x64
0007d8  fb94f1f1          SDIV     r1,r4,r1
0007dc  0109              LSLS     r1,r1,#4
0007de  eb010181          ADD      r1,r1,r1,LSL #2
0007e2  eb001001          ADD      r0,r0,r1,LSL #4
0007e6  fa1ff880          UXTH     r8,r0
0007ea  2204              MOVS     r2,#4
0007ec  4641              MOV      r1,r8
0007ee  a802              ADD      r0,sp,#8
0007f0  f7fffffe          BL       I2C_EE_ReadBuffer
;;;435    			//写入价格备份
;;;436    			I2C_EE_WriteBuffer((uint8_t*)&bkp, (SETUP_CHANNEL_ADDR + CHANNEL_PRICEBKP_OFFSET + EEPROM_PAGE_SIZE*(channel%100) + (channel/100)*EEPROM_PAGE_SIZE*MAX_CHANNEL_SIZE ) ,1);
0007f4  2064              MOVS     r0,#0x64
0007f6  fb94f1f0          SDIV     r1,r4,r0
0007fa  fb004011          MLS      r0,r0,r1,r4
0007fe  0100              LSLS     r0,r0,#4
000800  308e              ADDS     r0,r0,#0x8e
000802  2164              MOVS     r1,#0x64
000804  fb94f1f1          SDIV     r1,r4,r1
000808  0109              LSLS     r1,r1,#4
00080a  eb010181          ADD      r1,r1,r1,LSL #2
00080e  eb001001          ADD      r0,r0,r1,LSL #4
000812  fa1ff880          UXTH     r8,r0
000816  2201              MOVS     r2,#1
000818  4641              MOV      r1,r8
00081a  a801              ADD      r0,sp,#4
00081c  f7fffffe          BL       I2C_EE_WriteBuffer
;;;437    			I2C_EE_ReadBuffer((uint8_t*)&bkpChk, (SETUP_CHANNEL_ADDR + CHANNEL_PRICEBKP_OFFSET + EEPROM_PAGE_SIZE*(channel%100) + (channel/100)*EEPROM_PAGE_SIZE*MAX_CHANNEL_SIZE ) ,1);
000820  2064              MOVS     r0,#0x64
000822  fb94f1f0          SDIV     r1,r4,r0
000826  fb004011          MLS      r0,r0,r1,r4
00082a  0100              LSLS     r0,r0,#4
00082c  308e              ADDS     r0,r0,#0x8e
00082e  2164              MOVS     r1,#0x64
000830  fb94f1f1          SDIV     r1,r4,r1
000834  0109              LSLS     r1,r1,#4
000836  eb010181          ADD      r1,r1,r1,LSL #2
00083a  eb001001          ADD      r0,r0,r1,LSL #4
00083e  fa1ff880          UXTH     r8,r0
000842  2201              MOVS     r2,#1
000844  4641              MOV      r1,r8
000846  4668              MOV      r0,sp
000848  f7fffffe          BL       I2C_EE_ReadBuffer
;;;438    			
;;;439    			if(price == (*dat) && (bkp == bkpChk))
00084c  6828              LDR      r0,[r5,#0]
00084e  9902              LDR      r1,[sp,#8]
000850  4288              CMP      r0,r1
000852  d106              BNE      |L1.2146|
000854  f89d0004          LDRB     r0,[sp,#4]
000858  f89d1000          LDRB     r1,[sp,#0]
00085c  4288              CMP      r0,r1
00085e  d100              BNE      |L1.2146|
;;;440    				rs = TRUE;
000860  2601              MOVS     r6,#1
                  |L1.2146|
;;;441    		}while(rs == FALSE && i++ < 5);
000862  b926              CBNZ     r6,|L1.2158|
000864  4638              MOV      r0,r7
000866  1c79              ADDS     r1,r7,#1
000868  b2cf              UXTB     r7,r1
00086a  2805              CMP      r0,#5
00086c  db96              BLT      |L1.1948|
                  |L1.2158|
;;;442    	}
;;;443    	return rs;
00086e  4630              MOV      r0,r6
;;;444    }
000870  e8bd83fe          POP      {r1-r9,pc}
;;;445    /*
                          ENDP

                  e2p_set_channelEnable PROC
;;;447    */
;;;448    bool e2p_set_channelEnable(uint16_t channel, uint8_t *dat)
000874  e92d43f8          PUSH     {r3-r9,lr}
;;;449    {
000878  4604              MOV      r4,r0
00087a  460d              MOV      r5,r1
;;;450    	
;;;451    	uint8_t chk = 0xff, i = 0; 
00087c  20ff              MOVS     r0,#0xff
00087e  9000              STR      r0,[sp,#0]
000880  2700              MOVS     r7,#0
;;;452    	bool rs = FALSE;
000882  2600              MOVS     r6,#0
;;;453    	
;;;454    	if(dat != 0)
000884  b3c5              CBZ      r5,|L1.2296|
;;;455    	{
;;;456    		do{
000886  bf00              NOP      
                  |L1.2184|
;;;457    			I2C_EE_WriteBuffer((uint8_t*)dat, (SETUP_CHANNEL_ADDR + CHANNEL_ENABLE_OFFSET + EEPROM_PAGE_SIZE*(channel%100) + (channel/100)*EEPROM_PAGE_SIZE*MAX_CHANNEL_SIZE ) ,1);
000888  2064              MOVS     r0,#0x64
00088a  fb94f1f0          SDIV     r1,r4,r0
00088e  fb004011          MLS      r0,r0,r1,r4
000892  0100              LSLS     r0,r0,#4
000894  308f              ADDS     r0,r0,#0x8f
000896  2164              MOVS     r1,#0x64
000898  fb94f1f1          SDIV     r1,r4,r1
00089c  0109              LSLS     r1,r1,#4
00089e  eb010181          ADD      r1,r1,r1,LSL #2
0008a2  eb001001          ADD      r0,r0,r1,LSL #4
0008a6  fa1ff880          UXTH     r8,r0
0008aa  2201              MOVS     r2,#1
0008ac  4641              MOV      r1,r8
0008ae  4628              MOV      r0,r5
0008b0  f7fffffe          BL       I2C_EE_WriteBuffer
;;;458    			I2C_EE_ReadBuffer((uint8_t*)&chk, (SETUP_CHANNEL_ADDR + CHANNEL_ENABLE_OFFSET + EEPROM_PAGE_SIZE*(channel%100) + (channel/100)*EEPROM_PAGE_SIZE*MAX_CHANNEL_SIZE ) ,1);
0008b4  2064              MOVS     r0,#0x64
0008b6  fb94f1f0          SDIV     r1,r4,r0
0008ba  fb004011          MLS      r0,r0,r1,r4
0008be  0100              LSLS     r0,r0,#4
0008c0  308f              ADDS     r0,r0,#0x8f
0008c2  2164              MOVS     r1,#0x64
0008c4  fb94f1f1          SDIV     r1,r4,r1
0008c8  0109              LSLS     r1,r1,#4
0008ca  eb010181          ADD      r1,r1,r1,LSL #2
0008ce  eb001001          ADD      r0,r0,r1,LSL #4
0008d2  fa1ff880          UXTH     r8,r0
0008d6  2201              MOVS     r2,#1
0008d8  4641              MOV      r1,r8
0008da  4668              MOV      r0,sp
0008dc  f7fffffe          BL       I2C_EE_ReadBuffer
;;;459    			if(chk == (*dat))
0008e0  7828              LDRB     r0,[r5,#0]
0008e2  f89d1000          LDRB     r1,[sp,#0]
0008e6  4288              CMP      r0,r1
0008e8  d100              BNE      |L1.2284|
;;;460    				rs = TRUE;
0008ea  2601              MOVS     r6,#1
                  |L1.2284|
;;;461    		}while(rs == FALSE && i++ < 5);
0008ec  b926              CBNZ     r6,|L1.2296|
0008ee  4638              MOV      r0,r7
0008f0  1c79              ADDS     r1,r7,#1
0008f2  b2cf              UXTB     r7,r1
0008f4  2805              CMP      r0,#5
0008f6  dbc7              BLT      |L1.2184|
                  |L1.2296|
;;;462    	}
;;;463    	return rs;
0008f8  4630              MOV      r0,r6
;;;464    }
0008fa  e8bd83f8          POP      {r3-r9,pc}
;;;465    /*
                          ENDP

                  e2p_set_store PROC
;;;467    */
;;;468    bool e2p_set_store(uint16_t channel, uint16_t* dat)
0008fe  e92d43f8          PUSH     {r3-r9,lr}
;;;469    {
000902  4604              MOV      r4,r0
000904  460d              MOV      r5,r1
;;;470    	uint16_t chk = 0xff, i = 0; 
000906  20ff              MOVS     r0,#0xff
000908  9000              STR      r0,[sp,#0]
00090a  2700              MOVS     r7,#0
;;;471    	bool rs = FALSE;
00090c  2600              MOVS     r6,#0
;;;472    	
;;;473    	if(dat != 0)
00090e  b3c5              CBZ      r5,|L1.2434|
;;;474    	{
;;;475    		//写入结果验证5次
;;;476    		do{
000910  bf00              NOP      
                  |L1.2322|
;;;477    			I2C_EE_WriteBuffer((uint8_t*)dat, (SETUP_CHANNEL_ADDR + CHANNEL_STORE_OFFSET + EEPROM_PAGE_SIZE*(channel%100) + (channel/100)*EEPROM_PAGE_SIZE*MAX_CHANNEL_SIZE ) ,2 );
000912  2064              MOVS     r0,#0x64
000914  fb94f1f0          SDIV     r1,r4,r0
000918  fb004011          MLS      r0,r0,r1,r4
00091c  0100              LSLS     r0,r0,#4
00091e  3088              ADDS     r0,r0,#0x88
000920  2164              MOVS     r1,#0x64
000922  fb94f1f1          SDIV     r1,r4,r1
000926  0109              LSLS     r1,r1,#4
000928  eb010181          ADD      r1,r1,r1,LSL #2
00092c  eb001001          ADD      r0,r0,r1,LSL #4
000930  fa1ff880          UXTH     r8,r0
000934  2202              MOVS     r2,#2
000936  4641              MOV      r1,r8
000938  4628              MOV      r0,r5
00093a  f7fffffe          BL       I2C_EE_WriteBuffer
;;;478    			I2C_EE_ReadBuffer((uint8_t*)&chk, (SETUP_CHANNEL_ADDR + CHANNEL_STORE_OFFSET + EEPROM_PAGE_SIZE*(channel%100) + (channel/100)*EEPROM_PAGE_SIZE*MAX_CHANNEL_SIZE ) ,2 );
00093e  2064              MOVS     r0,#0x64
000940  fb94f1f0          SDIV     r1,r4,r0
000944  fb004011          MLS      r0,r0,r1,r4
000948  0100              LSLS     r0,r0,#4
00094a  3088              ADDS     r0,r0,#0x88
00094c  2164              MOVS     r1,#0x64
00094e  fb94f1f1          SDIV     r1,r4,r1
000952  0109              LSLS     r1,r1,#4
000954  eb010181          ADD      r1,r1,r1,LSL #2
000958  eb001001          ADD      r0,r0,r1,LSL #4
00095c  fa1ff880          UXTH     r8,r0
000960  2202              MOVS     r2,#2
000962  4641              MOV      r1,r8
000964  4668              MOV      r0,sp
000966  f7fffffe          BL       I2C_EE_ReadBuffer
;;;479    			if(chk == (*dat))
00096a  8828              LDRH     r0,[r5,#0]
00096c  f8bd1000          LDRH     r1,[sp,#0]
000970  4288              CMP      r0,r1
000972  d100              BNE      |L1.2422|
;;;480    				rs = TRUE;
000974  2601              MOVS     r6,#1
                  |L1.2422|
;;;481    		}while(rs == FALSE && i++ < 5);
000976  b926              CBNZ     r6,|L1.2434|
000978  4638              MOV      r0,r7
00097a  1c79              ADDS     r1,r7,#1
00097c  b28f              UXTH     r7,r1
00097e  2805              CMP      r0,#5
000980  dbc7              BLT      |L1.2322|
                  |L1.2434|
;;;482    	}
;;;483    	return rs;
000982  4630              MOV      r0,r6
;;;484    }
000984  e8bd83f8          POP      {r3-r9,pc}
;;;485    /*
                          ENDP

                  e2p_set_storeBkp PROC
;;;487    */
;;;488    bool e2p_set_storeBkp(uint16_t channel, uint16_t* dat)
000988  e92d43f8          PUSH     {r3-r9,lr}
;;;489    {
00098c  4604              MOV      r4,r0
00098e  460d              MOV      r5,r1
;;;490    	uint16_t chk = 0xff, i = 0; 
000990  20ff              MOVS     r0,#0xff
000992  9000              STR      r0,[sp,#0]
000994  2700              MOVS     r7,#0
;;;491    	bool rs = FALSE;
000996  2600              MOVS     r6,#0
;;;492    	
;;;493    	if(dat != 0)
000998  b3c5              CBZ      r5,|L1.2572|
;;;494    	{
;;;495    		//写入结果验证5次
;;;496    		do{
00099a  bf00              NOP      
                  |L1.2460|
;;;497    			I2C_EE_WriteBuffer((uint8_t*)dat, (SETUP_CHANNEL_ADDR + CHANNEL_STOREBKP_OFFSET + EEPROM_PAGE_SIZE*(channel%100) + (channel/100)*EEPROM_PAGE_SIZE*MAX_CHANNEL_SIZE ) ,2 );
00099c  2064              MOVS     r0,#0x64
00099e  fb94f1f0          SDIV     r1,r4,r0
0009a2  fb004011          MLS      r0,r0,r1,r4
0009a6  0100              LSLS     r0,r0,#4
0009a8  308a              ADDS     r0,r0,#0x8a
0009aa  2164              MOVS     r1,#0x64
0009ac  fb94f1f1          SDIV     r1,r4,r1
0009b0  0109              LSLS     r1,r1,#4
0009b2  eb010181          ADD      r1,r1,r1,LSL #2
0009b6  eb001001          ADD      r0,r0,r1,LSL #4
0009ba  fa1ff880          UXTH     r8,r0
0009be  2202              MOVS     r2,#2
0009c0  4641              MOV      r1,r8
0009c2  4628              MOV      r0,r5
0009c4  f7fffffe          BL       I2C_EE_WriteBuffer
;;;498    			I2C_EE_ReadBuffer((uint8_t*)&chk, (SETUP_CHANNEL_ADDR + CHANNEL_STOREBKP_OFFSET + EEPROM_PAGE_SIZE*(channel%100) + (channel/100)*EEPROM_PAGE_SIZE*MAX_CHANNEL_SIZE ) ,2 );
0009c8  2064              MOVS     r0,#0x64
0009ca  fb94f1f0          SDIV     r1,r4,r0
0009ce  fb004011          MLS      r0,r0,r1,r4
0009d2  0100              LSLS     r0,r0,#4
0009d4  308a              ADDS     r0,r0,#0x8a
0009d6  2164              MOVS     r1,#0x64
0009d8  fb94f1f1          SDIV     r1,r4,r1
0009dc  0109              LSLS     r1,r1,#4
0009de  eb010181          ADD      r1,r1,r1,LSL #2
0009e2  eb001001          ADD      r0,r0,r1,LSL #4
0009e6  fa1ff880          UXTH     r8,r0
0009ea  2202              MOVS     r2,#2
0009ec  4641              MOV      r1,r8
0009ee  4668              MOV      r0,sp
0009f0  f7fffffe          BL       I2C_EE_ReadBuffer
;;;499    			if(chk == (*dat))
0009f4  8828              LDRH     r0,[r5,#0]
0009f6  f8bd1000          LDRH     r1,[sp,#0]
0009fa  4288              CMP      r0,r1
0009fc  d100              BNE      |L1.2560|
;;;500    				rs = TRUE;
0009fe  2601              MOVS     r6,#1
                  |L1.2560|
;;;501    		}while(rs == FALSE && i++ < 5);
000a00  b926              CBNZ     r6,|L1.2572|
000a02  4638              MOV      r0,r7
000a04  1c79              ADDS     r1,r7,#1
000a06  b28f              UXTH     r7,r1
000a08  2805              CMP      r0,#5
000a0a  dbc7              BLT      |L1.2460|
                  |L1.2572|
;;;502    	}
;;;503    	return rs;
000a0c  4630              MOV      r0,r6
;;;504    }
000a0e  e8bd83f8          POP      {r3-r9,pc}
;;;505    /*
                          ENDP

                  e2p_set_spring PROC
;;;507    */
;;;508    bool e2p_set_spring(uint16_t channel, uint16_t* dat)
000a12  e92d43f8          PUSH     {r3-r9,lr}
;;;509    {
000a16  4604              MOV      r4,r0
000a18  460d              MOV      r5,r1
;;;510    	uint16_t chk = 0xff, i = 0; 
000a1a  20ff              MOVS     r0,#0xff
000a1c  9000              STR      r0,[sp,#0]
000a1e  2700              MOVS     r7,#0
;;;511    	bool rs = FALSE;
000a20  2600              MOVS     r6,#0
;;;512    	
;;;513    	if(dat != 0)
000a22  b3c5              CBZ      r5,|L1.2710|
;;;514    	{
;;;515    		do{
000a24  bf00              NOP      
                  |L1.2598|
;;;516    			I2C_EE_WriteBuffer((uint8_t*)dat, (SETUP_CHANNEL_ADDR + CHANNEL_SPRING_OFFSET + EEPROM_PAGE_SIZE*(channel%100) + (channel/100)*EEPROM_PAGE_SIZE*MAX_CHANNEL_SIZE ) ,2 );
000a26  2064              MOVS     r0,#0x64
000a28  fb94f1f0          SDIV     r1,r4,r0
000a2c  fb004011          MLS      r0,r0,r1,r4
000a30  0100              LSLS     r0,r0,#4
000a32  308c              ADDS     r0,r0,#0x8c
000a34  2164              MOVS     r1,#0x64
000a36  fb94f1f1          SDIV     r1,r4,r1
000a3a  0109              LSLS     r1,r1,#4
000a3c  eb010181          ADD      r1,r1,r1,LSL #2
000a40  eb001001          ADD      r0,r0,r1,LSL #4
000a44  fa1ff880          UXTH     r8,r0
000a48  2202              MOVS     r2,#2
000a4a  4641              MOV      r1,r8
000a4c  4628              MOV      r0,r5
000a4e  f7fffffe          BL       I2C_EE_WriteBuffer
;;;517    			I2C_EE_ReadBuffer((uint8_t*)&chk, (SETUP_CHANNEL_ADDR + CHANNEL_SPRING_OFFSET + EEPROM_PAGE_SIZE*(channel%100) + (channel/100)*EEPROM_PAGE_SIZE*MAX_CHANNEL_SIZE ) ,2 );
000a52  2064              MOVS     r0,#0x64
000a54  fb94f1f0          SDIV     r1,r4,r0
000a58  fb004011          MLS      r0,r0,r1,r4
000a5c  0100              LSLS     r0,r0,#4
000a5e  308c              ADDS     r0,r0,#0x8c
000a60  2164              MOVS     r1,#0x64
000a62  fb94f1f1          SDIV     r1,r4,r1
000a66  0109              LSLS     r1,r1,#4
000a68  eb010181          ADD      r1,r1,r1,LSL #2
000a6c  eb001001          ADD      r0,r0,r1,LSL #4
000a70  fa1ff880          UXTH     r8,r0
000a74  2202              MOVS     r2,#2
000a76  4641              MOV      r1,r8
000a78  4668              MOV      r0,sp
000a7a  f7fffffe          BL       I2C_EE_ReadBuffer
;;;518    			if(chk == (*dat))
000a7e  8828              LDRH     r0,[r5,#0]
000a80  f8bd1000          LDRH     r1,[sp,#0]
000a84  4288              CMP      r0,r1
000a86  d100              BNE      |L1.2698|
;;;519    				rs = TRUE;
000a88  2601              MOVS     r6,#1
                  |L1.2698|
;;;520    		}while(rs == FALSE && i++ < 5);
000a8a  b926              CBNZ     r6,|L1.2710|
000a8c  4638              MOV      r0,r7
000a8e  1c79              ADDS     r1,r7,#1
000a90  b28f              UXTH     r7,r1
000a92  2805              CMP      r0,#5
000a94  dbc7              BLT      |L1.2598|
                  |L1.2710|
;;;521    	}
;;;522    	return rs;
000a96  4630              MOV      r0,r6
;;;523    }
000a98  e8bd83f8          POP      {r3-r9,pc}
;;;524    /*
                          ENDP

                  e2p_set_channelCode PROC
;;;526    */
;;;527    bool e2p_set_channelCode(uint16_t channel, uint32_t* dat)
000a9c  e92d43f8          PUSH     {r3-r9,lr}
;;;528    {
000aa0  4604              MOV      r4,r0
000aa2  460d              MOV      r5,r1
;;;529    	uint32_t chk = 0xff, i = 0; 
000aa4  20ff              MOVS     r0,#0xff
000aa6  9000              STR      r0,[sp,#0]
000aa8  2700              MOVS     r7,#0
;;;530    	bool rs = FALSE;
000aaa  2600              MOVS     r6,#0
;;;531    	
;;;532    	if(dat != 0)
000aac  b3b5              CBZ      r5,|L1.2844|
;;;533    	{
;;;534    		do{
000aae  bf00              NOP      
                  |L1.2736|
;;;535    			I2C_EE_WriteBuffer((uint8_t*)dat, (SETUP_CHANNEL_ADDR + CHANNEL_CODE_OFFSET + EEPROM_PAGE_SIZE*(channel%100) + (channel/100)*EEPROM_PAGE_SIZE*MAX_CHANNEL_SIZE ) ,4 );
000ab0  2064              MOVS     r0,#0x64
000ab2  fb94f1f0          SDIV     r1,r4,r0
000ab6  fb004011          MLS      r0,r0,r1,r4
000aba  0100              LSLS     r0,r0,#4
000abc  3084              ADDS     r0,r0,#0x84
000abe  2164              MOVS     r1,#0x64
000ac0  fb94f1f1          SDIV     r1,r4,r1
000ac4  0109              LSLS     r1,r1,#4
000ac6  eb010181          ADD      r1,r1,r1,LSL #2
000aca  eb001001          ADD      r0,r0,r1,LSL #4
000ace  fa1ff880          UXTH     r8,r0
000ad2  2204              MOVS     r2,#4
000ad4  4641              MOV      r1,r8
000ad6  4628              MOV      r0,r5
000ad8  f7fffffe          BL       I2C_EE_WriteBuffer
;;;536    			I2C_EE_ReadBuffer((uint8_t*)&chk, (SETUP_CHANNEL_ADDR + CHANNEL_CODE_OFFSET + EEPROM_PAGE_SIZE*(channel%100) + (channel/100)*EEPROM_PAGE_SIZE*MAX_CHANNEL_SIZE ) ,4 );
000adc  2064              MOVS     r0,#0x64
000ade  fb94f1f0          SDIV     r1,r4,r0
000ae2  fb004011          MLS      r0,r0,r1,r4
000ae6  0100              LSLS     r0,r0,#4
000ae8  3084              ADDS     r0,r0,#0x84
000aea  2164              MOVS     r1,#0x64
000aec  fb94f1f1          SDIV     r1,r4,r1
000af0  0109              LSLS     r1,r1,#4
000af2  eb010181          ADD      r1,r1,r1,LSL #2
000af6  eb001001          ADD      r0,r0,r1,LSL #4
000afa  fa1ff880          UXTH     r8,r0
000afe  2204              MOVS     r2,#4
000b00  4641              MOV      r1,r8
000b02  4668              MOV      r0,sp
000b04  f7fffffe          BL       I2C_EE_ReadBuffer
;;;537    			if(chk == (*dat))
000b08  6828              LDR      r0,[r5,#0]
000b0a  9900              LDR      r1,[sp,#0]
000b0c  4288              CMP      r0,r1
000b0e  d100              BNE      |L1.2834|
;;;538    				rs = TRUE;
000b10  2601              MOVS     r6,#1
                  |L1.2834|
;;;539    		}while(rs == FALSE && i++ < 5);
000b12  b91e              CBNZ     r6,|L1.2844|
000b14  4638              MOV      r0,r7
000b16  1c7f              ADDS     r7,r7,#1
000b18  2805              CMP      r0,#5
000b1a  d3c9              BCC      |L1.2736|
                  |L1.2844|
;;;540    	}
;;;541    	return rs;
000b1c  4630              MOV      r0,r6
;;;542    }
000b1e  e8bd83f8          POP      {r3-r9,pc}
;;;543    
                          ENDP

                  e2p_add_channelStatistic PROC
;;;546    */
;;;547    bool e2p_add_channelStatistic(uint16_t channel, uint32_t addnum, uint32_t addval)
000b22  e92d47f0          PUSH     {r4-r10,lr}
;;;548    {
000b26  b088              SUB      sp,sp,#0x20
000b28  4604              MOV      r4,r0
000b2a  460f              MOV      r7,r1
000b2c  4690              MOV      r8,r2
;;;549    	uint32_t chk1 = 0xff, chk2 = 0xff, i = 0, j = 0, num, val;
000b2e  20ff              MOVS     r0,#0xff
000b30  9007              STR      r0,[sp,#0x1c]
000b32  9006              STR      r0,[sp,#0x18]
000b34  f04f0900          MOV      r9,#0
000b38  2500              MOVS     r5,#0
;;;550    	uint8_t dat[8],datChk[8];
;;;551    	bool rs = TRUE;
000b3a  2601              MOVS     r6,#1
;;;552    	
;;;553    	do{
000b3c  bf00              NOP      
                  |L1.2878|
;;;554    		I2C_EE_ReadBuffer((uint8_t*)&dat,    (SETUP_COLUMN_ADDR + EEPROM_PAGE_SIZE*(channel%100) + (channel/100)*EEPROM_PAGE_SIZE*MAX_CHANNEL_SIZE ) ,8 );
000b3e  2064              MOVS     r0,#0x64
000b40  fb94f1f0          SDIV     r1,r4,r0
000b44  fb004011          MLS      r0,r0,r1,r4
000b48  0100              LSLS     r0,r0,#4
000b4a  f5005036          ADD      r0,r0,#0x2d80
000b4e  2164              MOVS     r1,#0x64
000b50  fb94f1f1          SDIV     r1,r4,r1
000b54  0109              LSLS     r1,r1,#4
000b56  eb010181          ADD      r1,r1,r1,LSL #2
000b5a  eb001001          ADD      r0,r0,r1,LSL #4
000b5e  fa1ffa80          UXTH     r10,r0
000b62  2208              MOVS     r2,#8
000b64  4651              MOV      r1,r10
000b66  a802              ADD      r0,sp,#8
000b68  f7fffffe          BL       I2C_EE_ReadBuffer
;;;555    		I2C_EE_ReadBuffer((uint8_t*)&datChk, (SETUP_COLUMN_ADDR + EEPROM_PAGE_SIZE*(channel%100) + (channel/100)*EEPROM_PAGE_SIZE*MAX_CHANNEL_SIZE ) ,8 );
000b6c  2064              MOVS     r0,#0x64
000b6e  fb94f1f0          SDIV     r1,r4,r0
000b72  fb004011          MLS      r0,r0,r1,r4
000b76  0100              LSLS     r0,r0,#4
000b78  f5005036          ADD      r0,r0,#0x2d80
000b7c  2164              MOVS     r1,#0x64
000b7e  fb94f1f1          SDIV     r1,r4,r1
000b82  0109              LSLS     r1,r1,#4
000b84  eb010181          ADD      r1,r1,r1,LSL #2
000b88  eb001001          ADD      r0,r0,r1,LSL #4
000b8c  fa1ffa80          UXTH     r10,r0
000b90  2208              MOVS     r2,#8
000b92  4651              MOV      r1,r10
000b94  4668              MOV      r0,sp
000b96  f7fffffe          BL       I2C_EE_ReadBuffer
;;;556    		for(j = 0; j < 8; j++)
000b9a  2500              MOVS     r5,#0
000b9c  e007              B        |L1.2990|
                  |L1.2974|
;;;557    		{
;;;558    			if(dat[j] != datChk[j])
000b9e  a802              ADD      r0,sp,#8
000ba0  5d40              LDRB     r0,[r0,r5]
000ba2  f81d1005          LDRB     r1,[sp,r5]
000ba6  4288              CMP      r0,r1
000ba8  d000              BEQ      |L1.2988|
;;;559    				rs = FALSE;
000baa  2600              MOVS     r6,#0
                  |L1.2988|
000bac  1c6d              ADDS     r5,r5,#1              ;556
                  |L1.2990|
000bae  2d08              CMP      r5,#8                 ;556
000bb0  d3f5              BCC      |L1.2974|
;;;560    		}
;;;561    	}while(rs == FALSE && i++ < 5);
000bb2  b926              CBNZ     r6,|L1.3006|
000bb4  4648              MOV      r0,r9
000bb6  f1090901          ADD      r9,r9,#1
000bba  2805              CMP      r0,#5
000bbc  d3bf              BCC      |L1.2878|
                  |L1.3006|
;;;562    	
;;;563    	if(rs == TRUE)
000bbe  2e01              CMP      r6,#1
000bc0  d17e              BNE      |L1.3264|
;;;564    	{
;;;565    		i = 0;
000bc2  f04f0900          MOV      r9,#0
;;;566    		rs = FALSE;
000bc6  2600              MOVS     r6,#0
;;;567    		num = ( (dat[3] << 24) | (dat[2] << 16) | (dat[1] << 8) | dat[0] ) + (addnum);
000bc8  f89d000b          LDRB     r0,[sp,#0xb]
000bcc  0600              LSLS     r0,r0,#24
000bce  f89d100a          LDRB     r1,[sp,#0xa]
000bd2  ea404001          ORR      r0,r0,r1,LSL #16
000bd6  f89d1009          LDRB     r1,[sp,#9]
000bda  ea402001          ORR      r0,r0,r1,LSL #8
000bde  f89d1008          LDRB     r1,[sp,#8]
000be2  4308              ORRS     r0,r0,r1
000be4  4438              ADD      r0,r0,r7
000be6  9005              STR      r0,[sp,#0x14]
;;;568    		val = ( (dat[7] << 24) | (dat[6] << 16) | (dat[5] << 8) | dat[4] ) + (addval);
000be8  f89d000f          LDRB     r0,[sp,#0xf]
000bec  0600              LSLS     r0,r0,#24
000bee  f89d100e          LDRB     r1,[sp,#0xe]
000bf2  ea404001          ORR      r0,r0,r1,LSL #16
000bf6  f89d100d          LDRB     r1,[sp,#0xd]
000bfa  ea402001          ORR      r0,r0,r1,LSL #8
000bfe  f89d100c          LDRB     r1,[sp,#0xc]
000c02  4308              ORRS     r0,r0,r1
000c04  4440              ADD      r0,r0,r8
000c06  9004              STR      r0,[sp,#0x10]
;;;569    		if(addnum != 0 && addval != 0)
000c08  2f00              CMP      r7,#0
000c0a  d074              BEQ      |L1.3318|
000c0c  f1b80f00          CMP      r8,#0
000c10  d071              BEQ      |L1.3318|
;;;570    		{
;;;571    			do{
000c12  bf00              NOP      
                  |L1.3092|
;;;572    				
;;;573    				I2C_EE_WriteBuffer((uint8_t*)&num, (SETUP_COLUMN_ADDR + EEPROM_PAGE_SIZE*(channel%100) + (channel/100)*EEPROM_PAGE_SIZE*MAX_CHANNEL_SIZE ) ,4 );
000c14  2064              MOVS     r0,#0x64
000c16  fb94f1f0          SDIV     r1,r4,r0
000c1a  fb004011          MLS      r0,r0,r1,r4
000c1e  0100              LSLS     r0,r0,#4
000c20  f5005036          ADD      r0,r0,#0x2d80
000c24  2164              MOVS     r1,#0x64
000c26  fb94f1f1          SDIV     r1,r4,r1
000c2a  0109              LSLS     r1,r1,#4
000c2c  eb010181          ADD      r1,r1,r1,LSL #2
000c30  eb001001          ADD      r0,r0,r1,LSL #4
000c34  fa1ffa80          UXTH     r10,r0
000c38  2204              MOVS     r2,#4
000c3a  4651              MOV      r1,r10
000c3c  a805              ADD      r0,sp,#0x14
000c3e  f7fffffe          BL       I2C_EE_WriteBuffer
;;;574    				I2C_EE_ReadBuffer((uint8_t*)&chk1, (SETUP_COLUMN_ADDR + EEPROM_PAGE_SIZE*(channel%100) + (channel/100)*EEPROM_PAGE_SIZE*MAX_CHANNEL_SIZE ) ,4 );
000c42  2064              MOVS     r0,#0x64
000c44  fb94f1f0          SDIV     r1,r4,r0
000c48  fb004011          MLS      r0,r0,r1,r4
000c4c  0100              LSLS     r0,r0,#4
000c4e  f5005036          ADD      r0,r0,#0x2d80
000c52  2164              MOVS     r1,#0x64
000c54  fb94f1f1          SDIV     r1,r4,r1
000c58  0109              LSLS     r1,r1,#4
000c5a  eb010181          ADD      r1,r1,r1,LSL #2
000c5e  eb001001          ADD      r0,r0,r1,LSL #4
000c62  fa1ffa80          UXTH     r10,r0
000c66  2204              MOVS     r2,#4
000c68  4651              MOV      r1,r10
000c6a  a807              ADD      r0,sp,#0x1c
000c6c  f7fffffe          BL       I2C_EE_ReadBuffer
;;;575    				I2C_EE_WriteBuffer((uint8_t*)&val, (SETUP_COLUMN_ADDR + 4 + EEPROM_PAGE_SIZE*(channel%100) + (channel/100)*EEPROM_PAGE_SIZE*MAX_CHANNEL_SIZE ) ,4 );
000c70  2064              MOVS     r0,#0x64
000c72  fb94f1f0          SDIV     r1,r4,r0
000c76  fb004011          MLS      r0,r0,r1,r4
000c7a  f6425184          MOV      r1,#0x2d84
000c7e  2210              MOVS     r2,#0x10
000c80  fb021000          MLA      r0,r2,r0,r1
000c84  2164              MOVS     r1,#0x64
000c86  fb94f1f1          SDIV     r1,r4,r1
000c8a  0109              LSLS     r1,r1,#4
000c8c  eb010181          ADD      r1,r1,r1,LSL #2
000c90  eb001001          ADD      r0,r0,r1,LSL #4
000c94  fa1ffa80          UXTH     r10,r0
000c98  2204              MOVS     r2,#4
000c9a  4651              MOV      r1,r10
000c9c  a804              ADD      r0,sp,#0x10
000c9e  f7fffffe          BL       I2C_EE_WriteBuffer
;;;576    				I2C_EE_ReadBuffer((uint8_t*)&chk2, (SETUP_COLUMN_ADDR + 4 + EEPROM_PAGE_SIZE*(channel%100) + (channel/100)*EEPROM_PAGE_SIZE*MAX_CHANNEL_SIZE ) ,4 );
000ca2  2064              MOVS     r0,#0x64
000ca4  fb94f1f0          SDIV     r1,r4,r0
000ca8  fb004011          MLS      r0,r0,r1,r4
000cac  f6425184          MOV      r1,#0x2d84
000cb0  2210              MOVS     r2,#0x10
000cb2  fb021000          MLA      r0,r2,r0,r1
000cb6  2164              MOVS     r1,#0x64
000cb8  fb94f1f1          SDIV     r1,r4,r1
000cbc  0109              LSLS     r1,r1,#4
000cbe  e000              B        |L1.3266|
                  |L1.3264|
000cc0  e019              B        |L1.3318|
                  |L1.3266|
000cc2  eb010181          ADD      r1,r1,r1,LSL #2
000cc6  eb001001          ADD      r0,r0,r1,LSL #4
000cca  fa1ffa80          UXTH     r10,r0
000cce  2204              MOVS     r2,#4
000cd0  4651              MOV      r1,r10
000cd2  a806              ADD      r0,sp,#0x18
000cd4  f7fffffe          BL       I2C_EE_ReadBuffer
;;;577    				
;;;578    				if(chk1 == num && chk2 == val)
000cd8  9905              LDR      r1,[sp,#0x14]
000cda  9807              LDR      r0,[sp,#0x1c]
000cdc  4288              CMP      r0,r1
000cde  d104              BNE      |L1.3306|
000ce0  9904              LDR      r1,[sp,#0x10]
000ce2  9806              LDR      r0,[sp,#0x18]
000ce4  4288              CMP      r0,r1
000ce6  d100              BNE      |L1.3306|
;;;579    					rs = TRUE;
000ce8  2601              MOVS     r6,#1
                  |L1.3306|
;;;580    			}while(rs == FALSE && i++ < 5);
000cea  b926              CBNZ     r6,|L1.3318|
000cec  4648              MOV      r0,r9
000cee  f1090901          ADD      r9,r9,#1
000cf2  2805              CMP      r0,#5
000cf4  d38e              BCC      |L1.3092|
                  |L1.3318|
;;;581    		}
;;;582    	}
;;;583    	return rs;
000cf6  4630              MOV      r0,r6
;;;584    }
000cf8  b008              ADD      sp,sp,#0x20
000cfa  e8bd87f0          POP      {r4-r10,pc}
;;;585    
                          ENDP

                  e2p_set_channelStatistic PROC
;;;588    */
;;;589    bool e2p_set_channelStatistic(uint16_t channel, uint32_t num, uint32_t val)
000cfe  b5f7              PUSH     {r0-r2,r4-r7,lr}
;;;590    {
000d00  b082              SUB      sp,sp,#8
000d02  4604              MOV      r4,r0
;;;591    	uint32_t chk1 = 0xff, chk2 = 0xff, i = 0;
000d04  20ff              MOVS     r0,#0xff
000d06  9001              STR      r0,[sp,#4]
000d08  9000              STR      r0,[sp,#0]
000d0a  2600              MOVS     r6,#0
;;;592    	bool rs = FALSE;
000d0c  2500              MOVS     r5,#0
;;;593    	
;;;594    	do{
000d0e  bf00              NOP      
                  |L1.3344|
;;;595    		
;;;596    		I2C_EE_WriteBuffer((uint8_t*)&num, (SETUP_COLUMN_ADDR + EEPROM_PAGE_SIZE*(channel%100) + (channel/100)*EEPROM_PAGE_SIZE*MAX_CHANNEL_SIZE ) ,4 );
000d10  2064              MOVS     r0,#0x64
000d12  fb94f1f0          SDIV     r1,r4,r0
000d16  fb004011          MLS      r0,r0,r1,r4
000d1a  0100              LSLS     r0,r0,#4
000d1c  f5005036          ADD      r0,r0,#0x2d80
000d20  2164              MOVS     r1,#0x64
000d22  fb94f1f1          SDIV     r1,r4,r1
000d26  0109              LSLS     r1,r1,#4
000d28  eb010181          ADD      r1,r1,r1,LSL #2
000d2c  eb001001          ADD      r0,r0,r1,LSL #4
000d30  b287              UXTH     r7,r0
000d32  2204              MOVS     r2,#4
000d34  4639              MOV      r1,r7
000d36  a803              ADD      r0,sp,#0xc
000d38  f7fffffe          BL       I2C_EE_WriteBuffer
;;;597    		I2C_EE_ReadBuffer((uint8_t*)&chk1, (SETUP_COLUMN_ADDR + EEPROM_PAGE_SIZE*(channel%100) + (channel/100)*EEPROM_PAGE_SIZE*MAX_CHANNEL_SIZE ) ,4 );
000d3c  2064              MOVS     r0,#0x64
000d3e  fb94f1f0          SDIV     r1,r4,r0
000d42  fb004011          MLS      r0,r0,r1,r4
000d46  0100              LSLS     r0,r0,#4
000d48  f5005036          ADD      r0,r0,#0x2d80
000d4c  2164              MOVS     r1,#0x64
000d4e  fb94f1f1          SDIV     r1,r4,r1
000d52  0109              LSLS     r1,r1,#4
000d54  eb010181          ADD      r1,r1,r1,LSL #2
000d58  eb001001          ADD      r0,r0,r1,LSL #4
000d5c  b287              UXTH     r7,r0
000d5e  2204              MOVS     r2,#4
000d60  4639              MOV      r1,r7
000d62  a801              ADD      r0,sp,#4
000d64  f7fffffe          BL       I2C_EE_ReadBuffer
;;;598    		I2C_EE_WriteBuffer((uint8_t*)&val, (SETUP_COLUMN_ADDR + 4 + EEPROM_PAGE_SIZE*(channel%100) + (channel/100)*EEPROM_PAGE_SIZE*MAX_CHANNEL_SIZE ) ,4 );
000d68  2064              MOVS     r0,#0x64
000d6a  fb94f1f0          SDIV     r1,r4,r0
000d6e  fb004011          MLS      r0,r0,r1,r4
000d72  f6425184          MOV      r1,#0x2d84
000d76  2210              MOVS     r2,#0x10
000d78  fb021000          MLA      r0,r2,r0,r1
000d7c  2164              MOVS     r1,#0x64
000d7e  fb94f1f1          SDIV     r1,r4,r1
000d82  0109              LSLS     r1,r1,#4
000d84  eb010181          ADD      r1,r1,r1,LSL #2
000d88  eb001001          ADD      r0,r0,r1,LSL #4
000d8c  b287              UXTH     r7,r0
000d8e  2204              MOVS     r2,#4
000d90  4639              MOV      r1,r7
000d92  a804              ADD      r0,sp,#0x10
000d94  f7fffffe          BL       I2C_EE_WriteBuffer
;;;599    		I2C_EE_ReadBuffer((uint8_t*)&chk2, (SETUP_COLUMN_ADDR + 4 + EEPROM_PAGE_SIZE*(channel%100) + (channel/100)*EEPROM_PAGE_SIZE*MAX_CHANNEL_SIZE ) ,4 );
000d98  2064              MOVS     r0,#0x64
000d9a  fb94f1f0          SDIV     r1,r4,r0
000d9e  fb004011          MLS      r0,r0,r1,r4
000da2  f6425184          MOV      r1,#0x2d84
000da6  2210              MOVS     r2,#0x10
000da8  fb021000          MLA      r0,r2,r0,r1
000dac  2164              MOVS     r1,#0x64
000dae  fb94f1f1          SDIV     r1,r4,r1
000db2  0109              LSLS     r1,r1,#4
000db4  eb010181          ADD      r1,r1,r1,LSL #2
000db8  eb001001          ADD      r0,r0,r1,LSL #4
000dbc  b287              UXTH     r7,r0
000dbe  2204              MOVS     r2,#4
000dc0  4639              MOV      r1,r7
000dc2  4668              MOV      r0,sp
000dc4  f7fffffe          BL       I2C_EE_ReadBuffer
;;;600    		if(chk1 == num && chk2 == val)
000dc8  9903              LDR      r1,[sp,#0xc]
000dca  9801              LDR      r0,[sp,#4]
000dcc  4288              CMP      r0,r1
000dce  d104              BNE      |L1.3546|
000dd0  9904              LDR      r1,[sp,#0x10]
000dd2  9800              LDR      r0,[sp,#0]
000dd4  4288              CMP      r0,r1
000dd6  d100              BNE      |L1.3546|
;;;601    			rs = TRUE;
000dd8  2501              MOVS     r5,#1
                  |L1.3546|
;;;602    	}while(rs == FALSE && i++ < 5);
000dda  b91d              CBNZ     r5,|L1.3556|
000ddc  4630              MOV      r0,r6
000dde  1c76              ADDS     r6,r6,#1
000de0  2805              CMP      r0,#5
000de2  d395              BCC      |L1.3344|
                  |L1.3556|
;;;603    	return rs;
000de4  4628              MOV      r0,r5
;;;604    }
000de6  b005              ADD      sp,sp,#0x14
000de8  bdf0              POP      {r4-r7,pc}
;;;605    
                          ENDP

                  e2p_reset_device PROC
;;;613    */
;;;614    static void e2p_reset_device(void)
000dea  b50e              PUSH     {r1-r3,lr}
;;;615    {
;;;616    	SETUP_DEVICE	mac;
;;;617    	mac.data = 20170501;//2017年5月1号
000dec  48ae              LDR      r0,|L1.4264|
000dee  9002              STR      r0,[sp,#8]
;;;618    	mac.facId = 1000000000;
000df0  48ae              LDR      r0,|L1.4268|
000df2  9000              STR      r0,[sp,#0]
;;;619    	mac.usrId = 999999;
000df4  48ae              LDR      r0,|L1.4272|
000df6  9001              STR      r0,[sp,#4]
;;;620    	I2C_EE_WriteBuffer((uint8_t*)(&mac), SETUP_DEVICE_ADDR, sizeof(SETUP_DEVICE));
000df8  220c              MOVS     r2,#0xc
000dfa  2110              MOVS     r1,#0x10
000dfc  4668              MOV      r0,sp
000dfe  f7fffffe          BL       I2C_EE_WriteBuffer
;;;621    }
000e02  bd0e              POP      {r1-r3,pc}
;;;622    
                          ENDP

                  e2p_reset_common PROC
;;;625    */
;;;626    static void e2p_reset_common(void)
000e04  b51f              PUSH     {r0-r4,lr}
;;;627    {
;;;628    	SETUP_COMMON common;
;;;629    	
;;;630    	common.drvnum = 1;		//机柜数
000e06  2001              MOVS     r0,#1
000e08  f88d0006          STRB     r0,[sp,#6]
;;;631    	common.traynum = 6;		//托盘数
000e0c  2006              MOVS     r0,#6
000e0e  f88d0007          STRB     r0,[sp,#7]
;;;632    	common.factor = 1;		//比例因子
000e12  2001              MOVS     r0,#1
000e14  9000              STR      r0,[sp,#0]
;;;633    	common.language = 1;	//1中文0英文
000e16  f88d0005          STRB     r0,[sp,#5]
;;;634    	common.numChannel = 1;	//货道位数
000e1a  f88d000b          STRB     r0,[sp,#0xb]
;;;635    	common.numPrice = 4;	//价格位数
000e1e  2004              MOVS     r0,#4
000e20  f88d000a          STRB     r0,[sp,#0xa]
;;;636    	common.numStore = 3;	//库存位数
000e24  2003              MOVS     r0,#3
000e26  f88d0009          STRB     r0,[sp,#9]
;;;637    	common.point = 2;		//小数点位数
000e2a  2002              MOVS     r0,#2
000e2c  f88d0004          STRB     r0,[sp,#4]
;;;638    	common.numGoodsId = 6;	//商品条码位数
000e30  2006              MOVS     r0,#6
000e32  f88d000c          STRB     r0,[sp,#0xc]
;;;639    	common.screenHorizontal = 0;//横竖屏：0：横；1：竖
000e36  2000              MOVS     r0,#0
000e38  f88d0008          STRB     r0,[sp,#8]
;;;640    	
;;;641    	I2C_EE_WriteBuffer((uint8_t*)(&common),SETUP_COMMON_ADDR,sizeof(SETUP_COMMON));
000e3c  2210              MOVS     r2,#0x10
000e3e  2120              MOVS     r1,#0x20
000e40  4668              MOV      r0,sp
000e42  f7fffffe          BL       I2C_EE_WriteBuffer
;;;642    	
;;;643    }
000e46  bd1f              POP      {r0-r4,pc}
;;;644    
                          ENDP

                  e2p_reset_cashless PROC
;;;648    */
;;;649    static void e2p_reset_cashless(void)
000e48  b51c              PUSH     {r2-r4,lr}
;;;650    {
;;;651    	SETUP_CASHLESS	cashlessSet;
;;;652    	cashlessSet.applyEnable = 0;
000e4a  2000              MOVS     r0,#0
000e4c  f88d0004          STRB     r0,[sp,#4]
;;;653    	cashlessSet.port = 1001;
000e50  f24030e9          MOV      r0,#0x3e9
000e54  9000              STR      r0,[sp,#0]
;;;654    	I2C_EE_WriteBuffer((uint8_t*)(&cashlessSet), SETUP_CASHLESS_ADDR, sizeof(SETUP_CASHLESS));
000e56  2208              MOVS     r2,#8
000e58  2130              MOVS     r1,#0x30
000e5a  4668              MOV      r0,sp
000e5c  f7fffffe          BL       I2C_EE_WriteBuffer
;;;655    
;;;656    }
000e60  bd1c              POP      {r2-r4,pc}
;;;657    /*
                          ENDP

                  e2p_reset_cash PROC
;;;659    */
;;;660    static void e2p_reset_cash(void)
000e62  b508              PUSH     {r3,lr}
;;;661    {
;;;662    	SETUP_CASH	cash_set;
;;;663    	cash_set.coinLever = NULL;//不限制层级
000e64  2000              MOVS     r0,#0
000e66  9000              STR      r0,[sp,#0]
;;;664    	I2C_EE_WriteBuffer((uint8_t*)(&cash_set), SETUP_CASH_ADDR, sizeof(SETUP_CASH));
000e68  2201              MOVS     r2,#1
000e6a  2140              MOVS     r1,#0x40
000e6c  4668              MOV      r0,sp
000e6e  f7fffffe          BL       I2C_EE_WriteBuffer
;;;665    
;;;666    }
000e72  bd08              POP      {r3,pc}
;;;667    /*
                          ENDP

                  e2p_reset_ex1 PROC
;;;669    */
;;;670    static void e2p_reset_ex1(void)
000e74  b51f              PUSH     {r0-r4,lr}
;;;671    {
;;;672    	SETUP_EX1	ex1Set;
;;;673    	ex1Set.tempTarget = 5;	//目标温度
000e76  2005              MOVS     r0,#5
000e78  f88d000c          STRB     r0,[sp,#0xc]
;;;674    	ex1Set.workMode = 0;	//0制冷；1制热
000e7c  2000              MOVS     r0,#0
000e7e  f88d000d          STRB     r0,[sp,#0xd]
;;;675    	ex1Set.starttime_1 = 0;
000e82  f8ad0000          STRH     r0,[sp,#0]
;;;676    	ex1Set.starttime_2 = 2359;
000e86  f6401037          MOV      r0,#0x937
000e8a  f8ad0004          STRH     r0,[sp,#4]
;;;677    	ex1Set.starttime_3 = 0;
000e8e  2000              MOVS     r0,#0
000e90  f8ad0008          STRH     r0,[sp,#8]
;;;678    	ex1Set.stoptime_1 = 2359;
000e94  f6401037          MOV      r0,#0x937
000e98  f8ad0002          STRH     r0,[sp,#2]
;;;679    	ex1Set.stoptime_2 = 2359;
000e9c  f8ad0006          STRH     r0,[sp,#6]
;;;680    	ex1Set.stoptime_3 = 2359;
000ea0  f8ad000a          STRH     r0,[sp,#0xa]
;;;681    
;;;682    	I2C_EE_WriteBuffer((uint8_t*)(&ex1Set), SETUP_EX1_ADDR, sizeof(SETUP_EX1));
000ea4  220e              MOVS     r2,#0xe
000ea6  2150              MOVS     r1,#0x50
000ea8  4668              MOV      r0,sp
000eaa  f7fffffe          BL       I2C_EE_WriteBuffer
;;;683    
;;;684    }
000eae  bd1f              POP      {r0-r4,pc}
;;;685    /*
                          ENDP

                  e2p_reset_ex2 PROC
;;;687    */
;;;688    static void e2p_reset_ex2(void)
000eb0  b50e              PUSH     {r1-r3,lr}
;;;689    {
;;;690    	SETUP_EX2	ex2Set;
;;;691    	ex2Set.starttime_4 = 2359; 
000eb2  f6401037          MOV      r0,#0x937
000eb6  f8ad0000          STRH     r0,[sp,#0]
;;;692    	ex2Set.starttime_5 = 2359;
000eba  f8ad0004          STRH     r0,[sp,#4]
;;;693    	ex2Set.starttime_6 = 2359;
000ebe  f8ad0008          STRH     r0,[sp,#8]
;;;694    	ex2Set.stoptime_4 = 2359;
000ec2  f8ad0002          STRH     r0,[sp,#2]
;;;695    	ex2Set.stoptime_5 = 2359;
000ec6  f8ad0006          STRH     r0,[sp,#6]
;;;696    	ex2Set.stoptime_6 = 2359;
000eca  f8ad000a          STRH     r0,[sp,#0xa]
;;;697    	I2C_EE_WriteBuffer((uint8_t*)(&ex2Set), SETUP_EX2_ADDR, sizeof(SETUP_EX2));
000ece  220c              MOVS     r2,#0xc
000ed0  2160              MOVS     r1,#0x60
000ed2  4668              MOV      r0,sp
000ed4  f7fffffe          BL       I2C_EE_WriteBuffer
;;;698    }
000ed8  bd0e              POP      {r1-r3,pc}
;;;699    /*
                          ENDP

                  e2p_reset_commucation PROC
;;;701    */
;;;702    static void e2p_reset_commucation(void)
000eda  b51c              PUSH     {r2-r4,lr}
;;;703    {
;;;704    	SETUP_COMMUCATION	comSet;
;;;705    	comSet.enable = 1;
000edc  2001              MOVS     r0,#1
000ede  f88d0006          STRB     r0,[sp,#6]
;;;706    	comSet.password = 000000;	//通讯密码
000ee2  2000              MOVS     r0,#0
000ee4  9000              STR      r0,[sp,#0]
;;;707    	comSet.port = 0;			//通讯接口
000ee6  f8ad0004          STRH     r0,[sp,#4]
;;;708    	comSet.type = 1;			//通讯协议  1.DTU通讯，2.dex
000eea  2001              MOVS     r0,#1
000eec  f88d0007          STRB     r0,[sp,#7]
;;;709    	I2C_EE_WriteBuffer((uint8_t*)(&comSet), SETUP_COMMUCATION_ADDR, sizeof(SETUP_COMMUCATION));
000ef0  2208              MOVS     r2,#8
000ef2  2170              MOVS     r1,#0x70
000ef4  4668              MOV      r0,sp
000ef6  f7fffffe          BL       I2C_EE_WriteBuffer
;;;710    }
000efa  bd1c              POP      {r2-r4,pc}
;;;711    /*
                          ENDP

                  e2p_reset_channel PROC
;;;715    uint32_t len;
;;;716     void e2p_reset_channel(void)
000efc  b57f              PUSH     {r0-r6,lr}
;;;717    {
;;;718    	uint8_t i,j;
;;;719    	for(j = 0;j <MAX_CONTAINER_SIZE; j++)//最多9个机柜
000efe  2500              MOVS     r5,#0
000f00  e041              B        |L1.3974|
                  |L1.3842|
;;;720    	{
;;;721    		for(i = 0; i < MAX_CHANNEL_SIZE; i++)//单机柜硬件最多支持最多80个货道
000f02  2400              MOVS     r4,#0
000f04  e03b              B        |L1.3966|
                  |L1.3846|
;;;722    		{
;;;723    			SETUP_CHANNEL	channelSet;
;;;724    			channelSet.price = 9000 + (j+1)*10 + i;
000f06  1c68              ADDS     r0,r5,#1
000f08  eb000080          ADD      r0,r0,r0,LSL #2
000f0c  f2423128          MOV      r1,#0x2328
000f10  eb010040          ADD      r0,r1,r0,LSL #1
000f14  4420              ADD      r0,r0,r4
000f16  9000              STR      r0,[sp,#0]
;;;725    			//价格备份就是价格的每字节校验和
;;;726    			channelSet.priceCHK = (channelSet.price & 0xff) + ((channelSet.price >>24) & 0xff) + ((channelSet.price >>16) & 0xff) + ((channelSet.price >>8 ) & 0xff);
000f18  9800              LDR      r0,[sp,#0]
000f1a  eb006010          ADD      r0,r0,r0,LSR #24
000f1e  9900              LDR      r1,[sp,#0]
000f20  eb004011          ADD      r0,r0,r1,LSR #16
000f24  eb002011          ADD      r0,r0,r1,LSR #8
000f28  b2c0              UXTB     r0,r0
000f2a  f88d000e          STRB     r0,[sp,#0xe]
;;;727    			channelSet.spring = 10;
000f2e  200a              MOVS     r0,#0xa
000f30  f8ad000c          STRH     r0,[sp,#0xc]
;;;728    			channelSet.store  = 10;
000f34  f8ad0008          STRH     r0,[sp,#8]
;;;729    			channelSet.storeBkp = 10;//库存备份
000f38  f8ad000a          STRH     r0,[sp,#0xa]
;;;730    			channelSet.type   = 1;//0:禁能；1:使能；2:联动
000f3c  2001              MOVS     r0,#1
000f3e  f88d000f          STRB     r0,[sp,#0xf]
;;;731    			channelSet.code   = 000000; 
000f42  2000              MOVS     r0,#0
000f44  9001              STR      r0,[sp,#4]
;;;732    			//每个货道占用1页，每页浪费2Byte
;;;733    			size = sizeof(SETUP_CHANNEL);
000f46  2010              MOVS     r0,#0x10
000f48  495a              LDR      r1,|L1.4276|
000f4a  6008              STR      r0,[r1,#0]  ; size
;;;734    			len = SETUP_CHANNEL_ADDR + i*EEPROM_PAGE_SIZE + j*EEPROM_PAGE_SIZE*MAX_CHANNEL_SIZE;
000f4c  2080              MOVS     r0,#0x80
000f4e  eb001004          ADD      r0,r0,r4,LSL #4
000f52  0129              LSLS     r1,r5,#4
000f54  eb010181          ADD      r1,r1,r1,LSL #2
000f58  eb001001          ADD      r0,r0,r1,LSL #4
000f5c  4956              LDR      r1,|L1.4280|
000f5e  6008              STR      r0,[r1,#0]  ; len
;;;735    			I2C_EE_WriteBuffer((uint8_t*)(&channelSet), ( SETUP_CHANNEL_ADDR + i*EEPROM_PAGE_SIZE + j*EEPROM_PAGE_SIZE*MAX_CHANNEL_SIZE) , sizeof(SETUP_CHANNEL));
000f60  2080              MOVS     r0,#0x80
000f62  eb001004          ADD      r0,r0,r4,LSL #4
000f66  012a              LSLS     r2,r5,#4
000f68  eb020282          ADD      r2,r2,r2,LSL #2
000f6c  eb001002          ADD      r0,r0,r2,LSL #4
000f70  b281              UXTH     r1,r0
000f72  2210              MOVS     r2,#0x10
000f74  4668              MOV      r0,sp
000f76  f7fffffe          BL       I2C_EE_WriteBuffer
000f7a  1c60              ADDS     r0,r4,#1              ;721
000f7c  b2c4              UXTB     r4,r0                 ;721
                  |L1.3966|
000f7e  2c50              CMP      r4,#0x50              ;721
000f80  dbc1              BLT      |L1.3846|
000f82  1c68              ADDS     r0,r5,#1              ;719
000f84  b2c5              UXTB     r5,r0                 ;719
                  |L1.3974|
000f86  2d09              CMP      r5,#9                 ;719
000f88  dbbb              BLT      |L1.3842|
;;;736    		}
;;;737    	}
;;;738    }
000f8a  bd7f              POP      {r0-r6,pc}
;;;739    
                          ENDP

                  e2p_reset_channelStatistic PROC
;;;745    */
;;;746    void e2p_reset_channelStatistic(void)
000f8c  b53e              PUSH     {r1-r5,lr}
;;;747    {
;;;748    	uint8_t i,j;
;;;749    	for(j = 0; j < MAX_CONTAINER_SIZE; j++)//最多9个机柜
000f8e  2500              MOVS     r5,#0
000f90  e01a              B        |L1.4040|
                  |L1.3986|
;;;750    	{
;;;751    		for(i = 0; i < MAX_CHANNEL_SIZE; i++)//单机柜硬件最多支持最多80个货道
000f92  2400              MOVS     r4,#0
000f94  e014              B        |L1.4032|
                  |L1.3990|
;;;752    		{
;;;753    			SETUP_COLUMN	statistic;
;;;754    			statistic.num = 0;
000f96  2000              MOVS     r0,#0
000f98  9000              STR      r0,[sp,#0]
;;;755    			statistic.val = 0;
000f9a  9001              STR      r0,[sp,#4]
;;;756    			statistic.state = 0;
000f9c  f88d0008          STRB     r0,[sp,#8]
;;;757    			I2C_EE_WriteBuffer((uint8_t*)(&statistic), ( SETUP_COLUMN_ADDR + i*EEPROM_PAGE_SIZE + j*EEPROM_PAGE_SIZE*MAX_CHANNEL_SIZE) , sizeof(SETUP_COLUMN));
000fa0  f44f5036          MOV      r0,#0x2d80
000fa4  eb001004          ADD      r0,r0,r4,LSL #4
000fa8  012a              LSLS     r2,r5,#4
000faa  eb020282          ADD      r2,r2,r2,LSL #2
000fae  eb001002          ADD      r0,r0,r2,LSL #4
000fb2  b281              UXTH     r1,r0
000fb4  220c              MOVS     r2,#0xc
000fb6  4668              MOV      r0,sp
000fb8  f7fffffe          BL       I2C_EE_WriteBuffer
000fbc  1c60              ADDS     r0,r4,#1              ;751
000fbe  b2c4              UXTB     r4,r0                 ;751
                  |L1.4032|
000fc0  2c50              CMP      r4,#0x50              ;751
000fc2  dbe8              BLT      |L1.3990|
000fc4  1c68              ADDS     r0,r5,#1              ;749
000fc6  b2c5              UXTB     r5,r0                 ;749
                  |L1.4040|
000fc8  2d09              CMP      r5,#9                 ;749
000fca  dbe2              BLT      |L1.3986|
;;;758    		}
;;;759    	}
;;;760    }
000fcc  bd3e              POP      {r1-r5,pc}
;;;761    
                          ENDP

                  e2p_reset_all PROC
;;;764    */
;;;765    void e2p_reset_all(void)
000fce  b510              PUSH     {r4,lr}
;;;766    {
;;;767    	e2p_reset_device();
000fd0  f7fffffe          BL       e2p_reset_device
;;;768    	e2p_reset_common();
000fd4  f7fffffe          BL       e2p_reset_common
;;;769    	e2p_reset_cashless();
000fd8  f7fffffe          BL       e2p_reset_cashless
;;;770    	e2p_reset_cash();
000fdc  f7fffffe          BL       e2p_reset_cash
;;;771    	e2p_reset_ex1();
000fe0  f7fffffe          BL       e2p_reset_ex1
;;;772    	e2p_reset_ex2();
000fe4  f7fffffe          BL       e2p_reset_ex2
;;;773    	e2p_reset_commucation();
000fe8  f7fffffe          BL       e2p_reset_commucation
;;;774    	e2p_reset_channel();
000fec  f7fffffe          BL       e2p_reset_channel
;;;775    	e2p_reset_channelStatistic();
000ff0  f7fffffe          BL       e2p_reset_channelStatistic
;;;776    	bkp_trayStatistic_reset();
000ff4  f7fffffe          BL       bkp_trayStatistic_reset
;;;777    	bkp_wholeStatistic_reset();
000ff8  f7fffffe          BL       bkp_wholeStatistic_reset
;;;778    }
000ffc  bd10              POP      {r4,pc}
;;;779    
                          ENDP

                  e2p_poweron_init PROC
;;;785    **************************************************************************************/
;;;786    void e2p_poweron_init(void)
000ffe  b538              PUSH     {r3-r5,lr}
;;;787    {
;;;788    	//先判断是否有效，就是那个标志位是否正确，不正确则恢复
;;;789    	SETUP_FLAG valid;
;;;790    	uint8_t i = 0;
001000  2400              MOVS     r4,#0
;;;791    	
;;;792    	do
001002  bf00              NOP      
                  |L1.4100|
;;;793    	{
;;;794    		I2C_EE_ReadBuffer( (uint8_t*)(&valid), SETUP_FLAG_ADDR, sizeof(SETUP_FLAG));//检查标志位
001004  2204              MOVS     r2,#4
001006  2100              MOVS     r1,#0
001008  4668              MOV      r0,sp
00100a  f7fffffe          BL       I2C_EE_ReadBuffer
;;;795    	}while(valid.validFlag != EEPROM_VALID && i++ < 5);
00100e  f8bd0000          LDRH     r0,[sp,#0]
001012  f64a21ab          MOV      r1,#0xaaab
001016  4288              CMP      r0,r1
001018  d004              BEQ      |L1.4132|
00101a  4620              MOV      r0,r4
00101c  1c61              ADDS     r1,r4,#1
00101e  b2cc              UXTB     r4,r1
001020  2805              CMP      r0,#5
001022  dbef              BLT      |L1.4100|
                  |L1.4132|
;;;796    	
;;;797    	
;;;798    	if(valid.validFlag != EEPROM_VALID)//如果有效
001024  f8bd0000          LDRH     r0,[sp,#0]
001028  f64a21ab          MOV      r1,#0xaaab
00102c  4288              CMP      r0,r1
00102e  d014              BEQ      |L1.4186|
;;;799    	{
;;;800    		e2p_reset_all();
001030  f7fffffe          BL       e2p_reset_all
;;;801    		valid.validFlag = EEPROM_VALID;
001034  f64a20ab          MOV      r0,#0xaaab
001038  f8ad0000          STRH     r0,[sp,#0]
;;;802    		I2C_EE_WriteBuffer((uint8_t*)(&valid), SETUP_FLAG_ADDR, sizeof(SETUP_FLAG));//重写标志位
00103c  2204              MOVS     r2,#4
00103e  2100              MOVS     r1,#0
001040  4668              MOV      r0,sp
001042  f7fffffe          BL       I2C_EE_WriteBuffer
;;;803    		lcd_show_character(&pt_word.warring[12]);
001046  491d              LDR      r1,|L1.4284|
001048  6989              LDR      r1,[r1,#0x18]  ; pt_word
00104a  f10100f0          ADD      r0,r1,#0xf0
00104e  f7fffffe          BL       lcd_show_character
;;;804    		OSTimeDly(OS_TICKS_PER_SEC*2);
001052  f44f60fa          MOV      r0,#0x7d0
001056  f7fffffe          BL       OSTimeDly
                  |L1.4186|
;;;805    	}
;;;806    }
00105a  bd38              POP      {r3-r5,pc}
;;;807    
                          ENDP

                  e2p_get_global PROC
;;;811    */
;;;812    void e2p_get_global(void)
00105c  b500              PUSH     {lr}
;;;813    {
00105e  b087              SUB      sp,sp,#0x1c
;;;814    	SETUP_COMMON common;
;;;815    	SETUP_CASHLESS cashless;
;;;816    	
;;;817    	e2p_get_common(&common); 
001060  a803              ADD      r0,sp,#0xc
001062  f7fffffe          BL       e2p_get_common
;;;818    	e2p_get_cashless(&cashless);
001066  a801              ADD      r0,sp,#4
001068  f7fffffe          BL       e2p_get_cashless
;;;819    	
;;;820        g_vm.language = common.language;		//语言
00106c  f89d0011          LDRB     r0,[sp,#0x11]
001070  4913              LDR      r1,|L1.4288|
001072  7088              STRB     r0,[r1,#2]
;;;821    	g_vm.maxContainerNum = common.drvnum;	//机柜数
001074  f89d0012          LDRB     r0,[sp,#0x12]
001078  7408              STRB     r0,[r1,#0x10]
;;;822    	g_vm.maxtrayNum = common.traynum;		//托盘数
00107a  f89d0013          LDRB     r0,[sp,#0x13]
00107e  73c8              STRB     r0,[r1,#0xf]
;;;823    	g_vm.point = common.point;				//小数位数
001080  f89d0010          LDRB     r0,[sp,#0x10]
001084  70c8              STRB     r0,[r1,#3]
;;;824    	g_vm.priceBit = common.numPrice;		//价格位数
001086  f89d0016          LDRB     r0,[sp,#0x16]
00108a  7108              STRB     r0,[r1,#4]
;;;825    	g_vm.storeBit = common.numStore;		//库存位数
00108c  f89d0015          LDRB     r0,[sp,#0x15]
001090  7188              STRB     r0,[r1,#6]
;;;826    	g_vm.channelBit = common.numChannel;	//货道位数
001092  f89d0017          LDRB     r0,[sp,#0x17]
001096  7148              STRB     r0,[r1,#5]
;;;827    	g_vm.goodsIdBit = common.numGoodsId;	//条码位数
001098  f89d0018          LDRB     r0,[sp,#0x18]
00109c  71c8              STRB     r0,[r1,#7]
;;;828    	g_vm.applyEnable = cashless.applyEnable;//二维码支付开关
00109e  f89d0008          LDRB     r0,[sp,#8]
0010a2  7348              STRB     r0,[r1,#0xd]
;;;829    	
;;;830    //	common.screenHorizontal//横屏
;;;831    	
;;;832    }
0010a4  b007              ADD      sp,sp,#0x1c
0010a6  bd00              POP      {pc}
;;;833    
                          ENDP

                  |L1.4264|
                          DCD      0x0133c705
                  |L1.4268|
                          DCD      0x3b9aca00
                  |L1.4272|
                          DCD      0x000f423f
                  |L1.4276|
                          DCD      size
                  |L1.4280|
                          DCD      len
                  |L1.4284|
                          DCD      pt_word
                  |L1.4288|
                          DCD      g_vm

                          AREA ||.data||, DATA, ALIGN=2

                  size
                          DCD      0x00000000
                  len
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "..\\USR\\SETUP\\setup.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___7_setup_c_ffb0064c____REV16|
#line 129 "C:\\Keil_v5\\ARM\\CMSIS\\Include\\core_cmInstr.h"
|__asm___7_setup_c_ffb0064c____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___7_setup_c_ffb0064c____REVSH|
#line 144
|__asm___7_setup_c_ffb0064c____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
