; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\output\bsp_ireader.o --asm_dir=.\Listing\ --list_dir=.\Listing\ --depend=.\output\bsp_ireader.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x -I..\bsp_lib -I..\UCOSII\port -I..\UCOSII\src -I..\UCOSII\uC-CPU -I..\Libraries\CMSIS -I..\User\INCLUDES -I..\LCD -I..\USR\Global -I..\USR -I..\USR\FSM -I..\USR\Commucation -I..\USR\Mdb -I..\USR\Drop -I..\USR\DriverBoard -I..\USR\Flash -I..\USR\Card -I..\USR\MSG -I..\USR\Bsp -I..\USR\SetPar -I..\User\QRCode -I..\USR\MEM -I..\USR\QRCode -I..\USR\SETUP -I..\USR\stm32 -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -IC:\Keil_v5\ARM\INC\ST\STM32F10x -D__MICROLIB -D__UVISION_VERSION=525 -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER --omf_browse=.\output\bsp_ireader.crf ..\USR\Bsp\bsp_ireader.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  icreader_recv_default PROC
;;;26     */
;;;27     void icreader_recv_default(uint8_t * dat, uint16_t len)
000000  4770              BX       lr
;;;28     {
;;;29     	//这里可以作为那种全双工通讯的通道
;;;30     }
;;;31     
                          ENDP

                  usart1_config PROC
;;;39     */
;;;40     static void usart1_config(void)
000002  b500              PUSH     {lr}
;;;41     {
000004  b087              SUB      sp,sp,#0x1c
;;;42     	GPIO_InitTypeDef GPIO_InitStructure;	
;;;43     	USART_InitTypeDef USART_InitStructure;	 
;;;44     	NVIC_InitTypeDef NVIC_InitStructure;	
;;;45     
;;;46     	//使能引脚时钟，与复用功能时钟
;;;47     	RCC_APB2PeriphClockCmd( RCC_APB2Periph_USART1 | RCC_APB2Periph_GPIOA  ,  ENABLE );
000006  2101              MOVS     r1,#1
000008  f2440004          MOV      r0,#0x4004
00000c  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;48     
;;;49     	//TX 引脚
;;;50     	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;			//PA9
000010  f44f7000          MOV      r0,#0x200
000014  f8ad0018          STRH     r0,[sp,#0x18]
;;;51     	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;		//复用的推挽输出
000018  2018              MOVS     r0,#0x18
00001a  f88d001b          STRB     r0,[sp,#0x1b]
;;;52     	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;		
00001e  2003              MOVS     r0,#3
000020  f88d001a          STRB     r0,[sp,#0x1a]
;;;53     	GPIO_Init(GPIOA, &GPIO_InitStructure);
000024  a906              ADD      r1,sp,#0x18
000026  48f5              LDR      r0,|L1.1020|
000028  f7fffffe          BL       GPIO_Init
;;;54         //RX 引脚
;;;55     	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;			//PA10
00002c  f44f6080          MOV      r0,#0x400
000030  f8ad0018          STRH     r0,[sp,#0x18]
;;;56     	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;//浮空输入
000034  2004              MOVS     r0,#4
000036  f88d001b          STRB     r0,[sp,#0x1b]
;;;57     	GPIO_Init(GPIOA, &GPIO_InitStructure);
00003a  a906              ADD      r1,sp,#0x18
00003c  48ef              LDR      r0,|L1.1020|
00003e  f7fffffe          BL       GPIO_Init
;;;58     	//串口配置
;;;59     	USART_InitStructure.USART_BaudRate            = 9600  ;				//波特率
000042  f44f5016          MOV      r0,#0x2580
000046  9002              STR      r0,[sp,#8]
;;;60     	USART_InitStructure.USART_WordLength          = USART_WordLength_8b;           	//8位数据
000048  2000              MOVS     r0,#0
00004a  f8ad000c          STRH     r0,[sp,#0xc]
;;;61     	USART_InitStructure.USART_StopBits            = USART_StopBits_1;              	//1个停止位
00004e  f8ad000e          STRH     r0,[sp,#0xe]
;;;62     	USART_InitStructure.USART_Parity              = USART_Parity_No ;              	//无奇偶检验
000052  f8ad0010          STRH     r0,[sp,#0x10]
;;;63     	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;	//禁用硬件流控制
000056  f8ad0014          STRH     r0,[sp,#0x14]
;;;64     	USART_InitStructure.USART_Mode                = USART_Mode_Rx | USART_Mode_Tx;  //使能发送接收
00005a  200c              MOVS     r0,#0xc
00005c  f8ad0012          STRH     r0,[sp,#0x12]
;;;65     	USART_Init(USART1, &USART_InitStructure);
000060  a902              ADD      r1,sp,#8
000062  48e7              LDR      r0,|L1.1024|
000064  f7fffffe          BL       USART_Init
;;;66     	
;;;67     	
;;;68     	//串口中断配置
;;;69     //	USART_ITConfig(USART1,USART_IT_RXNE, ENABLE);          	//使能接收中断
;;;70     	USART_ITConfig(USART1,USART_IT_ERR,ENABLE);				//使能错误中断
000068  2201              MOVS     r2,#1
00006a  2160              MOVS     r1,#0x60
00006c  48e4              LDR      r0,|L1.1024|
00006e  f7fffffe          BL       USART_ITConfig
;;;71     	USART_ITConfig(USART1,USART_IT_IDLE,ENABLE );			//使能空闲中断(只要这个就行)
000072  2201              MOVS     r2,#1
000074  f2404124          MOV      r1,#0x424
000078  48e1              LDR      r0,|L1.1024|
00007a  f7fffffe          BL       USART_ITConfig
;;;72     //	USART_ITConfig(USART1, USART_IT_TC, ENABLE);                                  
;;;73     //	USART_ClearITPendingBit(USART1, USART_IT_RXNE);
;;;74     
;;;75     
;;;76     	
;;;77     //	USART_ClearFlag(USART1,USART_FLAG_RXNE); 
;;;78     	USART_ClearFlag(USART1,USART_FLAG_TC); 				//清发送完标志
00007e  2140              MOVS     r1,#0x40
000080  48df              LDR      r0,|L1.1024|
000082  f7fffffe          BL       USART_ClearFlag
;;;79     
;;;80     	USART_Cmd(USART1, ENABLE);     	//使能uart1外设
000086  2101              MOVS     r1,#1
000088  48dd              LDR      r0,|L1.1024|
00008a  f7fffffe          BL       USART_Cmd
;;;81     	
;;;82     	//=============================
;;;83     	//中断使能，对应到中断向量表
;;;84     	//=============================
;;;85     	NVIC_InitStructure.NVIC_IRQChannel = USART1_IRQn; 		                       	//USART1接收中断
00008e  2025              MOVS     r0,#0x25
000090  f88d0004          STRB     r0,[sp,#4]
;;;86     	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;                       //先占优先级
000094  2000              MOVS     r0,#0
000096  f88d0005          STRB     r0,[sp,#5]
;;;87     	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;		                        //从优先级
00009a  f88d0006          STRB     r0,[sp,#6]
;;;88     	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;									//中断通道使能
00009e  2001              MOVS     r0,#1
0000a0  f88d0007          STRB     r0,[sp,#7]
;;;89     	NVIC_Init(&NVIC_InitStructure);
0000a4  a801              ADD      r0,sp,#4
0000a6  f7fffffe          BL       NVIC_Init
;;;90     }
0000aa  b007              ADD      sp,sp,#0x1c
0000ac  bd00              POP      {pc}
;;;91     
                          ENDP

                  uart1_dmaRecv_config PROC
;;;95     */
;;;96     static void uart1_dmaRecv_config(void)
0000ae  b500              PUSH     {lr}
;;;97     {
0000b0  b08d              SUB      sp,sp,#0x34
;;;98     	DMA_InitTypeDef DMA_InitStructure;
;;;99     	NVIC_InitTypeDef NVIC_InitStructure;				
;;;100    	
;;;101    	RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA1, ENABLE);	//DMA1 时钟打开
0000b2  2101              MOVS     r1,#1
0000b4  4608              MOV      r0,r1
0000b6  f7fffffe          BL       RCC_AHBPeriphClockCmd
;;;102    	
;;;103    	
;;;104    	DMA_DeInit(DMA1_Channel4); 
0000ba  48d2              LDR      r0,|L1.1028|
0000bc  f7fffffe          BL       DMA_DeInit
;;;105    	DMA_InitStructure.DMA_PeripheralBaseAddr = (uint32_t)(&USART1->DR);		//dr寄存器的地址· (0x40013804)
0000c0  48cf              LDR      r0,|L1.1024|
0000c2  1d00              ADDS     r0,r0,#4
0000c4  9002              STR      r0,[sp,#8]
;;;106    	DMA_InitStructure.DMA_MemoryBaseAddr = (uint32_t)icreader_recv_buf;				//接收缓冲的地址
0000c6  48d0              LDR      r0,|L1.1032|
0000c8  9003              STR      r0,[sp,#0xc]
;;;107    	DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralSRC;						//外设作为数据来源
0000ca  2000              MOVS     r0,#0
0000cc  9004              STR      r0,[sp,#0x10]
;;;108    	DMA_InitStructure.DMA_BufferSize = RX_LEN;
0000ce  2064              MOVS     r0,#0x64
0000d0  9005              STR      r0,[sp,#0x14]
;;;109    	DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;	//dma 不自增
0000d2  2000              MOVS     r0,#0
0000d4  9006              STR      r0,[sp,#0x18]
;;;110    	DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;				//内存自增
0000d6  2080              MOVS     r0,#0x80
0000d8  9007              STR      r0,[sp,#0x1c]
;;;111    	DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_Byte;	//dma数据宽度（Byte宽）
0000da  2000              MOVS     r0,#0
0000dc  9008              STR      r0,[sp,#0x20]
;;;112    	DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_Byte;			//内存数据宽度
0000de  9009              STR      r0,[sp,#0x24]
;;;113    	DMA_InitStructure.DMA_Mode = DMA_Mode_Normal;		//普通模式；非循环接收
0000e0  900a              STR      r0,[sp,#0x28]
;;;114    	DMA_InitStructure.DMA_Priority = DMA_Priority_High;	//DMA高优先级（DMA设备间的优先级）
0000e2  f44f5000          MOV      r0,#0x2000
0000e6  900b              STR      r0,[sp,#0x2c]
;;;115    	DMA_InitStructure.DMA_M2M = DMA_M2M_Disable;		//关闭内存到内存传输模式
0000e8  2000              MOVS     r0,#0
0000ea  900c              STR      r0,[sp,#0x30]
;;;116    	DMA_Init(DMA1_Channel5, &DMA_InitStructure);
0000ec  a902              ADD      r1,sp,#8
0000ee  48c5              LDR      r0,|L1.1028|
0000f0  3014              ADDS     r0,r0,#0x14
0000f2  f7fffffe          BL       DMA_Init
;;;117    	
;;;118    	DMA_ClearFlag(DMA1_FLAG_GL1);       // 清除DMA所有标志   
0000f6  2001              MOVS     r0,#1
0000f8  f7fffffe          BL       DMA_ClearFlag
;;;119    	
;;;120    	/*
;;;121    	注意，这里并没有开DMA接收中断
;;;122    	*/
;;;123    //	DMA_ITConfig(DMA1_Channel5, DMA_IT_TC, ENABLE);//传输完成中断
;;;124    //	DMA_ITConfig(DMA1_Channel5, DMA_IT_TE, ENABLE);//传输错误中断
;;;125    	
;;;126    	/* Enable USART1 DMA TX request */
;;;127    	USART_DMACmd(USART1, USART_DMAReq_Rx, ENABLE);	//使能串口1的DMA接收
0000fc  2201              MOVS     r2,#1
0000fe  2140              MOVS     r1,#0x40
000100  48bf              LDR      r0,|L1.1024|
000102  f7fffffe          BL       USART_DMACmd
;;;128    
;;;129    	DMA_Cmd(DMA1_Channel5, ENABLE);					//打开DMA1-5通道
000106  2101              MOVS     r1,#1
000108  48be              LDR      r0,|L1.1028|
00010a  3014              ADDS     r0,r0,#0x14
00010c  f7fffffe          BL       DMA_Cmd
;;;130    		
;;;131    	//=============================
;;;132    	//DMA中断设置
;;;133    	//=============================
;;;134    	NVIC_InitStructure.NVIC_IRQChannel = DMA1_Channel5_IRQn; 		                //中断通道
000110  200f              MOVS     r0,#0xf
000112  f88d0004          STRB     r0,[sp,#4]
;;;135    	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1;                       //抢占优先级
000116  2001              MOVS     r0,#1
000118  f88d0005          STRB     r0,[sp,#5]
;;;136    	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;		                        //从优先级
00011c  2000              MOVS     r0,#0
00011e  f88d0006          STRB     r0,[sp,#6]
;;;137    	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;									//中断使能
000122  2001              MOVS     r0,#1
000124  f88d0007          STRB     r0,[sp,#7]
;;;138    	NVIC_Init(&NVIC_InitStructure);
000128  a801              ADD      r0,sp,#4
00012a  f7fffffe          BL       NVIC_Init
;;;139    
;;;140    }
00012e  b00d              ADD      sp,sp,#0x34
000130  bd00              POP      {pc}
;;;141    
                          ENDP

                  uart1_dmaSend_config PROC
;;;145    */
;;;146    void uart1_dmaSend_config(void)
000132  b500              PUSH     {lr}
;;;147    {
000134  b08d              SUB      sp,sp,#0x34
;;;148    	DMA_InitTypeDef DMA_InitStructure;
;;;149    	NVIC_InitTypeDef NVIC_InitStructure;				
;;;150    	
;;;151    	RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA1, ENABLE);	//DMA1 时钟打开
000136  2101              MOVS     r1,#1
000138  4608              MOV      r0,r1
00013a  f7fffffe          BL       RCC_AHBPeriphClockCmd
;;;152    
;;;153    	DMA_DeInit(DMA1_Channel4); 
00013e  48b1              LDR      r0,|L1.1028|
000140  f7fffffe          BL       DMA_DeInit
;;;154    	DMA_InitStructure.DMA_PeripheralBaseAddr = (uint32_t)(&USART1->DR);
000144  48ae              LDR      r0,|L1.1024|
000146  1d00              ADDS     r0,r0,#4
000148  9002              STR      r0,[sp,#8]
;;;155    	DMA_InitStructure.DMA_MemoryBaseAddr = (uint32_t)icreader_send_buf;
00014a  48b0              LDR      r0,|L1.1036|
00014c  9003              STR      r0,[sp,#0xc]
;;;156    	DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralDST;				//外设作为数据目的地
00014e  2010              MOVS     r0,#0x10
000150  9004              STR      r0,[sp,#0x10]
;;;157    	DMA_InitStructure.DMA_BufferSize = TX_LEN;							//DMA缓存大小
000152  2064              MOVS     r0,#0x64
000154  9005              STR      r0,[sp,#0x14]
;;;158    	DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;//DMA外设地址不自增
000156  2000              MOVS     r0,#0
000158  9006              STR      r0,[sp,#0x18]
;;;159    	DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;			//DMA内存地址自增
00015a  2080              MOVS     r0,#0x80
00015c  9007              STR      r0,[sp,#0x1c]
;;;160    	DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_Byte;//8bit 数据宽度，dma
00015e  2000              MOVS     r0,#0
000160  9008              STR      r0,[sp,#0x20]
;;;161    	DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_Byte;	//8bit 数据宽度，内存
000162  9009              STR      r0,[sp,#0x24]
;;;162    	DMA_InitStructure.DMA_Mode = DMA_Mode_Normal;					//发完一次就停
000164  900a              STR      r0,[sp,#0x28]
;;;163    	DMA_InitStructure.DMA_Priority = DMA_Priority_High;				//高优先级
000166  f44f5000          MOV      r0,#0x2000
00016a  900b              STR      r0,[sp,#0x2c]
;;;164    	DMA_InitStructure.DMA_M2M = DMA_M2M_Disable;					//进制内存到内存
00016c  2000              MOVS     r0,#0
00016e  900c              STR      r0,[sp,#0x30]
;;;165    	
;;;166    	DMA_Init(DMA1_Channel4, &DMA_InitStructure);					//配置寄存器
000170  a902              ADD      r1,sp,#8
000172  48a4              LDR      r0,|L1.1028|
000174  f7fffffe          BL       DMA_Init
;;;167    	
;;;168    		DMA_ClearFlag(DMA1_FLAG_GL4);       // 清除DMA所有标志   
000178  f44f5080          MOV      r0,#0x1000
00017c  f7fffffe          BL       DMA_ClearFlag
;;;169    
;;;170    	
;;;171    	DMA_ITConfig(DMA1_Channel4, DMA_IT_TC, ENABLE);					//发送完中断
000180  2201              MOVS     r2,#1
000182  2102              MOVS     r1,#2
000184  489f              LDR      r0,|L1.1028|
000186  f7fffffe          BL       DMA_ITConfig
;;;172    	DMA_ITConfig(DMA1_Channel4, DMA_IT_TE, ENABLE);					//传输错误中断
00018a  2201              MOVS     r2,#1
00018c  2108              MOVS     r1,#8
00018e  489d              LDR      r0,|L1.1028|
000190  f7fffffe          BL       DMA_ITConfig
;;;173    	
;;;174    	/* Enable USART1 DMA TX request */
;;;175    	USART_DMACmd(USART1, USART_DMAReq_Tx, ENABLE);
000194  2201              MOVS     r2,#1
000196  2180              MOVS     r1,#0x80
000198  4899              LDR      r0,|L1.1024|
00019a  f7fffffe          BL       USART_DMACmd
;;;176    	DMA_Cmd(DMA1_Channel4, DISABLE);				//关闭DMA1-4通道
00019e  2100              MOVS     r1,#0
0001a0  4898              LDR      r0,|L1.1028|
0001a2  f7fffffe          BL       DMA_Cmd
;;;177    	
;;;178    	//=============================
;;;179    	//DMA中断设置
;;;180    	//=============================
;;;181    	NVIC_InitStructure.NVIC_IRQChannel = DMA1_Channel4_IRQn; 		                //中断通道
0001a6  200e              MOVS     r0,#0xe
0001a8  f88d0004          STRB     r0,[sp,#4]
;;;182    	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1;                       //抢占优先级
0001ac  2001              MOVS     r0,#1
0001ae  f88d0005          STRB     r0,[sp,#5]
;;;183    	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;		                        //从优先级
0001b2  2000              MOVS     r0,#0
0001b4  f88d0006          STRB     r0,[sp,#6]
;;;184    	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;									//中断使能
0001b8  2001              MOVS     r0,#1
0001ba  f88d0007          STRB     r0,[sp,#7]
;;;185    	NVIC_Init(&NVIC_InitStructure);
0001be  a801              ADD      r0,sp,#4
0001c0  f7fffffe          BL       NVIC_Init
;;;186    
;;;187    }
0001c4  b00d              ADD      sp,sp,#0x34
0001c6  bd00              POP      {pc}
;;;188    
                          ENDP

                  DMA1_Channel5_IRQHandler PROC
;;;194    static uint8_t DMA_fl = 0;
;;;195    void DMA1_Channel5_IRQHandler(void)
0001c8  b510              PUSH     {r4,lr}
;;;196    {
;;;197    	DMA_fl = !DMA_fl;
0001ca  4891              LDR      r0,|L1.1040|
0001cc  7800              LDRB     r0,[r0,#0]  ; DMA_fl
0001ce  b908              CBNZ     r0,|L1.468|
0001d0  2001              MOVS     r0,#1
0001d2  e000              B        |L1.470|
                  |L1.468|
0001d4  2000              MOVS     r0,#0
                  |L1.470|
0001d6  498e              LDR      r1,|L1.1040|
0001d8  7008              STRB     r0,[r1,#0]
;;;198    	if(DMA_GetITStatus(DMA1_IT_TC5) == SET)    
0001da  f44f3000          MOV      r0,#0x20000
0001de  f7fffffe          BL       DMA_GetITStatus
0001e2  2801              CMP      r0,#1
0001e4  d102              BNE      |L1.492|
;;;199    	{
;;;200    		DMA_ClearITPendingBit(DMA1_IT_TC5);
0001e6  0440              LSLS     r0,r0,#17
0001e8  f7fffffe          BL       DMA_ClearITPendingBit
                  |L1.492|
;;;201    	}
;;;202    	if(DMA_GetITStatus(DMA1_IT_TE5) == SET)
0001ec  f44f2000          MOV      r0,#0x80000
0001f0  f7fffffe          BL       DMA_GetITStatus
0001f4  2801              CMP      r0,#1
0001f6  d102              BNE      |L1.510|
;;;203    	{
;;;204    		DMA_ClearITPendingBit(DMA1_IT_TE5);
0001f8  04c0              LSLS     r0,r0,#19
0001fa  f7fffffe          BL       DMA_ClearITPendingBit
                  |L1.510|
;;;205    	}
;;;206    	DMA_ClearITPendingBit(DMA1_IT_TC5);
0001fe  f44f3000          MOV      r0,#0x20000
000202  f7fffffe          BL       DMA_ClearITPendingBit
;;;207    	DMA_ClearITPendingBit(DMA1_IT_TE5);
000206  f44f2000          MOV      r0,#0x80000
00020a  f7fffffe          BL       DMA_ClearITPendingBit
;;;208    	DMA_Cmd(DMA1_Channel5, DISABLE);//关DMA防止处理时有数据过来
00020e  2100              MOVS     r1,#0
000210  487c              LDR      r0,|L1.1028|
000212  3014              ADDS     r0,r0,#0x14
000214  f7fffffe          BL       DMA_Cmd
;;;209    	DMA1_Channel5->CNDTR = 100;//重装填
000218  2064              MOVS     r0,#0x64
00021a  497a              LDR      r1,|L1.1028|
00021c  3944              SUBS     r1,r1,#0x44
00021e  65c8              STR      r0,[r1,#0x5c]
;;;210    	DMA_Cmd(DMA1_Channel5, ENABLE);//数据处理完，重开DMA
000220  2101              MOVS     r1,#1
000222  4878              LDR      r0,|L1.1028|
000224  3014              ADDS     r0,r0,#0x14
000226  f7fffffe          BL       DMA_Cmd
;;;211    }
00022a  bd10              POP      {r4,pc}
;;;212    
                          ENDP

                  DMA1_Channel4_IRQHandler PROC
;;;217    */
;;;218    void DMA1_Channel4_IRQHandler(void)
00022c  b510              PUSH     {r4,lr}
;;;219    {
;;;220    //	DMA_fl = !DMA_fl;
;;;221    	if(DMA_GetITStatus(DMA1_IT_TC4) == SET)    
00022e  f44f5000          MOV      r0,#0x2000
000232  f7fffffe          BL       DMA_GetITStatus
000236  2801              CMP      r0,#1
000238  d102              BNE      |L1.576|
;;;222    	{
;;;223    		DMA_ClearITPendingBit(DMA1_IT_TC4);
00023a  0340              LSLS     r0,r0,#13
00023c  f7fffffe          BL       DMA_ClearITPendingBit
                  |L1.576|
;;;224    	}
;;;225    	if(DMA_GetITStatus(DMA1_IT_TE4) == SET)
000240  f44f4000          MOV      r0,#0x8000
000244  f7fffffe          BL       DMA_GetITStatus
000248  2801              CMP      r0,#1
00024a  d102              BNE      |L1.594|
;;;226    	{
;;;227    		DMA_ClearITPendingBit(DMA1_IT_TE4);
00024c  03c0              LSLS     r0,r0,#15
00024e  f7fffffe          BL       DMA_ClearITPendingBit
                  |L1.594|
;;;228    	}
;;;229    	DMA_ClearITPendingBit(DMA1_IT_TC4);
000252  f44f5000          MOV      r0,#0x2000
000256  f7fffffe          BL       DMA_ClearITPendingBit
;;;230    	DMA_ClearITPendingBit(DMA1_IT_TE4);
00025a  f44f4000          MOV      r0,#0x8000
00025e  f7fffffe          BL       DMA_ClearITPendingBit
;;;231    	DMA_Cmd(DMA1_Channel4, DISABLE);//关dma
000262  2100              MOVS     r1,#0
000264  4867              LDR      r0,|L1.1028|
000266  f7fffffe          BL       DMA_Cmd
;;;232    	
;;;233    	DMA_Cmd(DMA1_Channel5, DISABLE);	//打开接收DMA
00026a  2100              MOVS     r1,#0
00026c  4865              LDR      r0,|L1.1028|
00026e  3014              ADDS     r0,r0,#0x14
000270  f7fffffe          BL       DMA_Cmd
;;;234    	DMA1_Channel5->CNDTR = TX_LEN;//重设置接收缓冲长度
000274  2064              MOVS     r0,#0x64
000276  4963              LDR      r1,|L1.1028|
000278  3944              SUBS     r1,r1,#0x44
00027a  65c8              STR      r0,[r1,#0x5c]
;;;235    	DMA_Cmd(DMA1_Channel5, ENABLE);	//打开接收DMA
00027c  2101              MOVS     r1,#1
00027e  4861              LDR      r0,|L1.1028|
000280  3014              ADDS     r0,r0,#0x14
000282  f7fffffe          BL       DMA_Cmd
;;;236    
;;;237    }
000286  bd10              POP      {r4,pc}
;;;238    
                          ENDP

                  USART1_IRQHandler PROC
;;;246    */
;;;247    void USART1_IRQHandler(void)
000288  b510              PUSH     {r4,lr}
;;;248    {
;;;249    	uint32_t  sr;
;;;250    	sr = sr;//防止编译器报错
00028a  bf00              NOP      
;;;251    	//sr = USART1->SR;
;;;252    	if(USART_GetITStatus(USART1, USART_IT_TXE) != RESET)//发送空
00028c  f2407127          MOV      r1,#0x727
000290  485b              LDR      r0,|L1.1024|
000292  f7fffffe          BL       USART_GetITStatus
000296  b120              CBZ      r0,|L1.674|
;;;253    	{
;;;254    		USART_ClearITPendingBit(USART1, USART_IT_TXE);
000298  f2407127          MOV      r1,#0x727
00029c  4858              LDR      r0,|L1.1024|
00029e  f7fffffe          BL       USART_ClearITPendingBit
                  |L1.674|
;;;255    	}
;;;256    	
;;;257    	if(USART_GetITStatus(USART1, USART_IT_TC) != RESET)//发送完成
0002a2  f2406126          MOV      r1,#0x626
0002a6  4856              LDR      r0,|L1.1024|
0002a8  f7fffffe          BL       USART_GetITStatus
0002ac  b150              CBZ      r0,|L1.708|
;;;258    	{
;;;259    		USART_ClearITPendingBit(USART1, USART_IT_TC);
0002ae  f2406126          MOV      r1,#0x626
0002b2  4853              LDR      r0,|L1.1024|
0002b4  f7fffffe          BL       USART_ClearITPendingBit
;;;260    		USART_ITConfig(USART1, USART_IT_TC, DISABLE);                                  
0002b8  2200              MOVS     r2,#0
0002ba  f2406126          MOV      r1,#0x626
0002be  4850              LDR      r0,|L1.1024|
0002c0  f7fffffe          BL       USART_ITConfig
                  |L1.708|
;;;261    	}
;;;262    	
;;;263    	if(USART_GetITStatus(USART1, USART_IT_RXNE) != RESET)//收到数据
0002c4  f2405125          MOV      r1,#0x525
0002c8  484d              LDR      r0,|L1.1024|
0002ca  f7fffffe          BL       USART_GetITStatus
0002ce  b120              CBZ      r0,|L1.730|
;;;264    	{	 	
;;;265    		USART_ClearITPendingBit(USART1, USART_IT_RXNE);//清除接收中断标志
0002d0  f2405125          MOV      r1,#0x525
0002d4  484a              LDR      r0,|L1.1024|
0002d6  f7fffffe          BL       USART_ClearITPendingBit
                  |L1.730|
;;;266    //		rx_len %= 100;
;;;267    //		rx_buffer[rx_len++]=USART_ReceiveData(USART1);//¶ÁÈ¡½ÓÊÕµ½µÄÊý¾ÝUSART1->DR,×Ô¶¯Çå³ý±êÖ¾Î»
;;;268    	}
;;;269    	
;;;270    	if(USART_GetITStatus(USART1, USART_IT_ORE) != RESET)//溢出错误
0002da  f44f7158          MOV      r1,#0x360
0002de  4848              LDR      r0,|L1.1024|
0002e0  f7fffffe          BL       USART_GetITStatus
0002e4  b140              CBZ      r0,|L1.760|
;;;271    	{//RDR 中有数据未读，但是移位寄存器有数据需要发送到RDR中
;;;272    		sr = USART_ReceiveData(USART1);
0002e6  4846              LDR      r0,|L1.1024|
0002e8  f7fffffe          BL       USART_ReceiveData
0002ec  4604              MOV      r4,r0
;;;273    		USART_ClearITPendingBit(USART1, USART_IT_ORE);//请溢出错误标志
0002ee  f44f7158          MOV      r1,#0x360
0002f2  4843              LDR      r0,|L1.1024|
0002f4  f7fffffe          BL       USART_ClearITPendingBit
                  |L1.760|
;;;274    	}
;;;275    	
;;;276    	if(USART_GetITStatus(USART1, USART_IT_IDLE) != RESET)//空闲
0002f8  f2404124          MOV      r1,#0x424
0002fc  4840              LDR      r0,|L1.1024|
0002fe  f7fffffe          BL       USART_GetITStatus
000302  b1f0              CBZ      r0,|L1.834|
;;;277    	{
;;;278    		DMA_fl = 3;
000304  2003              MOVS     r0,#3
000306  4942              LDR      r1,|L1.1040|
000308  7008              STRB     r0,[r1,#0]
;;;279    		sr = USART_ReceiveData(USART1);
00030a  483d              LDR      r0,|L1.1024|
00030c  f7fffffe          BL       USART_ReceiveData
000310  4604              MOV      r4,r0
;;;280    		DMA_Cmd(DMA1_Channel5, DISABLE);//关闭DMA，防止处理时有数据过来
000312  2100              MOVS     r1,#0
000314  483b              LDR      r0,|L1.1028|
000316  3014              ADDS     r0,r0,#0x14
000318  f7fffffe          BL       DMA_Cmd
;;;281    		USART_ClearITPendingBit(USART3, USART_IT_IDLE );
00031c  f2404124          MOV      r1,#0x424
000320  483c              LDR      r0,|L1.1044|
000322  f7fffffe          BL       USART_ClearITPendingBit
;;;282    		//获取DMA接收数据长度
;;;283    		icreader_rx_len = RX_LEN - DMA_GetCurrDataCounter(DMA1_Channel5);//这个和手上的中文手册不同 
000326  4837              LDR      r0,|L1.1028|
000328  3014              ADDS     r0,r0,#0x14
00032a  f7fffffe          BL       DMA_GetCurrDataCounter
00032e  f1c00064          RSB      r0,r0,#0x64
000332  4939              LDR      r1,|L1.1048|
000334  8008              STRH     r0,[r1,#0]
;;;284    		icreader_recv_dealwith(icreader_recv_buf, icreader_rx_len);//回调函数
000336  4608              MOV      r0,r1
000338  8801              LDRH     r1,[r0,#0]  ; icreader_rx_len
00033a  4833              LDR      r0,|L1.1032|
00033c  4a37              LDR      r2,|L1.1052|
00033e  6812              LDR      r2,[r2,#0]  ; icreader_recv_dealwith
000340  4790              BLX      r2
                  |L1.834|
;;;285    //		if(icreader_rx_len > 10)
;;;286    //		{
;;;287    //			uint8_t i;
;;;288    //			OSSemPost(semUart1Recv);
;;;289    //			//处理数据
;;;290    //			DMA_Cmd(DMA1_Channel5, DISABLE);//
;;;291    //			DMA1_Channel5->CNDTR = 100; // 设置要发送的字节数目
;;;292    //			DMA_Cmd(DMA1_Channel5, ENABLE);//打开DMA
;;;293    //			for(i = 0; i < 10 ;i++)
;;;294    //			cIC.PrintSnr[i] = icreader_recv_buf[i+1];
;;;295    //			icreader_rx_len = 0;
;;;296    //		}
;;;297    //		icreader_rx_len = 0;
;;;298    
;;;299    		
;;;300    //		icreader_recv_dealwith(icreader_recv_buf, icreader_rx_len);
;;;301    //		icreader_recv_dealwith = icreader_recv_default;
;;;302    		/*
;;;303    		刷新dma（从dma缓冲区起始处重新收数据，需要先关dma，再设置缓冲区长度，再开dma）
;;;304    		DMA 接收中断需要等dma缓冲满或过半才会触发
;;;305    		*/
;;;306    //		DMA1_Channel5->CNDTR = 100;//重设置接收缓冲长度
;;;307    //		DMA_Cmd(DMA1_Channel5, ENABLE);	//打开DMA
;;;308    	}
;;;309    
;;;310    	if(USART_GetITStatus(USART1 ,USART_IT_PE | USART_IT_FE | USART_IT_NE) != RESET)//其他错误
000342  f44f715a          MOV      r1,#0x368
000346  482e              LDR      r0,|L1.1024|
000348  f7fffffe          BL       USART_GetITStatus
00034c  b140              CBZ      r0,|L1.864|
;;;311    		{//没开对应的中断使能的话，是不会触发的
;;;312    		sr = USART_ReceiveData(USART1);
00034e  482c              LDR      r0,|L1.1024|
000350  f7fffffe          BL       USART_ReceiveData
000354  4604              MOV      r4,r0
;;;313    		USART_ClearITPendingBit(USART1, USART_IT_PE | USART_IT_FE | USART_IT_NE);
000356  f44f715a          MOV      r1,#0x368
00035a  4829              LDR      r0,|L1.1024|
00035c  f7fffffe          BL       USART_ClearITPendingBit
                  |L1.864|
;;;314    	}
;;;315    }
000360  bd10              POP      {r4,pc}
;;;316    
                          ENDP

                  lock_ireader_bus PROC
;;;319    */
;;;320    uint8_t lock_ireader_bus(void)
000362  b508              PUSH     {r3,lr}
;;;321    {
;;;322    	uint8_t err;
;;;323    	OSSemPend(semUart1Send, 0, &err);
000364  466a              MOV      r2,sp
000366  2100              MOVS     r1,#0
000368  482d              LDR      r0,|L1.1056|
00036a  6800              LDR      r0,[r0,#0]  ; semUart1Send
00036c  f7fffffe          BL       OSSemPend
;;;324    	return err;
000370  f89d0000          LDRB     r0,[sp,#0]
;;;325    }
000374  bd08              POP      {r3,pc}
;;;326    uint8_t unlock_ireader_bus(void)
                          ENDP

                  unlock_ireader_bus PROC
000376  b510              PUSH     {r4,lr}
;;;327    {
;;;328    	return OSSemPost(semUart1Send);
000378  4829              LDR      r0,|L1.1056|
00037a  6800              LDR      r0,[r0,#0]  ; semUart1Send
00037c  f7fffffe          BL       OSSemPost
;;;329    }
000380  bd10              POP      {r4,pc}
;;;330    /*
                          ENDP

                  wait_ireader_bus PROC
;;;332    */
;;;333    uint8_t wait_ireader_bus(void)
000382  b508              PUSH     {r3,lr}
;;;334    {
;;;335    	uint8_t err;
;;;336    	OSSemPend(semUart1Recv, 0, &err);
000384  466a              MOV      r2,sp
000386  2100              MOVS     r1,#0
000388  4826              LDR      r0,|L1.1060|
00038a  6800              LDR      r0,[r0,#0]  ; semUart1Recv
00038c  f7fffffe          BL       OSSemPend
;;;337    	return err;
000390  f89d0000          LDRB     r0,[sp,#0]
;;;338    }
000394  bd08              POP      {r3,pc}
;;;339    
                          ENDP

                  bsp_ireader_init PROC
;;;343    */
;;;344    void bsp_ireader_init(void)
000396  b510              PUSH     {r4,lr}
;;;345    {
;;;346    	usart1_config();
000398  f7fffffe          BL       usart1_config
;;;347    	uart1_dmaRecv_config();
00039c  f7fffffe          BL       uart1_dmaRecv_config
;;;348    	uart1_dmaSend_config();
0003a0  f7fffffe          BL       uart1_dmaSend_config
;;;349    	//创建信号量
;;;350    	semUart1Send = OSSemCreate(1);
0003a4  2001              MOVS     r0,#1
0003a6  f7fffffe          BL       OSSemCreate
0003aa  491d              LDR      r1,|L1.1056|
0003ac  6008              STR      r0,[r1,#0]  ; semUart1Send
;;;351    	semUart1Recv = OSSemCreate(0);
0003ae  2000              MOVS     r0,#0
0003b0  f7fffffe          BL       OSSemCreate
0003b4  491b              LDR      r1,|L1.1060|
0003b6  6008              STR      r0,[r1,#0]  ; semUart1Recv
;;;352    //	DMA_Cmd(DMA1_Channel4, ENABLE);
;;;353    	DMA_Cmd(DMA1_Channel5, ENABLE);
0003b8  2101              MOVS     r1,#1
0003ba  4812              LDR      r0,|L1.1028|
0003bc  3014              ADDS     r0,r0,#0x14
0003be  f7fffffe          BL       DMA_Cmd
;;;354    	icreader_recv_dealwith = icreader_recv_default;
0003c2  f2af30c3          ADR      r0,icreader_recv_default + 1
0003c6  4915              LDR      r1,|L1.1052|
0003c8  6008              STR      r0,[r1,#0]  ; icreader_recv_dealwith
;;;355    }
0003ca  bd10              POP      {r4,pc}
;;;356    
                          ENDP

                  cmd_icreader_send PROC
;;;360    */
;;;361    uint8_t* cmd_icreader_send(uint8_t *dat, uint16_t size, ICREADER_RECV_DEALWITH callback)  
0003cc  b570              PUSH     {r4-r6,lr}
;;;362    {
0003ce  4605              MOV      r5,r0
0003d0  460c              MOV      r4,r1
0003d2  4616              MOV      r6,r2
;;;363    	memcpy(icreader_send_buf, dat, size);//拷贝要发送的内容
0003d4  4622              MOV      r2,r4
0003d6  4629              MOV      r1,r5
0003d8  480c              LDR      r0,|L1.1036|
0003da  f7fffffe          BL       __aeabi_memcpy
;;;364    	icreader_recv_dealwith = callback;
0003de  480f              LDR      r0,|L1.1052|
0003e0  6006              STR      r6,[r0,#0]  ; icreader_recv_dealwith
;;;365    	icreader_rx_len = 0;
0003e2  2000              MOVS     r0,#0
0003e4  490c              LDR      r1,|L1.1048|
0003e6  8008              STRH     r0,[r1,#0]
;;;366    	
;;;367        DMA1_Channel4->CNDTR = size; // 设置要发送的字节数目
0003e8  4806              LDR      r0,|L1.1028|
0003ea  3844              SUBS     r0,r0,#0x44
0003ec  6484              STR      r4,[r0,#0x48]
;;;368        DMA_Cmd(DMA1_Channel4, ENABLE);//开始DMA发送
0003ee  2101              MOVS     r1,#1
0003f0  4804              LDR      r0,|L1.1028|
0003f2  f7fffffe          BL       DMA_Cmd
;;;369    	return icreader_recv_buf;
0003f6  4804              LDR      r0,|L1.1032|
;;;370    }
0003f8  bd70              POP      {r4-r6,pc}
;;;371    
                          ENDP

0003fa  0000              DCW      0x0000
                  |L1.1020|
                          DCD      0x40010800
                  |L1.1024|
                          DCD      0x40013800
                  |L1.1028|
                          DCD      0x40020044
                  |L1.1032|
                          DCD      icreader_recv_buf
                  |L1.1036|
                          DCD      icreader_send_buf
                  |L1.1040|
                          DCD      DMA_fl
                  |L1.1044|
                          DCD      0x40004800
                  |L1.1048|
                          DCD      icreader_rx_len
                  |L1.1052|
                          DCD      icreader_recv_dealwith
                  |L1.1056|
                          DCD      semUart1Send
                  |L1.1060|
                          DCD      semUart1Recv

                          AREA ||.bss||, DATA, NOINIT, ALIGN=0

                  icreader_recv_buf
                          %        100
                  icreader_send_buf
                          %        100

                          AREA ||.data||, DATA, ALIGN=2

                  icreader_rx_len
000000  00000000          DCB      0x00,0x00,0x00,0x00
                  semUart1Recv
                          DCD      0x00000000
                  semUart1Send
                          DCD      0x00000000
                  icreader_recv_dealwith
                          DCD      0x00000000
                  DMA_fl
000010  00                DCB      0x00

;*** Start embedded assembler ***

#line 1 "..\\USR\\Bsp\\bsp_ireader.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___13_bsp_ireader_c_f83db992____REV16|
#line 129 "C:\\Keil_v5\\ARM\\CMSIS\\Include\\core_cmInstr.h"
|__asm___13_bsp_ireader_c_f83db992____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___13_bsp_ireader_c_f83db992____REVSH|
#line 144
|__asm___13_bsp_ireader_c_f83db992____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
