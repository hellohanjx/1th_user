; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\output\mdb_driver.o --asm_dir=.\Listing\ --list_dir=.\Listing\ --depend=.\output\mdb_driver.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x -I..\bsp_lib -I..\UCOSII\port -I..\UCOSII\src -I..\UCOSII\uC-CPU -I..\Libraries\CMSIS -I..\User\INCLUDES -I..\LCD -I..\USR\Global -I..\USR -I..\USR\FSM -I..\USR\Commucation -I..\USR\Mdb -I..\USR\Drop -I..\USR\DriverBoard -I..\USR\Flash -I..\USR\Card -I..\USR\MSG -I..\USR\Bsp -I..\USR\SetPar -I..\User\QRCode -I..\USR\MEM -I..\USR\QRCode -I..\USR\SETUP -I..\USR\stm32 -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -IC:\Keil_v5\ARM\INC\ST\STM32F10x -D__MICROLIB -D__UVISION_VERSION=525 -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER --omf_browse=.\output\mdb_driver.crf ..\USR\Mdb\mdb_driver.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  uart4_config PROC
;;;21     */
;;;22     static void uart4_config(void)
000000  b500              PUSH     {lr}
;;;23     {
000002  b087              SUB      sp,sp,#0x1c
;;;24     	GPIO_InitTypeDef GPIO_InitStructure;
;;;25     	USART_InitTypeDef USART_InitStructure;
;;;26     	NVIC_InitTypeDef NVIC_InitStructure;
;;;27     	
;;;28     	//时钟初始化
;;;29     	RCC_APB2PeriphClockCmd( RCC_APB2Periph_GPIOC | RCC_APB2Periph_AFIO ,  ENABLE );
000004  2101              MOVS     r1,#1
000006  2011              MOVS     r0,#0x11
000008  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;30     	RCC_APB1PeriphClockCmd( RCC_APB1Periph_UART4 , ENABLE );
00000c  2101              MOVS     r1,#1
00000e  04c8              LSLS     r0,r1,#19
000010  f7fffffe          BL       RCC_APB1PeriphClockCmd
;;;31     	
;;;32     	//引脚初始化
;;;33     	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;				//TX 引脚
000014  f44f6080          MOV      r0,#0x400
000018  f8ad0018          STRH     r0,[sp,#0x18]
;;;34     	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;			//复用推挽输出
00001c  2018              MOVS     r0,#0x18
00001e  f88d001b          STRB     r0,[sp,#0x1b]
;;;35     	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
000022  2003              MOVS     r0,#3
000024  f88d001a          STRB     r0,[sp,#0x1a]
;;;36     	GPIO_Init(GPIOC, &GPIO_InitStructure);
000028  a906              ADD      r1,sp,#0x18
00002a  48fe              LDR      r0,|L1.1060|
00002c  f7fffffe          BL       GPIO_Init
;;;37     
;;;38     	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_11;				//RX引脚
000030  f44f6000          MOV      r0,#0x800
000034  f8ad0018          STRH     r0,[sp,#0x18]
;;;39     	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING ;	//浮空输入
000038  2004              MOVS     r0,#4
00003a  f88d001b          STRB     r0,[sp,#0x1b]
;;;40     	GPIO_Init(GPIOC, &GPIO_InitStructure);
00003e  a906              ADD      r1,sp,#0x18
000040  48f8              LDR      r0,|L1.1060|
000042  f7fffffe          BL       GPIO_Init
;;;41     	
;;;42     	USART_DeInit(UART4);	//寄存器恢复默认
000046  48f8              LDR      r0,|L1.1064|
000048  f7fffffe          BL       USART_DeInit
;;;43     	USART_InitStructure.USART_BaudRate            = 9600  ;							//9600波特率
00004c  f44f5016          MOV      r0,#0x2580
000050  9002              STR      r0,[sp,#8]
;;;44     	USART_InitStructure.USART_WordLength          = USART_WordLength_9b;           	//9个数据位
000052  f44f5080          MOV      r0,#0x1000
000056  f8ad000c          STRH     r0,[sp,#0xc]
;;;45     	USART_InitStructure.USART_StopBits            = USART_StopBits_1;              	//1个停止位
00005a  2000              MOVS     r0,#0
00005c  f8ad000e          STRH     r0,[sp,#0xe]
;;;46     	USART_InitStructure.USART_Parity              = USART_Parity_No ;              	//无奇偶校验
000060  f8ad0010          STRH     r0,[sp,#0x10]
;;;47     	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;	//禁用硬件流控
000064  f8ad0014          STRH     r0,[sp,#0x14]
;;;48     	USART_InitStructure.USART_Mode                = USART_Mode_Rx | USART_Mode_Tx;	//使能发送/接收
000068  200c              MOVS     r0,#0xc
00006a  f8ad0012          STRH     r0,[sp,#0x12]
;;;49     	USART_Init(UART4, &USART_InitStructure);
00006e  a902              ADD      r1,sp,#8
000070  48ed              LDR      r0,|L1.1064|
000072  f7fffffe          BL       USART_Init
;;;50     	
;;;51     	//清除标志位
;;;52     	USART_ClearFlag(UART4, USART_FLAG_TC);//清发送完标志
000076  2140              MOVS     r1,#0x40
000078  48eb              LDR      r0,|L1.1064|
00007a  f7fffffe          BL       USART_ClearFlag
;;;53     	USART_ClearFlag(UART4, USART_IT_IDLE);//清空闲标志
00007e  f2404124          MOV      r1,#0x424
000082  48e9              LDR      r0,|L1.1064|
000084  f7fffffe          BL       USART_ClearFlag
;;;54     	USART_ClearFlag(UART4, USART_IT_RXNE);//清接收标志
000088  f2405125          MOV      r1,#0x525
00008c  48e6              LDR      r0,|L1.1064|
00008e  f7fffffe          BL       USART_ClearFlag
;;;55     	
;;;56     	//关中断
;;;57     	USART_ITConfig(UART4,  USART_IT_TXE, DISABLE); 
000092  2200              MOVS     r2,#0
000094  f2407127          MOV      r1,#0x727
000098  48e3              LDR      r0,|L1.1064|
00009a  f7fffffe          BL       USART_ITConfig
;;;58     	USART_ITConfig(UART4,  USART_IT_TC, DISABLE);
00009e  2200              MOVS     r2,#0
0000a0  f2406126          MOV      r1,#0x626
0000a4  48e0              LDR      r0,|L1.1064|
0000a6  f7fffffe          BL       USART_ITConfig
;;;59     	USART_ITConfig(UART4,  USART_IT_RXNE, DISABLE);
0000aa  2200              MOVS     r2,#0
0000ac  f2405125          MOV      r1,#0x525
0000b0  48dd              LDR      r0,|L1.1064|
0000b2  f7fffffe          BL       USART_ITConfig
;;;60     	
;;;61     //	USART_ITConfig(UART4, USART_IT_RXNE, ENABLE );		//使能接收中断
;;;62     	USART_ITConfig(UART4, USART_IT_ERR,  ENABLE );		//使能错误中断
0000b6  2201              MOVS     r2,#1
0000b8  2160              MOVS     r1,#0x60
0000ba  48db              LDR      r0,|L1.1064|
0000bc  f7fffffe          BL       USART_ITConfig
;;;63     	USART_ITConfig(UART4, USART_IT_IDLE, ENABLE );		//使能空闲中断(接收数据后超过一个字节时间没收到数据则触发)
0000c0  2201              MOVS     r2,#1
0000c2  f2404124          MOV      r1,#0x424
0000c6  48d8              LDR      r0,|L1.1064|
0000c8  f7fffffe          BL       USART_ITConfig
;;;64     	//串口中断配置
;;;65     	NVIC_InitStructure.NVIC_IRQChannel = UART4_IRQn; 		    //UART4中断
0000cc  2034              MOVS     r0,#0x34
0000ce  f88d0004          STRB     r0,[sp,#4]
;;;66     	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1;   //先占优先级
0000d2  2001              MOVS     r0,#1
0000d4  f88d0005          STRB     r0,[sp,#5]
;;;67     	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;		    //次占优先级
0000d8  2000              MOVS     r0,#0
0000da  f88d0006          STRB     r0,[sp,#6]
;;;68     	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
0000de  2001              MOVS     r0,#1
0000e0  f88d0007          STRB     r0,[sp,#7]
;;;69     	NVIC_Init(&NVIC_InitStructure);
0000e4  a801              ADD      r0,sp,#4
0000e6  f7fffffe          BL       NVIC_Init
;;;70     	USART_Cmd(UART4, ENABLE);
0000ea  2101              MOVS     r1,#1
0000ec  48ce              LDR      r0,|L1.1064|
0000ee  f7fffffe          BL       USART_Cmd
;;;71     }
0000f2  b007              ADD      sp,sp,#0x1c
0000f4  bd00              POP      {pc}
;;;72     
                          ENDP

                  dma2_3_config PROC
;;;77     */
;;;78     static void dma2_3_config(void)
0000f6  b500              PUSH     {lr}
;;;79     {
0000f8  b08b              SUB      sp,sp,#0x2c
;;;80     	DMA_InitTypeDef DMA_InitStructure;
;;;81     //	NVIC_InitTypeDef NVIC_InitStructure;				
;;;82     	
;;;83     	RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA2, ENABLE);	//DMA2 时钟打开
0000fa  2101              MOVS     r1,#1
0000fc  2002              MOVS     r0,#2
0000fe  f7fffffe          BL       RCC_AHBPeriphClockCmd
;;;84     	
;;;85     	DMA_DeInit(DMA2_Channel3); 
000102  48ca              LDR      r0,|L1.1068|
000104  f7fffffe          BL       DMA_DeInit
;;;86     	DMA_InitStructure.DMA_PeripheralBaseAddr = (uint32_t)(&UART4->DR);		//dr寄存器的地址· (0x40013804)
000108  48c7              LDR      r0,|L1.1064|
00010a  1d00              ADDS     r0,r0,#4
00010c  9000              STR      r0,[sp,#0]
;;;87     	DMA_InitStructure.DMA_MemoryBaseAddr = (uint32_t)mdb_rx_buff;			//接收缓冲的地址
00010e  48c8              LDR      r0,|L1.1072|
000110  9001              STR      r0,[sp,#4]
;;;88     	DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralSRC;						//外设作为数据来源
000112  2000              MOVS     r0,#0
000114  9002              STR      r0,[sp,#8]
;;;89     	DMA_InitStructure.DMA_BufferSize = MDB_RX_LEN;							//多设几个长度，防止有错误脉冲过来
000116  2025              MOVS     r0,#0x25
000118  9003              STR      r0,[sp,#0xc]
;;;90     	DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;		//dma 不自增
00011a  2000              MOVS     r0,#0
00011c  9004              STR      r0,[sp,#0x10]
;;;91     	DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;					//内存自增
00011e  2080              MOVS     r0,#0x80
000120  9005              STR      r0,[sp,#0x14]
;;;92     	DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_HalfWord;	//dma数据宽度（半字 16bit）
000122  0040              LSLS     r0,r0,#1
000124  9006              STR      r0,[sp,#0x18]
;;;93     	DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_HalfWord;			//内存数据宽度
000126  0080              LSLS     r0,r0,#2
000128  9007              STR      r0,[sp,#0x1c]
;;;94     	DMA_InitStructure.DMA_Mode = DMA_Mode_Normal;		//普通模式；非循环接收
00012a  2000              MOVS     r0,#0
00012c  9008              STR      r0,[sp,#0x20]
;;;95     	DMA_InitStructure.DMA_Priority = DMA_Priority_High;	//DMA高优先级（DMA设备间的优先级）
00012e  f44f5000          MOV      r0,#0x2000
000132  9009              STR      r0,[sp,#0x24]
;;;96     	DMA_InitStructure.DMA_M2M = DMA_M2M_Disable;		//关闭内存到内存传输模式
000134  2000              MOVS     r0,#0
000136  900a              STR      r0,[sp,#0x28]
;;;97     	DMA_Init(DMA2_Channel3, &DMA_InitStructure);
000138  4669              MOV      r1,sp
00013a  48bc              LDR      r0,|L1.1068|
00013c  f7fffffe          BL       DMA_Init
;;;98     	
;;;99     	DMA_ClearFlag(DMA2_FLAG_GL1);       // 清除DMA所有标志   
000140  48bc              LDR      r0,|L1.1076|
000142  f7fffffe          BL       DMA_ClearFlag
;;;100    		
;;;101    	/*
;;;102    	注意，DMA2-3 并没有开启中断
;;;103    	*/
;;;104    	USART_DMACmd(UART4, USART_DMAReq_Rx, ENABLE);	//使能串口4的DMA接收
000146  2201              MOVS     r2,#1
000148  2140              MOVS     r1,#0x40
00014a  48b7              LDR      r0,|L1.1064|
00014c  f7fffffe          BL       USART_DMACmd
;;;105    	DMA_Cmd(DMA2_Channel3, DISABLE);				//关闭DMA2-3
000150  2100              MOVS     r1,#0
000152  48b6              LDR      r0,|L1.1068|
000154  f7fffffe          BL       DMA_Cmd
;;;106    		
;;;107    	//=============================
;;;108    	//DMA中断设置
;;;109    	//=============================
;;;110    //	NVIC_InitStructure.NVIC_IRQChannel = DMA2_Channel3_IRQn; 		                //中断通道
;;;111    //	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;                       //抢占优先级
;;;112    //	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 1;		                        //从优先级
;;;113    //	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;									//中断使能
;;;114    //	NVIC_Init(&NVIC_InitStructure);
;;;115    
;;;116    }
000158  b00b              ADD      sp,sp,#0x2c
00015a  bd00              POP      {pc}
;;;117    
                          ENDP

                  dma2_5_config PROC
;;;121    */
;;;122    static void dma2_5_config(void)
00015c  b500              PUSH     {lr}
;;;123    {
00015e  b08d              SUB      sp,sp,#0x34
;;;124    	DMA_InitTypeDef DMA_InitStructure;
;;;125    	NVIC_InitTypeDef NVIC_InitStructure;				
;;;126    	
;;;127    	RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA2, ENABLE);	//DMA2 时钟打开
000160  2101              MOVS     r1,#1
000162  2002              MOVS     r0,#2
000164  f7fffffe          BL       RCC_AHBPeriphClockCmd
;;;128    
;;;129    	DMA_DeInit(DMA2_Channel5); 
000168  48b0              LDR      r0,|L1.1068|
00016a  3028              ADDS     r0,r0,#0x28
00016c  f7fffffe          BL       DMA_DeInit
;;;130    	DMA_InitStructure.DMA_PeripheralBaseAddr = (uint32_t)(&UART4->DR);
000170  48ad              LDR      r0,|L1.1064|
000172  1d00              ADDS     r0,r0,#4
000174  9002              STR      r0,[sp,#8]
;;;131    	DMA_InitStructure.DMA_MemoryBaseAddr = (uint32_t)mdb_tx_buff;
000176  48b0              LDR      r0,|L1.1080|
000178  9003              STR      r0,[sp,#0xc]
;;;132    	DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralDST;				//外设作为数据目的地
00017a  2010              MOVS     r0,#0x10
00017c  9004              STR      r0,[sp,#0x10]
;;;133    	DMA_InitStructure.DMA_BufferSize = MDB_RX_LEN;					//DMA缓存大小,先设定一个，发的时候重设置
00017e  2025              MOVS     r0,#0x25
000180  9005              STR      r0,[sp,#0x14]
;;;134    	DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;//DMA外设地址不自增
000182  2000              MOVS     r0,#0
000184  9006              STR      r0,[sp,#0x18]
;;;135    	DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;			//DMA内存地址自增
000186  2080              MOVS     r0,#0x80
000188  9007              STR      r0,[sp,#0x1c]
;;;136    	DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_HalfWord;	//外设数据宽度，半字
00018a  0040              LSLS     r0,r0,#1
00018c  9008              STR      r0,[sp,#0x20]
;;;137    	DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_HalfWord;		//内存数据宽度，半字
00018e  0080              LSLS     r0,r0,#2
000190  9009              STR      r0,[sp,#0x24]
;;;138    	DMA_InitStructure.DMA_Mode = DMA_Mode_Normal;					//发完一次就停
000192  2000              MOVS     r0,#0
000194  900a              STR      r0,[sp,#0x28]
;;;139    	DMA_InitStructure.DMA_Priority = DMA_Priority_High;				//高优先级
000196  f44f5000          MOV      r0,#0x2000
00019a  900b              STR      r0,[sp,#0x2c]
;;;140    	DMA_InitStructure.DMA_M2M = DMA_M2M_Disable;					//进制内存到内存
00019c  2000              MOVS     r0,#0
00019e  900c              STR      r0,[sp,#0x30]
;;;141    	DMA_Init(DMA2_Channel5, &DMA_InitStructure);					//配置寄存器
0001a0  a902              ADD      r1,sp,#8
0001a2  48a2              LDR      r0,|L1.1068|
0001a4  3028              ADDS     r0,r0,#0x28
0001a6  f7fffffe          BL       DMA_Init
;;;142    	
;;;143    	DMA_ClearFlag(DMA2_FLAG_GL1);       // 清除DMA所有标志   
0001aa  48a2              LDR      r0,|L1.1076|
0001ac  f7fffffe          BL       DMA_ClearFlag
;;;144    
;;;145    	DMA_ITConfig(DMA2_Channel5, DMA_IT_TC, ENABLE);					//发送完中断
0001b0  2201              MOVS     r2,#1
0001b2  2102              MOVS     r1,#2
0001b4  489d              LDR      r0,|L1.1068|
0001b6  3028              ADDS     r0,r0,#0x28
0001b8  f7fffffe          BL       DMA_ITConfig
;;;146    	DMA_ITConfig(DMA2_Channel5, DMA_IT_TE, ENABLE);					//传输错误中断
0001bc  2201              MOVS     r2,#1
0001be  2108              MOVS     r1,#8
0001c0  489a              LDR      r0,|L1.1068|
0001c2  3028              ADDS     r0,r0,#0x28
0001c4  f7fffffe          BL       DMA_ITConfig
;;;147    	
;;;148    	USART_DMACmd(UART4, USART_DMAReq_Tx, ENABLE);	//使能串口DMA发送方式
0001c8  2201              MOVS     r2,#1
0001ca  2180              MOVS     r1,#0x80
0001cc  4896              LDR      r0,|L1.1064|
0001ce  f7fffffe          BL       USART_DMACmd
;;;149    	DMA_Cmd(DMA2_Channel5, DISABLE);				//关闭DMA2-5
0001d2  2100              MOVS     r1,#0
0001d4  4895              LDR      r0,|L1.1068|
0001d6  3028              ADDS     r0,r0,#0x28
0001d8  f7fffffe          BL       DMA_Cmd
;;;150    	
;;;151    	//=============================
;;;152    	//DMA中断设置
;;;153    	//=============================
;;;154    	NVIC_InitStructure.NVIC_IRQChannel = DMA2_Channel4_5_IRQn; 		                //中断通道
0001dc  203b              MOVS     r0,#0x3b
0001de  f88d0004          STRB     r0,[sp,#4]
;;;155    	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1;                       //抢占优先级
0001e2  2001              MOVS     r0,#1
0001e4  f88d0005          STRB     r0,[sp,#5]
;;;156    	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;		                        //从优先级
0001e8  2000              MOVS     r0,#0
0001ea  f88d0006          STRB     r0,[sp,#6]
;;;157    	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;									//中断使能
0001ee  2001              MOVS     r0,#1
0001f0  f88d0007          STRB     r0,[sp,#7]
;;;158    	NVIC_Init(&NVIC_InitStructure);
0001f4  a801              ADD      r0,sp,#4
0001f6  f7fffffe          BL       NVIC_Init
;;;159    
;;;160    }
0001fa  b00d              ADD      sp,sp,#0x34
0001fc  bd00              POP      {pc}
;;;161    
                          ENDP

                  DMA2_Channel3_IRQHandler PROC
;;;165    */
;;;166    void DMA2_Channel3_IRQHandler(void)
0001fe  b510              PUSH     {r4,lr}
;;;167    {
;;;168    	if(DMA_GetITStatus(DMA2_IT_TC3) == SET)    
000200  488e              LDR      r0,|L1.1084|
000202  f7fffffe          BL       DMA_GetITStatus
000206  2801              CMP      r0,#1
000208  d102              BNE      |L1.528|
;;;169    	{
;;;170    		DMA_ClearITPendingBit(DMA2_IT_TC3);
00020a  488c              LDR      r0,|L1.1084|
00020c  f7fffffe          BL       DMA_ClearITPendingBit
                  |L1.528|
;;;171    	}
;;;172    	if(DMA_GetITStatus(DMA2_IT_TE3) == SET)
000210  488b              LDR      r0,|L1.1088|
000212  f7fffffe          BL       DMA_GetITStatus
000216  2801              CMP      r0,#1
000218  d102              BNE      |L1.544|
;;;173    	{
;;;174    		DMA_ClearITPendingBit(DMA2_IT_TE3);
00021a  4889              LDR      r0,|L1.1088|
00021c  f7fffffe          BL       DMA_ClearITPendingBit
                  |L1.544|
;;;175    	}
;;;176    	DMA_ClearITPendingBit(DMA2_IT_TC3);
000220  4886              LDR      r0,|L1.1084|
000222  f7fffffe          BL       DMA_ClearITPendingBit
;;;177    	DMA_ClearITPendingBit(DMA2_IT_TE3);
000226  4886              LDR      r0,|L1.1088|
000228  f7fffffe          BL       DMA_ClearITPendingBit
;;;178    	DMA_Cmd(DMA2_Channel3, DISABLE);	//关DMA防止处理时有数据过来
00022c  2100              MOVS     r1,#0
00022e  487f              LDR      r0,|L1.1068|
000230  f7fffffe          BL       DMA_Cmd
;;;179    	DMA2_Channel3->CNDTR = MDB_RX_LEN;	//重装填
000234  2025              MOVS     r0,#0x25
000236  497d              LDR      r1,|L1.1068|
000238  1d09              ADDS     r1,r1,#4
00023a  6008              STR      r0,[r1,#0]
;;;180    	DMA_Cmd(DMA2_Channel3, ENABLE);		//数据处理完，重开DMA
00023c  2101              MOVS     r1,#1
00023e  487b              LDR      r0,|L1.1068|
000240  f7fffffe          BL       DMA_Cmd
;;;181    }
000244  bd10              POP      {r4,pc}
;;;182    
                          ENDP

                  DMA2_Channel4_5_IRQHandler PROC
;;;187    */
;;;188    void DMA2_Channel4_5_IRQHandler(void)
000246  b510              PUSH     {r4,lr}
;;;189    {
;;;190    	if(DMA_GetITStatus(DMA2_IT_TC5) == SET)    
000248  487e              LDR      r0,|L1.1092|
00024a  f7fffffe          BL       DMA_GetITStatus
00024e  2801              CMP      r0,#1
000250  d102              BNE      |L1.600|
;;;191    	{
;;;192    		DMA_ClearITPendingBit(DMA2_IT_TC5);
000252  487c              LDR      r0,|L1.1092|
000254  f7fffffe          BL       DMA_ClearITPendingBit
                  |L1.600|
;;;193    	}
;;;194    	if(DMA_GetITStatus(DMA2_IT_TE5) == SET)
000258  487b              LDR      r0,|L1.1096|
00025a  f7fffffe          BL       DMA_GetITStatus
00025e  2801              CMP      r0,#1
000260  d102              BNE      |L1.616|
;;;195    	{
;;;196    		DMA_ClearITPendingBit(DMA2_IT_TE5);
000262  4879              LDR      r0,|L1.1096|
000264  f7fffffe          BL       DMA_ClearITPendingBit
                  |L1.616|
;;;197    	}
;;;198    	DMA_ClearITPendingBit(DMA2_IT_TC5);
000268  4876              LDR      r0,|L1.1092|
00026a  f7fffffe          BL       DMA_ClearITPendingBit
;;;199    	DMA_ClearITPendingBit(DMA2_IT_TE5);
00026e  4876              LDR      r0,|L1.1096|
000270  f7fffffe          BL       DMA_ClearITPendingBit
;;;200    	DMA_Cmd(DMA2_Channel5, DISABLE);//关
000274  2100              MOVS     r1,#0
000276  486d              LDR      r0,|L1.1068|
000278  3028              ADDS     r0,r0,#0x28
00027a  f7fffffe          BL       DMA_Cmd
;;;201    //	
;;;202    	//dma2_3开始接收
;;;203    //	DMA2_Channel3->CNDTR = RX_LEN;//重设置接收缓冲长度
;;;204    //	DMA_Cmd(DMA2_Channel3, ENABLE);	//打开接收DMA
;;;205    
;;;206    }
00027e  bd10              POP      {r4,pc}
;;;207    
                          ENDP

                  send_ack PROC
;;;220    */
;;;221    static void send_ack(void)
000280  b510              PUSH     {r4,lr}
;;;222    {
;;;223    	mdb_tx_buff[0] = (ACK & 0xff);
000282  2000              MOVS     r0,#0
000284  496c              LDR      r1,|L1.1080|
000286  8008              STRH     r0,[r1,#0]
;;;224        DMA2_Channel5->CNDTR = 1; 		//设置要发送的字节数目
000288  2001              MOVS     r0,#1
00028a  4968              LDR      r1,|L1.1068|
00028c  312c              ADDS     r1,r1,#0x2c
00028e  6008              STR      r0,[r1,#0]
;;;225        DMA_Cmd(DMA2_Channel5, ENABLE);	//开始DMA发送
000290  2101              MOVS     r1,#1
000292  4866              LDR      r0,|L1.1068|
000294  3028              ADDS     r0,r0,#0x28
000296  f7fffffe          BL       DMA_Cmd
;;;226    	
;;;227    }
00029a  bd10              POP      {r4,pc}
;;;228    /*
                          ENDP

                  send_nak PROC
;;;234    
;;;235    static void send_nak(void)
00029c  b510              PUSH     {r4,lr}
;;;236    {
;;;237    	mdb_tx_buff[0] = (NAK & 0xff);
00029e  20ff              MOVS     r0,#0xff
0002a0  4965              LDR      r1,|L1.1080|
0002a2  8008              STRH     r0,[r1,#0]
;;;238        DMA2_Channel5->CNDTR = 1; 		//设置要发送的字节数目
0002a4  2001              MOVS     r0,#1
0002a6  4961              LDR      r1,|L1.1068|
0002a8  312c              ADDS     r1,r1,#0x2c
0002aa  6008              STR      r0,[r1,#0]
;;;239        DMA_Cmd(DMA2_Channel5, ENABLE);	//开始DMA发送
0002ac  2101              MOVS     r1,#1
0002ae  485f              LDR      r0,|L1.1068|
0002b0  3028              ADDS     r0,r0,#0x28
0002b2  f7fffffe          BL       DMA_Cmd
;;;240    }
0002b6  bd10              POP      {r4,pc}
;;;241    /*
                          ENDP

                  send_ret PROC
;;;247    
;;;248    static void send_ret(void)
0002b8  b510              PUSH     {r4,lr}
;;;249    {
;;;250    	mdb_tx_buff[0] = (RET & 0xff);
0002ba  20aa              MOVS     r0,#0xaa
0002bc  495e              LDR      r1,|L1.1080|
0002be  8008              STRH     r0,[r1,#0]
;;;251        DMA2_Channel5->CNDTR = 1; 		//设置要发送的字节数目
0002c0  2001              MOVS     r0,#1
0002c2  495a              LDR      r1,|L1.1068|
0002c4  312c              ADDS     r1,r1,#0x2c
0002c6  6008              STR      r0,[r1,#0]
;;;252        DMA_Cmd(DMA2_Channel5, ENABLE);	//开始DMA发送
0002c8  2101              MOVS     r1,#1
0002ca  4858              LDR      r0,|L1.1068|
0002cc  3028              ADDS     r0,r0,#0x28
0002ce  f7fffffe          BL       DMA_Cmd
;;;253    }
0002d2  bd10              POP      {r4,pc}
;;;254    
                          ENDP

                  mdb_rx_handle PROC
;;;260    */
;;;261    static uint8_t mdb_rx_handle(uint16_t timeout)
0002d4  b5f0              PUSH     {r4-r7,lr}
;;;262    {
0002d6  b087              SUB      sp,sp,#0x1c
0002d8  4607              MOV      r7,r0
;;;263    	uint8_t err = 0xff,i = 0, chk;
0002da  20ff              MOVS     r0,#0xff
0002dc  9006              STR      r0,[sp,#0x18]
0002de  2400              MOVS     r4,#0
;;;264    	/*
;;;265    	这样做超时可能会等待时间长些,但是简单易用
;;;266    	setup 指令耗时最长，最大200ms
;;;267    	*/
;;;268    	OSSemPend(sem_mdb_recvd, 220, &err);//等待接收数据,最多等200ms，每个字节最多5ms
0002e0  aa06              ADD      r2,sp,#0x18
0002e2  21dc              MOVS     r1,#0xdc
0002e4  4859              LDR      r0,|L1.1100|
0002e6  6800              LDR      r0,[r0,#0]  ; sem_mdb_recvd
0002e8  f7fffffe          BL       OSSemPend
;;;269    	//这里超时也要关闭接收
;;;270    	DMA_Cmd(DMA2_Channel3, DISABLE);	//关闭DMA接收
0002ec  2100              MOVS     r1,#0
0002ee  484f              LDR      r0,|L1.1068|
0002f0  f7fffffe          BL       DMA_Cmd
;;;271    	
;;;272    //	OSSemPend(sem_mdb_recvd, 20, &err);//第一个字节允许20ms
;;;273    //	recv = mdb_rx_len;
;;;274    //	while((err==OS_TIMEOUT && recv != 0) && i++<37)
;;;275    //	{
;;;276    //		OSSemPend(sem_mdb_recvd, 10, &err);
;;;277    //		recv = (mdb_rx_len - recv);
;;;278    //		if(err == OS_TIMEOUT && recv == 0)
;;;279    //			break;
;;;280    //	}
;;;281    	USART_ITConfig(UART4, USART_IT_RXNE, DISABLE );		//关接收中断
0002f4  2200              MOVS     r2,#0
0002f6  f2405125          MOV      r1,#0x525
0002fa  484b              LDR      r0,|L1.1064|
0002fc  f7fffffe          BL       USART_ITConfig
;;;282    	
;;;283    	
;;;284       if(err == OS_NO_ERR)
000300  f89d0018          LDRB     r0,[sp,#0x18]
000304  2800              CMP      r0,#0
000306  d15a              BNE      |L1.958|
;;;285       {
;;;286    		if(mdb_rx_len == 1)      //如果只收到一个字节数据检查是否是应答
000308  4851              LDR      r0,|L1.1104|
00030a  7800              LDRB     r0,[r0,#0]  ; mdb_rx_len
00030c  2801              CMP      r0,#1
00030e  d11b              BNE      |L1.840|
;;;287    		{
;;;288    			mdb_rx_buff[0] &= 0xff;
000310  4847              LDR      r0,|L1.1072|
000312  7800              LDRB     r0,[r0,#0]  ; mdb_rx_buff
000314  4946              LDR      r1,|L1.1072|
000316  8008              STRH     r0,[r1,#0]
;;;289    			
;;;290    			if(mdb_rx_buff[0] == ACK)
000318  4608              MOV      r0,r1
00031a  8800              LDRH     r0,[r0,#0]  ; mdb_rx_buff
00031c  b910              CBNZ     r0,|L1.804|
;;;291    			{
;;;292    				return MDB_RECEIVE_ACK;
00031e  2078              MOVS     r0,#0x78
                  |L1.800|
;;;293    			}
;;;294    			else
;;;295    			if(mdb_rx_buff[0] == NAK)
;;;296    			{
;;;297    				return MDB_RECEIVE_NAK;
;;;298    			}
;;;299    			else	
;;;300    			if(mdb_rx_buff[0] == DROP || (mdb_rx_buff[0]&0x01) == DROP )
;;;301    			{
;;;302    				return MDB_RECEIVE_DROP;
;;;303    			}
;;;304    		}
;;;305    		else//如果是多字节数据
;;;306    		{
;;;307    			mdb_rx_len--;  						//去除多出的位(就是指校验和)
;;;308    			for(i = 0, chk = 0; i < mdb_rx_len; i++)//计算接收数据校验和
;;;309    			{
;;;310    				chk += (mdb_rx_buff[i] & 0XFF);
;;;311    			}
;;;312       
;;;313    			if(chk == (mdb_rx_buff[mdb_rx_len] & 0xff))	//如果校验和正确
;;;314    			{
;;;315    				send_ack();	 //发送ACK应答
;;;316    				return MDB_RECEIVE_DATA;
;;;317    			}
;;;318    			else
;;;319    			{
;;;320    				lcd_show_num(test++, 0, 6, WHITE, BLUE, *(pt_word.choose[0].font), 0, 10); 
;;;321    				return ERR_CHECKSUM;
;;;322    			}
;;;323    		}
;;;324    	}
;;;325    	else//没收到数据
;;;326    	{
;;;327    		if(mdb_rx_len == 0)    //如果缓冲区内没有数据
;;;328    		{
;;;329    			return NO_RESPONSE;
;;;330    		}
;;;331    	}
;;;332    	return 0;
;;;333    }
000320  b007              ADD      sp,sp,#0x1c
000322  bdf0              POP      {r4-r7,pc}
                  |L1.804|
000324  4842              LDR      r0,|L1.1072|
000326  8800              LDRH     r0,[r0,#0]            ;295  ; mdb_rx_buff
000328  28ff              CMP      r0,#0xff              ;295
00032a  d101              BNE      |L1.816|
00032c  2077              MOVS     r0,#0x77              ;297
00032e  e7f7              B        |L1.800|
                  |L1.816|
000330  483f              LDR      r0,|L1.1072|
000332  8800              LDRH     r0,[r0,#0]            ;300  ; mdb_rx_buff
000334  2801              CMP      r0,#1                 ;300
000336  d005              BEQ      |L1.836|
000338  483d              LDR      r0,|L1.1072|
00033a  7800              LDRB     r0,[r0,#0]            ;300  ; mdb_rx_buff
00033c  f0000001          AND      r0,r0,#1              ;300
000340  2800              CMP      r0,#0                 ;300
000342  d041              BEQ      |L1.968|
                  |L1.836|
000344  2076              MOVS     r0,#0x76              ;302
000346  e7eb              B        |L1.800|
                  |L1.840|
000348  4841              LDR      r0,|L1.1104|
00034a  7800              LDRB     r0,[r0,#0]            ;307  ; mdb_rx_len
00034c  1e40              SUBS     r0,r0,#1              ;307
00034e  4940              LDR      r1,|L1.1104|
000350  7008              STRB     r0,[r1,#0]            ;307
000352  2400              MOVS     r4,#0                 ;308
000354  2500              MOVS     r5,#0                 ;308
000356  e006              B        |L1.870|
                  |L1.856|
000358  4835              LDR      r0,|L1.1072|
00035a  f8100014          LDRB     r0,[r0,r4,LSL #1]     ;310
00035e  4428              ADD      r0,r0,r5              ;310
000360  b2c5              UXTB     r5,r0                 ;310
000362  1c60              ADDS     r0,r4,#1              ;308
000364  b2c4              UXTB     r4,r0                 ;308
                  |L1.870|
000366  483a              LDR      r0,|L1.1104|
000368  7800              LDRB     r0,[r0,#0]            ;308  ; mdb_rx_len
00036a  4284              CMP      r4,r0                 ;308
00036c  dbf4              BLT      |L1.856|
00036e  4830              LDR      r0,|L1.1072|
000370  4937              LDR      r1,|L1.1104|
000372  7809              LDRB     r1,[r1,#0]            ;313  ; mdb_rx_len
000374  f8100011          LDRB     r0,[r0,r1,LSL #1]     ;313
000378  42a8              CMP      r0,r5                 ;313
00037a  d103              BNE      |L1.900|
00037c  f7fffffe          BL       send_ack
000380  2079              MOVS     r0,#0x79              ;316
000382  e7cd              B        |L1.800|
                  |L1.900|
000384  4833              LDR      r0,|L1.1108|
000386  6806              LDR      r6,[r0,#0]            ;320  ; test
000388  200a              MOVS     r0,#0xa               ;320
00038a  2100              MOVS     r1,#0                 ;320
00038c  e9cd1004          STRD     r1,r0,[sp,#0x10]      ;320
000390  4831              LDR      r0,|L1.1112|
000392  6880              LDR      r0,[r0,#8]            ;320  ; pt_word
000394  68c2              LDR      r2,[r0,#0xc]          ;320
000396  e9d21000          LDRD     r1,r0,[r2,#0]         ;320
00039a  6892              LDR      r2,[r2,#8]            ;320
00039c  e9cd0202          STRD     r0,r2,[sp,#8]         ;320
0003a0  9101              STR      r1,[sp,#4]            ;320
0003a2  201f              MOVS     r0,#0x1f              ;320
0003a4  1c71              ADDS     r1,r6,#1              ;320
0003a6  4a2b              LDR      r2,|L1.1108|
0003a8  9000              STR      r0,[sp,#0]            ;320
0003aa  6011              STR      r1,[r2,#0]            ;320  ; test
0003ac  4630              MOV      r0,r6                 ;320
0003ae  f64f73ff          MOV      r3,#0xffff            ;320
0003b2  2206              MOVS     r2,#6                 ;320
0003b4  2100              MOVS     r1,#0                 ;320
0003b6  f7fffffe          BL       lcd_show_num
0003ba  2083              MOVS     r0,#0x83              ;321
0003bc  e7b0              B        |L1.800|
                  |L1.958|
0003be  4824              LDR      r0,|L1.1104|
0003c0  7800              LDRB     r0,[r0,#0]            ;327  ; mdb_rx_len
0003c2  b908              CBNZ     r0,|L1.968|
0003c4  2080              MOVS     r0,#0x80              ;329
0003c6  e7ab              B        |L1.800|
                  |L1.968|
0003c8  2000              MOVS     r0,#0                 ;332
0003ca  e7a9              B        |L1.800|
;;;334    
                          ENDP

                  UART4_IRQHandler PROC
;;;338    */
;;;339    void  UART4_IRQHandler(void)
0003cc  b510              PUSH     {r4,lr}
;;;340    {
;;;341    	uint32_t  sr;
;;;342    	sr = sr;//防止编译器报错
0003ce  bf00              NOP      
;;;343    	//sr = USART3->SR;
;;;344    	if(USART_GetITStatus(UART4, USART_IT_TXE) != RESET)//发送空
0003d0  f2407127          MOV      r1,#0x727
0003d4  4814              LDR      r0,|L1.1064|
0003d6  f7fffffe          BL       USART_GetITStatus
0003da  b120              CBZ      r0,|L1.998|
;;;345    	{
;;;346    		USART_ClearITPendingBit(UART4, USART_IT_TXE);
0003dc  f2407127          MOV      r1,#0x727
0003e0  4811              LDR      r0,|L1.1064|
0003e2  f7fffffe          BL       USART_ClearITPendingBit
                  |L1.998|
;;;347    	}
;;;348    	
;;;349    	if(USART_GetITStatus(UART4, USART_IT_TC) != RESET)//发送完成
0003e6  f2406126          MOV      r1,#0x626
0003ea  480f              LDR      r0,|L1.1064|
0003ec  f7fffffe          BL       USART_GetITStatus
0003f0  b150              CBZ      r0,|L1.1032|
;;;350    	{
;;;351    		USART_ClearITPendingBit(UART4, USART_IT_TC);
0003f2  f2406126          MOV      r1,#0x626
0003f6  480c              LDR      r0,|L1.1064|
0003f8  f7fffffe          BL       USART_ClearITPendingBit
;;;352    		USART_ITConfig(UART4, USART_IT_TC, DISABLE);                                  
0003fc  2200              MOVS     r2,#0
0003fe  f2406126          MOV      r1,#0x626
000402  4809              LDR      r0,|L1.1064|
000404  f7fffffe          BL       USART_ITConfig
                  |L1.1032|
;;;353    	}
;;;354    	
;;;355    	if(USART_GetITStatus(UART4, USART_IT_RXNE) != RESET)//收到数据
000408  f2405125          MOV      r1,#0x525
00040c  4806              LDR      r0,|L1.1064|
00040e  f7fffffe          BL       USART_GetITStatus
000412  b130              CBZ      r0,|L1.1058|
;;;356    	{	 	
;;;357    		USART_ClearITPendingBit(UART4, USART_IT_RXNE);//清除接收中断标志
000414  f2405125          MOV      r1,#0x525
000418  4803              LDR      r0,|L1.1064|
00041a  f7fffffe          BL       USART_ClearITPendingBit
;;;358    		sr = USART_ReceiveData(UART4);
00041e  4802              LDR      r0,|L1.1064|
000420  e01c              B        |L1.1116|
                  |L1.1058|
000422  e034              B        |L1.1166|
                  |L1.1060|
                          DCD      0x40011000
                  |L1.1064|
                          DCD      0x40004c00
                  |L1.1068|
                          DCD      0x40020430
                  |L1.1072|
                          DCD      mdb_rx_buff
                  |L1.1076|
                          DCD      0x10000001
                  |L1.1080|
                          DCD      mdb_tx_buff
                  |L1.1084|
                          DCD      0x10000200
                  |L1.1088|
                          DCD      0x10000800
                  |L1.1092|
                          DCD      0x10020000
                  |L1.1096|
                          DCD      0x10080000
                  |L1.1100|
                          DCD      sem_mdb_recvd
                  |L1.1104|
                          DCD      mdb_rx_len
                  |L1.1108|
                          DCD      test
                  |L1.1112|
                          DCD      pt_word
                  |L1.1116|
00045c  f7fffffe          BL       USART_ReceiveData
000460  4604              MOV      r4,r0
;;;359    		mdb_rx_buff[mdb_rx_len++] = sr;
000462  4870              LDR      r0,|L1.1572|
000464  7801              LDRB     r1,[r0,#0]  ; mdb_rx_len
000466  7800              LDRB     r0,[r0,#0]  ; mdb_rx_len
000468  1c40              ADDS     r0,r0,#1
00046a  4a6e              LDR      r2,|L1.1572|
00046c  7010              STRB     r0,[r2,#0]
00046e  486e              LDR      r0,|L1.1576|
000470  f8204011          STRH     r4,[r0,r1,LSL #1]
;;;360    		if(mdb_rx_buff[mdb_rx_len - 1] & 0x100)//收到最后字节
000474  4610              MOV      r0,r2
000476  7800              LDRB     r0,[r0,#0]  ; mdb_rx_len
000478  1e40              SUBS     r0,r0,#1
00047a  496b              LDR      r1,|L1.1576|
00047c  f8310010          LDRH     r0,[r1,r0,LSL #1]
000480  f4007080          AND      r0,r0,#0x100
000484  b118              CBZ      r0,|L1.1166|
;;;361    		{
;;;362    			OSSemPost(sem_mdb_recvd);//释放信号量 
000486  4869              LDR      r0,|L1.1580|
000488  6800              LDR      r0,[r0,#0]  ; sem_mdb_recvd
00048a  f7fffffe          BL       OSSemPost
                  |L1.1166|
;;;363    		}
;;;364    	}
;;;365    	
;;;366    	if(USART_GetITStatus(UART4, USART_IT_ORE) != RESET)//溢出错误
00048e  f44f7158          MOV      r1,#0x360
000492  4867              LDR      r0,|L1.1584|
000494  f7fffffe          BL       USART_GetITStatus
000498  b140              CBZ      r0,|L1.1196|
;;;367    	{//RDR 中有数据未读，但是移位寄存器有数据需要发送到RDR中
;;;368    		sr = USART_ReceiveData(UART4);
00049a  4865              LDR      r0,|L1.1584|
00049c  f7fffffe          BL       USART_ReceiveData
0004a0  4604              MOV      r4,r0
;;;369    		USART_ClearITPendingBit(UART4, USART_IT_ORE);//请溢出错误标志
0004a2  f44f7158          MOV      r1,#0x360
0004a6  4862              LDR      r0,|L1.1584|
0004a8  f7fffffe          BL       USART_ClearITPendingBit
                  |L1.1196|
;;;370    	}
;;;371    	
;;;372    	if(USART_GetITStatus(UART4, USART_IT_IDLE) != RESET)//空闲中断
0004ac  f2404124          MOV      r1,#0x424
0004b0  485f              LDR      r0,|L1.1584|
0004b2  f7fffffe          BL       USART_GetITStatus
0004b6  b1f8              CBZ      r0,|L1.1272|
;;;373    	{
;;;374    //		sr = UART4->SR;
;;;375    		sr = UART4->DR;
0004b8  485d              LDR      r0,|L1.1584|
0004ba  1d00              ADDS     r0,r0,#4
0004bc  8804              LDRH     r4,[r0,#0]
;;;376    //		DMA_Cmd(DMA2_Channel3, DISABLE);//关闭DMA接收，防止处理时有数据过来
;;;377    		USART_ClearITPendingBit(UART4, USART_IT_IDLE );
0004be  f2404124          MOV      r1,#0x424
0004c2  1f00              SUBS     r0,r0,#4
0004c4  f7fffffe          BL       USART_ClearITPendingBit
;;;378    		//获取DMA接收数据长度
;;;379    		mdb_rx_len = MDB_RX_LEN - DMA_GetCurrDataCounter(DMA2_Channel3);//接收数据长度
0004c8  485a              LDR      r0,|L1.1588|
0004ca  f7fffffe          BL       DMA_GetCurrDataCounter
0004ce  f1c00025          RSB      r0,r0,#0x25
0004d2  4954              LDR      r1,|L1.1572|
0004d4  7008              STRB     r0,[r1,#0]
;;;380    		
;;;381    		if( mdb_rx_buff[mdb_rx_len - 1] & 0x100)//收到的是结束字符
0004d6  4608              MOV      r0,r1
0004d8  7800              LDRB     r0,[r0,#0]  ; mdb_rx_len
0004da  1e40              SUBS     r0,r0,#1
0004dc  4952              LDR      r1,|L1.1576|
0004de  f8310010          LDRH     r0,[r1,r0,LSL #1]
0004e2  f4007080          AND      r0,r0,#0x100
0004e6  b138              CBZ      r0,|L1.1272|
;;;382    		{
;;;383    			DMA_Cmd(DMA2_Channel3, DISABLE);//关闭DMA接收，防止处理时有数据过来
0004e8  2100              MOVS     r1,#0
0004ea  4852              LDR      r0,|L1.1588|
0004ec  f7fffffe          BL       DMA_Cmd
;;;384    			OSSemPost(sem_mdb_recvd);//释放信号量 
0004f0  484e              LDR      r0,|L1.1580|
0004f2  6800              LDR      r0,[r0,#0]  ; sem_mdb_recvd
0004f4  f7fffffe          BL       OSSemPost
                  |L1.1272|
;;;385    		}
;;;386    	}
;;;387    
;;;388    	if(USART_GetITStatus(UART4 ,USART_IT_PE | USART_IT_FE | USART_IT_NE) != RESET)//其他错误
0004f8  f44f715a          MOV      r1,#0x368
0004fc  484c              LDR      r0,|L1.1584|
0004fe  f7fffffe          BL       USART_GetITStatus
000502  b140              CBZ      r0,|L1.1302|
;;;389    	{
;;;390    		//没开对应的中断使能的话，是不会触发的
;;;391    		sr = USART_ReceiveData(UART4);
000504  484a              LDR      r0,|L1.1584|
000506  f7fffffe          BL       USART_ReceiveData
00050a  4604              MOV      r4,r0
;;;392    		USART_ClearITPendingBit(UART4, USART_IT_PE | USART_IT_FE | USART_IT_NE);
00050c  f44f715a          MOV      r1,#0x368
000510  4847              LDR      r0,|L1.1584|
000512  f7fffffe          BL       USART_ClearITPendingBit
                  |L1.1302|
;;;393    	}
;;;394    }
000516  bd10              POP      {r4,pc}
;;;395    
                          ENDP

                  mdb_send_cmd PROC
;;;402    */
;;;403    uint16_t* mdb_send_cmd(uint8_t *cmd, uint8_t n, uint8_t ret, uint16_t timeout, uint8_t *rs, uint16_t *rx_len)
000518  e92d5ff0          PUSH     {r4-r12,lr}
;;;404    {
00051c  4606              MOV      r6,r0
00051e  460f              MOV      r7,r1
000520  4691              MOV      r9,r2
000522  469a              MOV      r10,r3
000524  9d0a              LDR      r5,[sp,#0x28]
;;;405    	uint8_t i, j = 0;
000526  f04f0b00          MOV      r11,#0
;;;406    	uint8_t checksum = 0;
00052a  46d8              MOV      r8,r11
;;;407    	
;;;408    //	while(OSSemAccept(sem_mdb_recvd));//清除信号量
;;;409    //	USART_ITConfig(UART4, USART_IT_RXNE, ENABLE );		//开收中断
;;;410    	
;;;411    	mdb_tx_buff[0] = cmd[0] | 0x100;  //地址字节，最高位为1
00052c  7830              LDRB     r0,[r6,#0]
00052e  f4407080          ORR      r0,r0,#0x100
000532  4941              LDR      r1,|L1.1592|
000534  8008              STRH     r0,[r1,#0]
;;;412    	checksum += mdb_tx_buff[0];
000536  4608              MOV      r0,r1
000538  7800              LDRB     r0,[r0,#0]  ; mdb_tx_buff
00053a  4440              ADD      r0,r0,r8
00053c  f00008ff          AND      r8,r0,#0xff
;;;413    	for(i = 1; i < n; i++)
000540  2401              MOVS     r4,#1
000542  e009              B        |L1.1368|
                  |L1.1348|
;;;414    	{	
;;;415    		mdb_tx_buff[i] = cmd[i] & 0xff;
000544  5d30              LDRB     r0,[r6,r4]
000546  493c              LDR      r1,|L1.1592|
000548  f8210014          STRH     r0,[r1,r4,LSL #1]
;;;416    		checksum += cmd[i];
00054c  5d30              LDRB     r0,[r6,r4]
00054e  4440              ADD      r0,r0,r8
000550  f00008ff          AND      r8,r0,#0xff
000554  1c60              ADDS     r0,r4,#1              ;413
000556  b2c4              UXTB     r4,r0                 ;413
                  |L1.1368|
000558  42bc              CMP      r4,r7                 ;413
00055a  dbf3              BLT      |L1.1348|
;;;417    	}
;;;418    	mdb_tx_buff[i] = checksum;
00055c  4836              LDR      r0,|L1.1592|
00055e  f8208014          STRH     r8,[r0,r4,LSL #1]
;;;419    	
;;;420    	while(OSSemAccept(sem_mdb_recvd));
000562  bf00              NOP      
                  |L1.1380|
000564  4831              LDR      r0,|L1.1580|
000566  6800              LDR      r0,[r0,#0]  ; sem_mdb_recvd
000568  f7fffffe          BL       OSSemAccept
00056c  2800              CMP      r0,#0
00056e  d1f9              BNE      |L1.1380|
;;;421    	for(i = 0; i < MDB_RX_LEN; i++)
000570  2400              MOVS     r4,#0
000572  e005              B        |L1.1408|
                  |L1.1396|
;;;422    	{
;;;423    		mdb_rx_buff[i] = 0;
000574  2000              MOVS     r0,#0
000576  492c              LDR      r1,|L1.1576|
000578  f8210014          STRH     r0,[r1,r4,LSL #1]
00057c  1c60              ADDS     r0,r4,#1              ;421
00057e  b2c4              UXTB     r4,r0                 ;421
                  |L1.1408|
000580  2c25              CMP      r4,#0x25              ;421
000582  dbf7              BLT      |L1.1396|
;;;424    	}
;;;425    	
;;;426    	/*
;;;427    	打开DMA接收
;;;428    	在此处打开接收而不在DMA发送中断里打开是因为：
;;;429    	主机应答从机，发送ack时，从机并不应答
;;;430    	*/
;;;431    	DMA2_Channel3->CNDTR = MDB_RX_LEN;//重设置接收缓冲长度
000584  2025              MOVS     r0,#0x25
000586  492b              LDR      r1,|L1.1588|
000588  1d09              ADDS     r1,r1,#4
00058a  6008              STR      r0,[r1,#0]
;;;432    	DMA_Cmd(DMA2_Channel3, ENABLE);	//打开接收DMA
00058c  2101              MOVS     r1,#1
00058e  4829              LDR      r0,|L1.1588|
000590  f7fffffe          BL       DMA_Cmd
;;;433    	mdb_rx_len = 0;  				//复位接收缓冲区计数
000594  2000              MOVS     r0,#0
000596  4923              LDR      r1,|L1.1572|
000598  7008              STRB     r0,[r1,#0]
;;;434    //	USART_ITConfig(UART4, USART_IT_RXNE, ENABLE );		
;;;435    	
;;;436        DMA2_Channel5->CNDTR = (n + 1); //设置要发送的字节数目(多了一个校验和)
00059a  1c78              ADDS     r0,r7,#1
00059c  4925              LDR      r1,|L1.1588|
00059e  312c              ADDS     r1,r1,#0x2c
0005a0  6008              STR      r0,[r1,#0]
;;;437        DMA_Cmd(DMA2_Channel5, ENABLE);	//开始DMA发送
0005a2  2101              MOVS     r1,#1
0005a4  4823              LDR      r0,|L1.1588|
0005a6  3028              ADDS     r0,r0,#0x28
0005a8  f7fffffe          BL       DMA_Cmd
;;;438    	
;;;439        *rs = mdb_rx_handle(timeout);//处理接收数据
0005ac  4650              MOV      r0,r10
0005ae  f7fffffe          BL       mdb_rx_handle
0005b2  7028              STRB     r0,[r5,#0]
;;;440        
;;;441        while(j < ret && ((*rs) == ERR_TIME_OUT || (*rs) == NO_RESPONSE || (*rs) == ERR_CHECKSUM))//如果接收不正确
0005b4  e016              B        |L1.1508|
                  |L1.1462|
;;;442        {
;;;443        	j++;
0005b6  f10b0001          ADD      r0,r11,#1
0005ba  f0000bff          AND      r11,r0,#0xff
;;;444        	//send_ret(); //发送重发命令，目前发现很多都不支持
;;;445        	OSTimeDly(100);
0005be  2064              MOVS     r0,#0x64
0005c0  f7fffffe          BL       OSTimeDly
;;;446    		mdb_rx_len = 0;  		//复位接收缓冲区计数
0005c4  2000              MOVS     r0,#0
0005c6  4917              LDR      r1,|L1.1572|
0005c8  7008              STRB     r0,[r1,#0]
;;;447    		
;;;448    		DMA2_Channel5->CNDTR = (n + 1); 		//设置要发送的字节数目
0005ca  1c78              ADDS     r0,r7,#1
0005cc  4919              LDR      r1,|L1.1588|
0005ce  312c              ADDS     r1,r1,#0x2c
0005d0  6008              STR      r0,[r1,#0]
;;;449    		DMA_Cmd(DMA2_Channel5, ENABLE);	//开始DMA发送
0005d2  2101              MOVS     r1,#1
0005d4  4817              LDR      r0,|L1.1588|
0005d6  3028              ADDS     r0,r0,#0x28
0005d8  f7fffffe          BL       DMA_Cmd
;;;450    
;;;451        	*rs = mdb_rx_handle(timeout);
0005dc  4650              MOV      r0,r10
0005de  f7fffffe          BL       mdb_rx_handle
0005e2  7028              STRB     r0,[r5,#0]
                  |L1.1508|
0005e4  45cb              CMP      r11,r9                ;441
0005e6  da08              BGE      |L1.1530|
0005e8  7828              LDRB     r0,[r5,#0]            ;441
0005ea  2881              CMP      r0,#0x81              ;441
0005ec  d0e3              BEQ      |L1.1462|
0005ee  7828              LDRB     r0,[r5,#0]            ;441
0005f0  2880              CMP      r0,#0x80              ;441
0005f2  d0e0              BEQ      |L1.1462|
0005f4  7828              LDRB     r0,[r5,#0]            ;441
0005f6  2883              CMP      r0,#0x83              ;441
0005f8  d0dd              BEQ      |L1.1462|
                  |L1.1530|
;;;452        }
;;;453    	*rx_len = mdb_rx_len;
0005fa  480a              LDR      r0,|L1.1572|
0005fc  7801              LDRB     r1,[r0,#0]  ; mdb_rx_len
0005fe  980b              LDR      r0,[sp,#0x2c]
000600  8001              STRH     r1,[r0,#0]
;;;454    	return mdb_rx_buff;
000602  4809              LDR      r0,|L1.1576|
;;;455    }
000604  e8bd9ff0          POP      {r4-r12,pc}
;;;456    
                          ENDP

                  uart4_init PROC
;;;462    */
;;;463    void uart4_init(void)
000608  b510              PUSH     {r4,lr}
;;;464    {
;;;465    	uart4_config();
00060a  f7fffffe          BL       uart4_config
;;;466    	dma2_3_config();
00060e  f7fffffe          BL       dma2_3_config
;;;467    	dma2_5_config();
000612  f7fffffe          BL       dma2_5_config
;;;468    	sem_mdb_recvd = OSSemCreate(0);//接收数据信号量
000616  2000              MOVS     r0,#0
000618  f7fffffe          BL       OSSemCreate
00061c  4903              LDR      r1,|L1.1580|
00061e  6008              STR      r0,[r1,#0]  ; sem_mdb_recvd
;;;469    }
000620  bd10              POP      {r4,pc}
;;;470    
                          ENDP

000622  0000              DCW      0x0000
                  |L1.1572|
                          DCD      mdb_rx_len
                  |L1.1576|
                          DCD      mdb_rx_buff
                  |L1.1580|
                          DCD      sem_mdb_recvd
                  |L1.1584|
                          DCD      0x40004c00
                  |L1.1588|
                          DCD      0x40020430
                  |L1.1592|
                          DCD      mdb_tx_buff

                          AREA ||.bss||, DATA, NOINIT, ALIGN=1

                  mdb_tx_buff
                          %        74
                  mdb_rx_buff
                          %        74

                          AREA ||.data||, DATA, ALIGN=2

                  sem_mdb_recvd
                          DCD      0x00000000
                  mdb_rx_len
000004  00000000          DCB      0x00,0x00,0x00,0x00
                  test
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "..\\USR\\Mdb\\mdb_driver.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___12_mdb_driver_c_106609f7____REV16|
#line 129 "C:\\Keil_v5\\ARM\\CMSIS\\Include\\core_cmInstr.h"
|__asm___12_mdb_driver_c_106609f7____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___12_mdb_driver_c_106609f7____REVSH|
#line 144
|__asm___12_mdb_driver_c_106609f7____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
