; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\output\bsp_key.o --asm_dir=.\Listing\ --list_dir=.\Listing\ --depend=.\output\bsp_key.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x -I..\bsp_lib -I..\UCOSII\port -I..\UCOSII\src -I..\UCOSII\uC-CPU -I..\Libraries\CMSIS -I..\User\INCLUDES -I..\LCD -I..\USR\Global -I..\USR -I..\USR\FSM -I..\USR\Commucation -I..\USR\Mdb -I..\USR\Drop -I..\USR\DriverBoard -I..\USR\Flash -I..\USR\Card -I..\USR\MSG -I..\USR\Bsp -I..\USR\SetPar -I..\User\QRCode -I..\USR\MEM -I..\USR\QRCode -I..\USR\SETUP -I..\USR\stm32 -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -IC:\Keil_v5\ARM\INC\ST\STM32F10x -D__MICROLIB -D__UVISION_VERSION=525 -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER --omf_browse=.\output\bsp_key.crf ..\USR\Bsp\bsp_key.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  key_Configuration PROC
;;;41     
;;;42     static void key_Configuration(void)
000000  b508              PUSH     {r3,lr}
;;;43     {
;;;44     	GPIO_InitTypeDef GPIO_InitStructure;
;;;45     //	//WAKEUP PA0
;;;46     //	GPIO_InitStructure.GPIO_Pin=GPIO_Pin_0;
;;;47     //	GPIO_InitStructure.GPIO_Mode=GPIO_Mode_IN_FLOATING;
;;;48     //	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
;;;49     //	GPIO_Init(GPIOA,&GPIO_InitStructure);
;;;50     	
;;;51     	//DOOR PA1
;;;52     	GPIO_InitStructure.GPIO_Pin=GPIO_Pin_1;
000002  2002              MOVS     r0,#2
000004  f8ad0000          STRH     r0,[sp,#0]
;;;53     	GPIO_InitStructure.GPIO_Mode=GPIO_Mode_IN_FLOATING;
000008  2004              MOVS     r0,#4
00000a  f88d0003          STRB     r0,[sp,#3]
;;;54     //	GPIO_InitStructure.GPIO_Mode=GPIO_Mode_Out_OD;//这里改成输出，防止串扰
;;;55     	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
00000e  2003              MOVS     r0,#3
000010  f88d0002          STRB     r0,[sp,#2]
;;;56     	GPIO_Init(GPIOA,&GPIO_InitStructure);
000014  4669              MOV      r1,sp
000016  48f7              LDR      r0,|L1.1012|
000018  f7fffffe          BL       GPIO_Init
;;;57     	
;;;58     	//USER1 PE2
;;;59     	GPIO_InitStructure.GPIO_Pin=GPIO_Pin_2;
00001c  2004              MOVS     r0,#4
00001e  f8ad0000          STRH     r0,[sp,#0]
;;;60     	GPIO_InitStructure.GPIO_Mode=GPIO_Mode_IN_FLOATING;
000022  f88d0003          STRB     r0,[sp,#3]
;;;61     	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
000026  2003              MOVS     r0,#3
000028  f88d0002          STRB     r0,[sp,#2]
;;;62     	GPIO_Init(GPIOE,&GPIO_InitStructure);
00002c  4669              MOV      r1,sp
00002e  48f2              LDR      r0,|L1.1016|
000030  f7fffffe          BL       GPIO_Init
;;;63     	
;;;64     	//USER2,3,4 PB7,PB6,PB5
;;;65     	GPIO_InitStructure.GPIO_Pin=GPIO_Pin_7|GPIO_Pin_6|GPIO_Pin_5;
000034  20e0              MOVS     r0,#0xe0
000036  f8ad0000          STRH     r0,[sp,#0]
;;;66     	GPIO_InitStructure.GPIO_Mode=GPIO_Mode_IN_FLOATING;
00003a  2004              MOVS     r0,#4
00003c  f88d0003          STRB     r0,[sp,#3]
;;;67     	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
000040  2003              MOVS     r0,#3
000042  f88d0002          STRB     r0,[sp,#2]
;;;68     	GPIO_Init(GPIOB,&GPIO_InitStructure);
000046  4669              MOV      r1,sp
000048  48ec              LDR      r0,|L1.1020|
00004a  f7fffffe          BL       GPIO_Init
;;;69     	
;;;70     	//键盘输出脚 KEY5,KEY6,KEY7,KEY8.
;;;71     	GPIO_InitStructure.GPIO_Pin=GPIO_Pin_7|GPIO_Pin_8|GPIO_Pin_9|GPIO_Pin_10;
00004e  f44f60f0          MOV      r0,#0x780
000052  f8ad0000          STRH     r0,[sp,#0]
;;;72     	GPIO_InitStructure.GPIO_Mode=GPIO_Mode_Out_OD;
000056  2014              MOVS     r0,#0x14
000058  f88d0003          STRB     r0,[sp,#3]
;;;73     	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
00005c  2003              MOVS     r0,#3
00005e  f88d0002          STRB     r0,[sp,#2]
;;;74     	GPIO_Init(GPIOF,&GPIO_InitStructure);
000062  4669              MOV      r1,sp
000064  48e6              LDR      r0,|L1.1024|
000066  f7fffffe          BL       GPIO_Init
;;;75       
;;;76     	//键盘输出脚 KEY1,KEY2,KEY3,KEY4
;;;77     	GPIO_InitStructure.GPIO_Pin=GPIO_Pin_0|GPIO_Pin_1|GPIO_Pin_2|GPIO_Pin_3;
00006a  200f              MOVS     r0,#0xf
00006c  f8ad0000          STRH     r0,[sp,#0]
;;;78     	GPIO_InitStructure.GPIO_Mode=GPIO_Mode_IN_FLOATING;
000070  2004              MOVS     r0,#4
000072  f88d0003          STRB     r0,[sp,#3]
;;;79     	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
000076  2003              MOVS     r0,#3
000078  f88d0002          STRB     r0,[sp,#2]
;;;80     	GPIO_Init(GPIOC,&GPIO_InitStructure);
00007c  4669              MOV      r1,sp
00007e  48e1              LDR      r0,|L1.1028|
000080  f7fffffe          BL       GPIO_Init
;;;81     }
000084  bd08              POP      {r3,pc}
;;;82     
                          ENDP

                  keyBoardHscan PROC
;;;86     */
;;;87     static uint8_t keyBoardHscan(void)
000086  b510              PUSH     {r4,lr}
;;;88     {
;;;89     	uint8_t inputData;
;;;90     	inputData = GPIO_ReadInputData(GPIOC);
000088  48de              LDR      r0,|L1.1028|
00008a  f7fffffe          BL       GPIO_ReadInputData
00008e  b2c4              UXTB     r4,r0
;;;91     	inputData &= 0x0F;
000090  f004040f          AND      r4,r4,#0xf
;;;92     	switch(inputData)
000094  1fa0              SUBS     r0,r4,#6
000096  2809              CMP      r0,#9
000098  d216              BCS      |L1.200|
00009a  e8dff000          TBB      [pc,r0]
00009e  130b              DCB      0x13,0x0b
0000a0  150f1109          DCB      0x15,0x0f,0x11,0x09
0000a4  0d070500          DCB      0x0d,0x07,0x05,0x00
;;;93     	{
;;;94     		case ____XXX_:
;;;95     			return 0;
0000a8  2000              MOVS     r0,#0
                  |L1.170|
;;;96     		case ____XX_X:
;;;97     			return 1;
;;;98     		case ____X_XX:
;;;99     			return 2;
;;;100    		case _____XXX:
;;;101    			return 3;
;;;102    		case ____XX__:
;;;103    			return 4;
;;;104    		case ____X__X:
;;;105    			return 5;
;;;106    		case ____X_X_:
;;;107    			return 6;
;;;108    		case _____XX_:
;;;109    			return 7;
;;;110    		default:
;;;111    			return 0xFF;
;;;112    	}
;;;113    }
0000aa  bd10              POP      {r4,pc}
0000ac  2001              MOVS     r0,#1                 ;97
0000ae  e7fc              B        |L1.170|
0000b0  2002              MOVS     r0,#2                 ;99
0000b2  e7fa              B        |L1.170|
0000b4  2003              MOVS     r0,#3                 ;101
0000b6  e7f8              B        |L1.170|
0000b8  2004              MOVS     r0,#4                 ;103
0000ba  e7f6              B        |L1.170|
0000bc  2005              MOVS     r0,#5                 ;105
0000be  e7f4              B        |L1.170|
0000c0  2006              MOVS     r0,#6                 ;107
0000c2  e7f2              B        |L1.170|
0000c4  2007              MOVS     r0,#7                 ;109
0000c6  e7f0              B        |L1.170|
                  |L1.200|
0000c8  20ff              MOVS     r0,#0xff              ;111
0000ca  e7ee              B        |L1.170|
;;;114    
                          ENDP

                  send_key_msg PROC
;;;118    */
;;;119    static void send_key_msg(uint8_t key)
0000cc  b570              PUSH     {r4-r6,lr}
;;;120    {
0000ce  4605              MOV      r5,r0
;;;121    	FSMMSG* msg = apply_fsm_msg(FSMMSG_SIZE_DEFAULT);
0000d0  2000              MOVS     r0,#0
0000d2  f7fffffe          BL       apply_fsm_msg
0000d6  4604              MOV      r4,r0
;;;122    	assert_param(msg);
;;;123    	if(msg != 0)
0000d8  b1ac              CBZ      r4,|L1.262|
;;;124    	{
;;;125    		msg->type = MsgKEY;
0000da  2001              MOVS     r0,#1
0000dc  7020              STRB     r0,[r4,#0]
;;;126    		msg->value = key;
0000de  6065              STR      r5,[r4,#4]
;;;127    		BEEP(ON);
0000e0  0201              LSLS     r1,r0,#8
0000e2  48c4              LDR      r0,|L1.1012|
0000e4  f7fffffe          BL       GPIO_SetBits
;;;128    		OSTimeDly(OS_TICKS_PER_SEC/10);
0000e8  2064              MOVS     r0,#0x64
0000ea  f7fffffe          BL       OSTimeDly
;;;129    		BEEP(OFF);
0000ee  f44f7180          MOV      r1,#0x100
0000f2  48c0              LDR      r0,|L1.1012|
0000f4  f7fffffe          BL       GPIO_ResetBits
;;;130    		if(!send_fsm_msg(msg))
0000f8  4620              MOV      r0,r4
0000fa  f7fffffe          BL       send_fsm_msg
0000fe  b910              CBNZ     r0,|L1.262|
;;;131    		release_fsm_msg(msg);
000100  4620              MOV      r0,r4
000102  f7fffffe          BL       release_fsm_msg
                  |L1.262|
;;;132    	}
;;;133    }
000106  bd70              POP      {r4-r6,pc}
;;;134    
                          ENDP

                  scan_board_key PROC
;;;137    */
;;;138    static void scan_board_key(void)
000108  b510              PUSH     {r4,lr}
;;;139    {
;;;140    	uint8_t key =  0xff;
00010a  24ff              MOVS     r4,#0xff
;;;141    	
;;;142    	if(USER_1 == PRESS)
00010c  2104              MOVS     r1,#4
00010e  48ba              LDR      r0,|L1.1016|
000110  f7fffffe          BL       GPIO_ReadInputDataBit
000114  b9b8              CBNZ     r0,|L1.326|
;;;143    	{
;;;144    		key = PRESS ;
000116  2400              MOVS     r4,#0
;;;145    		OSTimeDly(60);//防抖动
000118  203c              MOVS     r0,#0x3c
00011a  f7fffffe          BL       OSTimeDly
;;;146    		if(key == USER_1)
00011e  2104              MOVS     r1,#4
000120  48b5              LDR      r0,|L1.1016|
000122  f7fffffe          BL       GPIO_ReadInputDataBit
000126  42a0              CMP      r0,r4
000128  d163              BNE      |L1.498|
;;;147    		{
;;;148    			send_key_msg(USER1_VAL);
00012a  2064              MOVS     r0,#0x64
00012c  f7fffffe          BL       send_key_msg
;;;149    			while(USER_1 == PRESS)
000130  e002              B        |L1.312|
                  |L1.306|
;;;150    			{
;;;151    				OSTimeDly(60);
000132  203c              MOVS     r0,#0x3c
000134  f7fffffe          BL       OSTimeDly
                  |L1.312|
000138  2104              MOVS     r1,#4                 ;149
00013a  48af              LDR      r0,|L1.1016|
00013c  f7fffffe          BL       GPIO_ReadInputDataBit
000140  2800              CMP      r0,#0                 ;149
000142  d0f6              BEQ      |L1.306|
000144  e055              B        |L1.498|
                  |L1.326|
;;;152    			}
;;;153    		}
;;;154    	}
;;;155    	else
;;;156    	if(USER_2 == PRESS)
000146  2180              MOVS     r1,#0x80
000148  48ac              LDR      r0,|L1.1020|
00014a  f7fffffe          BL       GPIO_ReadInputDataBit
00014e  b9b8              CBNZ     r0,|L1.384|
;;;157    	{
;;;158    		key = PRESS ;
000150  2400              MOVS     r4,#0
;;;159    		OSTimeDly(60);//防抖动
000152  203c              MOVS     r0,#0x3c
000154  f7fffffe          BL       OSTimeDly
;;;160    		if(key == USER_2)
000158  2180              MOVS     r1,#0x80
00015a  48a8              LDR      r0,|L1.1020|
00015c  f7fffffe          BL       GPIO_ReadInputDataBit
000160  42a0              CMP      r0,r4
000162  d146              BNE      |L1.498|
;;;161    		{
;;;162    			send_key_msg(USER2_VAL);
000164  2065              MOVS     r0,#0x65
000166  f7fffffe          BL       send_key_msg
;;;163    			while(USER_2 == PRESS)
00016a  e002              B        |L1.370|
                  |L1.364|
;;;164    			{
;;;165    				OSTimeDly(60);
00016c  203c              MOVS     r0,#0x3c
00016e  f7fffffe          BL       OSTimeDly
                  |L1.370|
000172  2180              MOVS     r1,#0x80              ;163
000174  48a1              LDR      r0,|L1.1020|
000176  f7fffffe          BL       GPIO_ReadInputDataBit
00017a  2800              CMP      r0,#0                 ;163
00017c  d0f6              BEQ      |L1.364|
00017e  e038              B        |L1.498|
                  |L1.384|
;;;166    			}
;;;167    		}
;;;168    	}
;;;169    	else
;;;170    	if(USER_3 == PRESS)
000180  2140              MOVS     r1,#0x40
000182  489e              LDR      r0,|L1.1020|
000184  f7fffffe          BL       GPIO_ReadInputDataBit
000188  b9b8              CBNZ     r0,|L1.442|
;;;171    	{
;;;172    		key = PRESS ;
00018a  2400              MOVS     r4,#0
;;;173    		OSTimeDly(60);//防抖动
00018c  203c              MOVS     r0,#0x3c
00018e  f7fffffe          BL       OSTimeDly
;;;174    		if(key == USER_3)
000192  2140              MOVS     r1,#0x40
000194  4899              LDR      r0,|L1.1020|
000196  f7fffffe          BL       GPIO_ReadInputDataBit
00019a  42a0              CMP      r0,r4
00019c  d129              BNE      |L1.498|
;;;175    		{
;;;176    			send_key_msg(USER3_VAL);
00019e  2066              MOVS     r0,#0x66
0001a0  f7fffffe          BL       send_key_msg
;;;177    			while(USER_3 == PRESS)
0001a4  e002              B        |L1.428|
                  |L1.422|
;;;178    			{
;;;179    				OSTimeDly(60);
0001a6  203c              MOVS     r0,#0x3c
0001a8  f7fffffe          BL       OSTimeDly
                  |L1.428|
0001ac  2140              MOVS     r1,#0x40              ;177
0001ae  4893              LDR      r0,|L1.1020|
0001b0  f7fffffe          BL       GPIO_ReadInputDataBit
0001b4  2800              CMP      r0,#0                 ;177
0001b6  d0f6              BEQ      |L1.422|
0001b8  e01b              B        |L1.498|
                  |L1.442|
;;;180    			}
;;;181    		}
;;;182    	}
;;;183    	else
;;;184    	if(USER_4 == PRESS)
0001ba  2120              MOVS     r1,#0x20
0001bc  488f              LDR      r0,|L1.1020|
0001be  f7fffffe          BL       GPIO_ReadInputDataBit
0001c2  b9b0              CBNZ     r0,|L1.498|
;;;185    	{
;;;186    		key = PRESS ;
0001c4  2400              MOVS     r4,#0
;;;187    		OSTimeDly(60);//防抖动
0001c6  203c              MOVS     r0,#0x3c
0001c8  f7fffffe          BL       OSTimeDly
;;;188    		if(key == USER_4)
0001cc  2120              MOVS     r1,#0x20
0001ce  488b              LDR      r0,|L1.1020|
0001d0  f7fffffe          BL       GPIO_ReadInputDataBit
0001d4  42a0              CMP      r0,r4
0001d6  d10c              BNE      |L1.498|
;;;189    		{
;;;190    			send_key_msg(USER4_VAL);
0001d8  2067              MOVS     r0,#0x67
0001da  f7fffffe          BL       send_key_msg
;;;191    			while(USER_4 == PRESS)
0001de  e002              B        |L1.486|
                  |L1.480|
;;;192    			{
;;;193    				OSTimeDly(60);
0001e0  203c              MOVS     r0,#0x3c
0001e2  f7fffffe          BL       OSTimeDly
                  |L1.486|
0001e6  2120              MOVS     r1,#0x20              ;191
0001e8  4884              LDR      r0,|L1.1020|
0001ea  f7fffffe          BL       GPIO_ReadInputDataBit
0001ee  2800              CMP      r0,#0                 ;191
0001f0  d0f6              BEQ      |L1.480|
                  |L1.498|
;;;194    			}
;;;195    		}
;;;196    	}
;;;197    //	else
;;;198    //	if(WAKE_UP == PRESS)
;;;199    //	{
;;;200    //		key = PRESS ;
;;;201    //		OSTimeDly(60);//防抖动
;;;202    //		if(key == WAKE_UP)
;;;203    //		{
;;;204    //			send_key_msg(WAKEUP_VAL);
;;;205    //			while(WAKE_UP == PRESS)
;;;206    //			{
;;;207    //				OSTimeDly(60);
;;;208    //			}
;;;209    //		}
;;;210    //	}
;;;211    }
0001f2  bd10              POP      {r4,pc}
;;;212    
                          ENDP

                  check_key_value PROC
;;;219    */
;;;220    static uint8_t check_key_value(uint8_t key1, uint8_t key2)
0001f4  4602              MOV      r2,r0
;;;221    {
;;;222    	uint8_t key;
;;;223    
;;;224    	#ifdef JY_MILK	//均亚牛奶组合按键定义
;;;225    		if((key1 == '3' && key2 == '8') || ( key2 == '3' && key1 == '8'))//定义为小数点位
0001f6  2a33              CMP      r2,#0x33
0001f8  d101              BNE      |L1.510|
0001fa  2938              CMP      r1,#0x38
0001fc  d003              BEQ      |L1.518|
                  |L1.510|
0001fe  2933              CMP      r1,#0x33
000200  d103              BNE      |L1.522|
000202  2a38              CMP      r2,#0x38
000204  d101              BNE      |L1.522|
                  |L1.518|
;;;226    		{
;;;227    			key = '.';
000206  202e              MOVS     r0,#0x2e
000208  e026              B        |L1.600|
                  |L1.522|
;;;228    		}
;;;229    		else
;;;230    		if((key1 == '2' && key2 == '6') || (key2 == '2' && key1 == '6'))//定义为下翻
00020a  2a32              CMP      r2,#0x32
00020c  d101              BNE      |L1.530|
00020e  2936              CMP      r1,#0x36
000210  d003              BEQ      |L1.538|
                  |L1.530|
000212  2932              CMP      r1,#0x32
000214  d103              BNE      |L1.542|
000216  2a36              CMP      r2,#0x36
000218  d101              BNE      |L1.542|
                  |L1.538|
;;;231    		{
;;;232    			key = KEY_DOWN_VAL;
00021a  206d              MOVS     r0,#0x6d
00021c  e01c              B        |L1.600|
                  |L1.542|
;;;233    		}
;;;234    		else
;;;235    		if((key1 == '1' && key2 == '5') || (key2 == '1' && key1 == '5'))//定义上翻
00021e  2a31              CMP      r2,#0x31
000220  d101              BNE      |L1.550|
000222  2935              CMP      r1,#0x35
000224  d003              BEQ      |L1.558|
                  |L1.550|
000226  2931              CMP      r1,#0x31
000228  d103              BNE      |L1.562|
00022a  2a35              CMP      r2,#0x35
00022c  d101              BNE      |L1.562|
                  |L1.558|
;;;236    		{
;;;237    			key = KEY_UP_VAL;
00022e  206c              MOVS     r0,#0x6c
000230  e012              B        |L1.600|
                  |L1.562|
;;;238    		}
;;;239    		else
;;;240    		if((key1 == '3' && key2 == '7') || (key2 == '3' && key1 == '7'))//定义上翻
000232  2a33              CMP      r2,#0x33
000234  d101              BNE      |L1.570|
000236  2937              CMP      r1,#0x37
000238  d003              BEQ      |L1.578|
                  |L1.570|
00023a  2933              CMP      r1,#0x33
00023c  d103              BNE      |L1.582|
00023e  2a37              CMP      r2,#0x37
000240  d101              BNE      |L1.582|
                  |L1.578|
;;;241    		{
;;;242    			key = '9';
000242  2039              MOVS     r0,#0x39
000244  e008              B        |L1.600|
                  |L1.582|
;;;243    		}
;;;244    		else
;;;245    		if((key1 == '4' && key2 == '8') || (key2 == '4' && key1 == '8'))//定义上翻
000246  2a34              CMP      r2,#0x34
000248  d101              BNE      |L1.590|
00024a  2938              CMP      r1,#0x38
00024c  d003              BEQ      |L1.598|
                  |L1.590|
00024e  2934              CMP      r1,#0x34
000250  d102              BNE      |L1.600|
000252  2a38              CMP      r2,#0x38
000254  d100              BNE      |L1.600|
                  |L1.598|
;;;246    		{
;;;247    			key = '0';
000256  2030              MOVS     r0,#0x30
                  |L1.600|
;;;248    		}
;;;249    	
;;;250    	#else
;;;251    		if((key1 == '8' && key2 == '6') || ( key2 == '8' && key1 == '6'))//定义为小数点位
;;;252    		{
;;;253    			key = '.';
;;;254    		}
;;;255    		else
;;;256    		if((key1 == '5' && key2 == '7') || (key2 == '5' && key1 == '7'))//定义为下翻
;;;257    		{
;;;258    			key = KEY_DOWN_VAL;
;;;259    		}
;;;260    		else
;;;261    		if((key1 == '2' && key2 == '4') || (key2 == '2' && key1 == '4'))//定义上翻
;;;262    		{
;;;263    			key = KEY_UP_VAL;
;;;264    		}
;;;265    	
;;;266    	#endif
;;;267    	
;;;268    	return key;
;;;269    }
000258  4770              BX       lr
;;;270    
                          ENDP

                  Key_Run PROC
;;;279    */
;;;280    void Key_Run(void)
00025a  b50e              PUSH     {r1-r3,lr}
;;;281    {
;;;282    	bool lock_key ,lock_group;	//键值锁定
;;;283    	bool groupFlag ;			//组合键触发标志
;;;284    	uint8_t key_row, key_line;	//记录临时值
;;;285    	uint8_t curRow, curLine ; 	//用来记录按下的键值
;;;286    	uint8_t curRow2,curLine2 ;	//记录组合键键值
;;;287    	g_vm.door = 0xff;	//门碰初始值
00025c  20ff              MOVS     r0,#0xff
00025e  496a              LDR      r1,|L1.1032|
000260  7248              STRB     r0,[r1,#9]
;;;288    	
;;;289    	key_Configuration();//初始化
000262  f7fffffe          BL       key_Configuration
;;;290    	
;;;291    	key_line = curRow = curLine = curRow2 = curLine2 = 0xff;
000266  20ff              MOVS     r0,#0xff
000268  4681              MOV      r9,r0
00026a  4683              MOV      r11,r0
00026c  4605              MOV      r5,r0
00026e  4606              MOV      r6,r0
000270  4607              MOV      r7,r0
;;;292    	lock_key = lock_group = groupFlag = FALSE;
000272  2000              MOVS     r0,#0
000274  9001              STR      r0,[sp,#4]
000276  4682              MOV      r10,r0
000278  9002              STR      r0,[sp,#8]
;;;293    	for(key_row = 0;key_row < 4; key_row++ )
00027a  2400              MOVS     r4,#0
00027c  e008              B        |L1.656|
                  |L1.638|
;;;294    	{
;;;295    		GPIO_WriteBit(GPIOF,pin[key_row],Bit_SET);//KET5~KEY8 拉高
00027e  4863              LDR      r0,|L1.1036|
000280  f8301014          LDRH     r1,[r0,r4,LSL #1]
000284  2201              MOVS     r2,#1
000286  485e              LDR      r0,|L1.1024|
000288  f7fffffe          BL       GPIO_WriteBit
00028c  1c60              ADDS     r0,r4,#1              ;293
00028e  b2c4              UXTB     r4,r0                 ;293
                  |L1.656|
000290  2c04              CMP      r4,#4                 ;293
000292  dbf4              BLT      |L1.638|
;;;296    	}
;;;297    	
;;;298    	
;;;299    	while(1)
000294  e1bf              B        |L1.1558|
                  |L1.662|
;;;300    	{
;;;301    		if(g_vm.keyState)//弹起触发方式，支持多功能按键
000296  485c              LDR      r0,|L1.1032|
000298  7a00              LDRB     r0,[r0,#8]  ; g_vm
00029a  2800              CMP      r0,#0
00029c  d07e              BEQ      |L1.924|
;;;302    		{
;;;303    			for(key_row = 0; key_row < 4; key_row++)
00029e  2400              MOVS     r4,#0
0002a0  e0e8              B        |L1.1140|
                  |L1.674|
;;;304    			{
;;;305    				GPIO_WriteBit(GPIOF, pin[key_row],Bit_RESET);//KEY5~KEY8 逐行拉低
0002a2  485a              LDR      r0,|L1.1036|
0002a4  f8301014          LDRH     r1,[r0,r4,LSL #1]
0002a8  2200              MOVS     r2,#0
0002aa  4855              LDR      r0,|L1.1024|
0002ac  f7fffffe          BL       GPIO_WriteBit
;;;306    				curRow = key_row; 	//记录当前拉低的行
0002b0  4626              MOV      r6,r4
;;;307    				OSTimeDly(10);		//等待电平平稳
0002b2  200a              MOVS     r0,#0xa
0002b4  f7fffffe          BL       OSTimeDly
;;;308    				curLine = key_line = keyBoardHscan();	//记录列按键
0002b8  f7fffffe          BL       keyBoardHscan
0002bc  4607              MOV      r7,r0
0002be  4605              MOV      r5,r0
;;;309    						
;;;310    				if(key_line != 0xFF)			//有按下动作
0002c0  2fff              CMP      r7,#0xff
0002c2  d06c              BEQ      |L1.926|
;;;311    				{
;;;312    					OSTimeDly(20);			//去抖动，可以调节按键的灵敏度
0002c4  2014              MOVS     r0,#0x14
0002c6  f7fffffe          BL       OSTimeDly
;;;313    					key_line = keyBoardHscan();
0002ca  f7fffffe          BL       keyBoardHscan
0002ce  4607              MOV      r7,r0
;;;314    					if(curLine == key_line )//如果还是前面按下的键
0002d0  42bd              CMP      r5,r7
0002d2  d164              BNE      |L1.926|
;;;315    					{
;;;316    						lock_key = TRUE;
0002d4  f04f0a01          MOV      r10,#1
;;;317    						while(lock_key)//锁住这个按键动作
0002d8  e0bf              B        |L1.1114|
                  |L1.730|
;;;318    						{	
;;;319    							if( keyBoardHscan() == 0xff)//按键松开了
0002da  f7fffffe          BL       keyBoardHscan
0002de  28ff              CMP      r0,#0xff
0002e0  d12b              BNE      |L1.826|
;;;320    							{
;;;321    								if(!groupFlag)//如果没有触发了组合键
0002e2  9801              LDR      r0,[sp,#4]
0002e4  bb20              CBNZ     r0,|L1.816|
;;;322    								{
;;;323    									FSMMSG* key=apply_fsm_msg(FSMMSG_SIZE_DEFAULT);
0002e6  2000              MOVS     r0,#0
0002e8  f7fffffe          BL       apply_fsm_msg
0002ec  4680              MOV      r8,r0
;;;324    									assert_param(key);
;;;325    									if(key != 0)
0002ee  f1b80f00          CMP      r8,#0
0002f2  d01c              BEQ      |L1.814|
;;;326    									{
;;;327    										key->type = MsgKEY;
0002f4  2001              MOVS     r0,#1
0002f6  f8880000          STRB     r0,[r8,#0]
;;;328    										key->value = keyValue[curRow][curLine];
0002fa  4845              LDR      r0,|L1.1040|
0002fc  eb000086          ADD      r0,r0,r6,LSL #2
000300  5d40              LDRB     r0,[r0,r5]
000302  f8c80004          STR      r0,[r8,#4]
;;;329    										BEEP(ON);
000306  f44f7180          MOV      r1,#0x100
00030a  483a              LDR      r0,|L1.1012|
00030c  f7fffffe          BL       GPIO_SetBits
;;;330    										OSTimeDly(OS_TICKS_PER_SEC/10);
000310  2064              MOVS     r0,#0x64
000312  f7fffffe          BL       OSTimeDly
;;;331    										BEEP(OFF);
000316  f44f7180          MOV      r1,#0x100
00031a  4836              LDR      r0,|L1.1012|
00031c  f7fffffe          BL       GPIO_ResetBits
;;;332    										if(!send_fsm_msg(key))
000320  4640              MOV      r0,r8
000322  f7fffffe          BL       send_fsm_msg
000326  b910              CBNZ     r0,|L1.814|
;;;333    										release_fsm_msg(key);
000328  4640              MOV      r0,r8
00032a  f7fffffe          BL       release_fsm_msg
                  |L1.814|
;;;334    									}
;;;335    								}
00032e  bf00              NOP      
                  |L1.816|
;;;336    								lock_key = FALSE;
000330  f04f0a00          MOV      r10,#0
;;;337    								groupFlag = FALSE;
000334  2000              MOVS     r0,#0
000336  9001              STR      r0,[sp,#4]
000338  e08f              B        |L1.1114|
                  |L1.826|
;;;338    							}
;;;339    							else//第一个按下的键没有松开
;;;340    							{
;;;341    								//组合键设计：继续扫描其他的三行,所以组合键必须是不同行不同列
;;;342    								GPIO_WriteBit(GPIOF,pin[curRow],Bit_SET);//拉高当前行
00033a  4834              LDR      r0,|L1.1036|
00033c  f8301016          LDRH     r1,[r0,r6,LSL #1]
000340  2201              MOVS     r2,#1
000342  482f              LDR      r0,|L1.1024|
000344  f7fffffe          BL       GPIO_WriteBit
;;;343    								OSTimeDly(10);//等待电平平稳
000348  200a              MOVS     r0,#0xa
00034a  f7fffffe          BL       OSTimeDly
;;;344    
;;;345    								for(key_row = 0; key_row < 4; key_row++)
00034e  2400              MOVS     r4,#0
000350  e077              B        |L1.1090|
                  |L1.850|
;;;346    								{
;;;347    									if(key_row != curRow)
000352  42b4              CMP      r4,r6
000354  d073              BEQ      |L1.1086|
;;;348    									{
;;;349    										GPIO_WriteBit(GPIOF,pin[key_row],Bit_RESET);//KEY5~KEY8 剩下3行逐行拉低
000356  482d              LDR      r0,|L1.1036|
000358  f8301014          LDRH     r1,[r0,r4,LSL #1]
00035c  2200              MOVS     r2,#0
00035e  4828              LDR      r0,|L1.1024|
000360  f7fffffe          BL       GPIO_WriteBit
;;;350    										curRow2 = key_row;
000364  46a3              MOV      r11,r4
;;;351    										OSTimeDly(10);	//等待电平平稳
000366  200a              MOVS     r0,#0xa
000368  f7fffffe          BL       OSTimeDly
;;;352    										curLine2 = key_line = keyBoardHscan();	
00036c  f7fffffe          BL       keyBoardHscan
000370  4607              MOV      r7,r0
000372  4681              MOV      r9,r0
;;;353    										
;;;354    										if(key_line != 0xff && curLine2 != curLine)			//有按下动作
000374  2fff              CMP      r7,#0xff
000376  d05b              BEQ      |L1.1072|
000378  45a9              CMP      r9,r5
00037a  d059              BEQ      |L1.1072|
;;;355    										{
;;;356    											OSTimeDly(20);	//去抖动，可以调节按键的灵敏度
00037c  2014              MOVS     r0,#0x14
00037e  f7fffffe          BL       OSTimeDly
;;;357    											
;;;358    											key_line = keyBoardHscan();
000382  f7fffffe          BL       keyBoardHscan
000386  4607              MOV      r7,r0
;;;359    											if(curLine2 == key_line )//如果还是前面按下的键
000388  45b9              CMP      r9,r7
00038a  d151              BNE      |L1.1072|
;;;360    											{
;;;361    												//这里处理方式是按下就触发，而不是弹起再触发
;;;362    												FSMMSG* key=apply_fsm_msg(FSMMSG_SIZE_DEFAULT);
00038c  2000              MOVS     r0,#0
00038e  f7fffffe          BL       apply_fsm_msg
000392  4680              MOV      r8,r0
;;;363    												assert_param(key);
;;;364    												if(key != 0)
000394  f1b80f00          CMP      r8,#0
000398  d028              BEQ      |L1.1004|
;;;365    												{
;;;366    													key->type = MsgKEY;
00039a  e001              B        |L1.928|
                  |L1.924|
00039c  e06e              B        |L1.1148|
                  |L1.926|
00039e  e060              B        |L1.1122|
                  |L1.928|
0003a0  2001              MOVS     r0,#1
0003a2  f8880000          STRB     r0,[r8,#0]
;;;367    													
;;;368    													/*
;;;369    													组合键值
;;;370    													*/
;;;371    													key->value = check_key_value(keyValue[curRow][curLine], keyValue[curRow2][curLine2]);
0003a6  4a1a              LDR      r2,|L1.1040|
0003a8  eb02028b          ADD      r2,r2,r11,LSL #2
0003ac  f8121009          LDRB     r1,[r2,r9]
0003b0  4a17              LDR      r2,|L1.1040|
0003b2  eb020286          ADD      r2,r2,r6,LSL #2
0003b6  5d50              LDRB     r0,[r2,r5]
0003b8  f7fffffe          BL       check_key_value
0003bc  f8c80004          STR      r0,[r8,#4]
;;;372    													
;;;373    													BEEP(ON);
0003c0  f44f7180          MOV      r1,#0x100
0003c4  480b              LDR      r0,|L1.1012|
0003c6  f7fffffe          BL       GPIO_SetBits
;;;374    													OSTimeDly(OS_TICKS_PER_SEC/10);
0003ca  2064              MOVS     r0,#0x64
0003cc  f7fffffe          BL       OSTimeDly
;;;375    													BEEP(OFF);
0003d0  f44f7180          MOV      r1,#0x100
0003d4  4807              LDR      r0,|L1.1012|
0003d6  f7fffffe          BL       GPIO_ResetBits
;;;376    													if(!send_fsm_msg(key))
0003da  4640              MOV      r0,r8
0003dc  f7fffffe          BL       send_fsm_msg
0003e0  b910              CBNZ     r0,|L1.1000|
;;;377    													release_fsm_msg(key);
0003e2  4640              MOV      r0,r8
0003e4  f7fffffe          BL       release_fsm_msg
                  |L1.1000|
;;;378    													groupFlag = TRUE;//触发了组合键
0003e8  2001              MOVS     r0,#1
0003ea  9001              STR      r0,[sp,#4]
                  |L1.1004|
;;;379    												}
;;;380    												
;;;381    												lock_group = TRUE;
0003ec  2001              MOVS     r0,#1
0003ee  9002              STR      r0,[sp,#8]
;;;382    												while(lock_group)//锁住第二个按键动作
0003f0  e01a              B        |L1.1064|
0003f2  0000              DCW      0x0000
                  |L1.1012|
                          DCD      0x40010800
                  |L1.1016|
                          DCD      0x40011800
                  |L1.1020|
                          DCD      0x40010c00
                  |L1.1024|
                          DCD      0x40011c00
                  |L1.1028|
                          DCD      0x40011000
                  |L1.1032|
                          DCD      g_vm
                  |L1.1036|
                          DCD      pin
                  |L1.1040|
                          DCD      keyValue
                  |L1.1044|
;;;383    												{
;;;384    													if( keyBoardHscan() == 0xff)//按键松开了
000414  f7fffffe          BL       keyBoardHscan
000418  28ff              CMP      r0,#0xff
00041a  d102              BNE      |L1.1058|
;;;385    													{
;;;386    														lock_group = FALSE;
00041c  2000              MOVS     r0,#0
00041e  9002              STR      r0,[sp,#8]
000420  e002              B        |L1.1064|
                  |L1.1058|
;;;387    													}
;;;388    													else
;;;389    													{
;;;390    //														if(key_free > 50*120)
;;;391    //															break;//守护，防止死锁
;;;392    														OSTimeDly(20);//这里可以扫描快些
000422  2014              MOVS     r0,#0x14
000424  f7fffffe          BL       OSTimeDly
                  |L1.1064|
000428  9802              LDR      r0,[sp,#8]            ;382
00042a  2800              CMP      r0,#0                 ;382
00042c  d1f2              BNE      |L1.1044|
;;;393    													}
;;;394    												}
;;;395    											}
00042e  bf00              NOP      
                  |L1.1072|
;;;396    										}
;;;397    										GPIO_WriteBit(GPIOF,pin[curRow2],Bit_SET);
000430  4879              LDR      r0,|L1.1560|
000432  f830101b          LDRH     r1,[r0,r11,LSL #1]
000436  2201              MOVS     r2,#1
000438  4878              LDR      r0,|L1.1564|
00043a  f7fffffe          BL       GPIO_WriteBit
                  |L1.1086|
00043e  1c60              ADDS     r0,r4,#1              ;345
000440  b2c4              UXTB     r4,r0                 ;345
                  |L1.1090|
000442  2c04              CMP      r4,#4                 ;345
000444  db85              BLT      |L1.850|
;;;398    									}
;;;399    								}
;;;400    								GPIO_WriteBit(GPIOF,pin[curRow],Bit_RESET);//当前行回复拉低，就是回复前一个键时状态
000446  4874              LDR      r0,|L1.1560|
000448  f8301016          LDRH     r1,[r0,r6,LSL #1]
00044c  2200              MOVS     r2,#0
00044e  4873              LDR      r0,|L1.1564|
000450  f7fffffe          BL       GPIO_WriteBit
;;;401    								OSTimeDly(10);
000454  200a              MOVS     r0,#0xa
000456  f7fffffe          BL       OSTimeDly
                  |L1.1114|
00045a  f1ba0f00          CMP      r10,#0                ;317
00045e  f47faf3c          BNE      |L1.730|
                  |L1.1122|
;;;402    							}
;;;403    						}
;;;404    					}
;;;405    				}
;;;406    				GPIO_WriteBit(GPIOF,pin[curRow],Bit_SET);//拉低的行拉高
000462  486d              LDR      r0,|L1.1560|
000464  f8301016          LDRH     r1,[r0,r6,LSL #1]
000468  2201              MOVS     r2,#1
00046a  486c              LDR      r0,|L1.1564|
00046c  f7fffffe          BL       GPIO_WriteBit
000470  1c60              ADDS     r0,r4,#1              ;303
000472  b2c4              UXTB     r4,r0                 ;303
                  |L1.1140|
000474  2c04              CMP      r4,#4                 ;303
000476  f6ffaf14          BLT      |L1.674|
00047a  e05a              B        |L1.1330|
                  |L1.1148|
;;;407    			}	
;;;408    		}
;;;409    		else//按下触发方式（不支持多功能按键）
;;;410    		{
;;;411    			for(key_row = 0; key_row < 4; key_row++)
00047c  2400              MOVS     r4,#0
00047e  e056              B        |L1.1326|
                  |L1.1152|
;;;412    			{
;;;413    				GPIO_WriteBit(GPIOF,pin[key_row],Bit_RESET);//KEY5~KEY8 逐行拉低
000480  4865              LDR      r0,|L1.1560|
000482  f8301014          LDRH     r1,[r0,r4,LSL #1]
000486  2200              MOVS     r2,#0
000488  4864              LDR      r0,|L1.1564|
00048a  f7fffffe          BL       GPIO_WriteBit
;;;414    				OSTimeDly(10);	//等待电平平稳
00048e  200a              MOVS     r0,#0xa
000490  f7fffffe          BL       OSTimeDly
;;;415    				curRow = key_row; 	//记录当前拉低的行
000494  4626              MOV      r6,r4
;;;416    				curLine = key_line = keyBoardHscan();	//记录列按键
000496  f7fffffe          BL       keyBoardHscan
00049a  4607              MOV      r7,r0
00049c  4605              MOV      r5,r0
;;;417    				if(key_line != 0xff)			//有按下动作
00049e  2fff              CMP      r7,#0xff
0004a0  d03c              BEQ      |L1.1308|
;;;418    				{
;;;419    					OSTimeDly(20);				//去抖动，可以调节按键的灵敏度
0004a2  2014              MOVS     r0,#0x14
0004a4  f7fffffe          BL       OSTimeDly
;;;420    					key_line = keyBoardHscan();
0004a8  f7fffffe          BL       keyBoardHscan
0004ac  4607              MOV      r7,r0
;;;421    					if(curLine == key_line )//如果还是前面按下的键
0004ae  42bd              CMP      r5,r7
0004b0  d134              BNE      |L1.1308|
;;;422    					{
;;;423    						FSMMSG* key=apply_fsm_msg(FSMMSG_SIZE_DEFAULT);
0004b2  2000              MOVS     r0,#0
0004b4  f7fffffe          BL       apply_fsm_msg
0004b8  4680              MOV      r8,r0
;;;424    						assert_param(key);
;;;425    						if(key != 0)
0004ba  f1b80f00          CMP      r8,#0
0004be  d01c              BEQ      |L1.1274|
;;;426    						{
;;;427    							key->type = MsgKEY;
0004c0  2001              MOVS     r0,#1
0004c2  f8880000          STRB     r0,[r8,#0]
;;;428    							key->value = keyValue[curRow][curLine];
0004c6  4856              LDR      r0,|L1.1568|
0004c8  eb000086          ADD      r0,r0,r6,LSL #2
0004cc  5d40              LDRB     r0,[r0,r5]
0004ce  f8c80004          STR      r0,[r8,#4]
;;;429    							BEEP(ON);
0004d2  f44f7180          MOV      r1,#0x100
0004d6  4853              LDR      r0,|L1.1572|
0004d8  f7fffffe          BL       GPIO_SetBits
;;;430    							OSTimeDly(OS_TICKS_PER_SEC/10);
0004dc  2064              MOVS     r0,#0x64
0004de  f7fffffe          BL       OSTimeDly
;;;431    							BEEP(OFF);
0004e2  f44f7180          MOV      r1,#0x100
0004e6  484f              LDR      r0,|L1.1572|
0004e8  f7fffffe          BL       GPIO_ResetBits
;;;432    							if(!send_fsm_msg(key))
0004ec  4640              MOV      r0,r8
0004ee  f7fffffe          BL       send_fsm_msg
0004f2  b910              CBNZ     r0,|L1.1274|
;;;433    							release_fsm_msg(key);
0004f4  4640              MOV      r0,r8
0004f6  f7fffffe          BL       release_fsm_msg
                  |L1.1274|
;;;434    						}
;;;435    						lock_key = TRUE;
0004fa  f04f0a01          MOV      r10,#1
;;;436    						while(lock_key)//锁住这个按键动作，不放开不重新扫描
0004fe  e009              B        |L1.1300|
                  |L1.1280|
;;;437    						{
;;;438    							if(keyBoardHscan() == 0xff)//按键弹起
000500  f7fffffe          BL       keyBoardHscan
000504  28ff              CMP      r0,#0xff
000506  d102              BNE      |L1.1294|
;;;439    							{
;;;440    								lock_key = FALSE;
000508  f04f0a00          MOV      r10,#0
00050c  e002              B        |L1.1300|
                  |L1.1294|
;;;441    							}
;;;442    							else
;;;443    							{
;;;444    								OSTimeDly(20);
00050e  2014              MOVS     r0,#0x14
000510  f7fffffe          BL       OSTimeDly
                  |L1.1300|
000514  f1ba0f00          CMP      r10,#0                ;436
000518  d1f2              BNE      |L1.1280|
;;;445    							}
;;;446    						}
;;;447    					}
00051a  bf00              NOP      
                  |L1.1308|
;;;448    				}
;;;449    				GPIO_WriteBit(GPIOF,pin[key_row],Bit_SET);//检测的行拉高
00051c  483e              LDR      r0,|L1.1560|
00051e  f8301014          LDRH     r1,[r0,r4,LSL #1]
000522  2201              MOVS     r2,#1
000524  483d              LDR      r0,|L1.1564|
000526  f7fffffe          BL       GPIO_WriteBit
00052a  1c60              ADDS     r0,r4,#1              ;411
00052c  b2c4              UXTB     r4,r0                 ;411
                  |L1.1326|
00052e  2c04              CMP      r4,#4                 ;411
000530  dba6              BLT      |L1.1152|
                  |L1.1330|
;;;450    			}
;;;451    		}
;;;452    		
;;;453    		/*
;;;454    		查询主板按键
;;;455    		*/
;;;456    		scan_board_key();
000532  f7fffffe          BL       scan_board_key
;;;457    		
;;;458    		/*
;;;459    		查门碰
;;;460    		门碰必须检测到，所以需要记录门碰状态
;;;461    		*/
;;;462    		if(g_vm.door != DOOR)//门碰状态改变 
000536  2102              MOVS     r1,#2
000538  483a              LDR      r0,|L1.1572|
00053a  f7fffffe          BL       GPIO_ReadInputDataBit
00053e  b908              CBNZ     r0,|L1.1348|
000540  2001              MOVS     r0,#1
000542  e000              B        |L1.1350|
                  |L1.1348|
000544  2000              MOVS     r0,#0
                  |L1.1350|
000546  4938              LDR      r1,|L1.1576|
000548  7a49              LDRB     r1,[r1,#9]  ; g_vm
00054a  4288              CMP      r0,r1
00054c  d060              BEQ      |L1.1552|
;;;463    		{
;;;464    			
;;;465    			if(g_vm.door == 0xff)//开机不发消息
00054e  4836              LDR      r0,|L1.1576|
000550  7a40              LDRB     r0,[r0,#9]  ; g_vm
000552  28ff              CMP      r0,#0xff
000554  d10a              BNE      |L1.1388|
;;;466    			{
;;;467    				g_vm.door = DOOR; 
000556  2102              MOVS     r1,#2
000558  4832              LDR      r0,|L1.1572|
00055a  f7fffffe          BL       GPIO_ReadInputDataBit
00055e  b908              CBNZ     r0,|L1.1380|
000560  2001              MOVS     r0,#1
000562  e000              B        |L1.1382|
                  |L1.1380|
000564  2000              MOVS     r0,#0
                  |L1.1382|
000566  4930              LDR      r1,|L1.1576|
000568  7248              STRB     r0,[r1,#9]
00056a  e051              B        |L1.1552|
                  |L1.1388|
;;;468    			}
;;;469    			else
;;;470    			{
;;;471    				uint8_t state;
;;;472    				state = DOOR; //记录当前状态
00056c  2102              MOVS     r1,#2
00056e  482d              LDR      r0,|L1.1572|
000570  f7fffffe          BL       GPIO_ReadInputDataBit
000574  b908              CBNZ     r0,|L1.1402|
000576  2001              MOVS     r0,#1
000578  e000              B        |L1.1404|
                  |L1.1402|
00057a  2000              MOVS     r0,#0
                  |L1.1404|
00057c  9000              STR      r0,[sp,#0]
;;;473    				OSTimeDly(60);//防抖动
00057e  203c              MOVS     r0,#0x3c
000580  f7fffffe          BL       OSTimeDly
;;;474    				if(state == DOOR)
000584  2102              MOVS     r1,#2
000586  4827              LDR      r0,|L1.1572|
000588  f7fffffe          BL       GPIO_ReadInputDataBit
00058c  b908              CBNZ     r0,|L1.1426|
00058e  2101              MOVS     r1,#1
000590  e000              B        |L1.1428|
                  |L1.1426|
000592  2100              MOVS     r1,#0
                  |L1.1428|
000594  9800              LDR      r0,[sp,#0]
000596  4281              CMP      r1,r0
000598  d139              BNE      |L1.1550|
;;;475    				{
;;;476    					FSMMSG* key=apply_fsm_msg(FSMMSG_SIZE_DEFAULT);
00059a  2000              MOVS     r0,#0
00059c  f7fffffe          BL       apply_fsm_msg
0005a0  4680              MOV      r8,r0
;;;477    					assert_param(key);
;;;478    					g_vm.door = DOOR; 
0005a2  2102              MOVS     r1,#2
0005a4  481f              LDR      r0,|L1.1572|
0005a6  f7fffffe          BL       GPIO_ReadInputDataBit
0005aa  b908              CBNZ     r0,|L1.1456|
0005ac  2001              MOVS     r0,#1
0005ae  e000              B        |L1.1458|
                  |L1.1456|
0005b0  2000              MOVS     r0,#0
                  |L1.1458|
0005b2  491d              LDR      r1,|L1.1576|
0005b4  7248              STRB     r0,[r1,#9]
;;;479    					if(key != 0)
0005b6  f1b80f00          CMP      r8,#0
0005ba  d027              BEQ      |L1.1548|
;;;480    					{
;;;481    						key->type = MsgKEY;
0005bc  2001              MOVS     r0,#1
0005be  f8880000          STRB     r0,[r8,#0]
;;;482    						if(g_vm.door == 1)//门开
0005c2  4608              MOV      r0,r1
0005c4  7a40              LDRB     r0,[r0,#9]  ; g_vm
0005c6  2801              CMP      r0,#1
0005c8  d103              BNE      |L1.1490|
;;;483    						key->value = DOOR_OPEN_VAL;
0005ca  2069              MOVS     r0,#0x69
0005cc  f8c80004          STR      r0,[r8,#4]
0005d0  e002              B        |L1.1496|
                  |L1.1490|
;;;484    						else//门关
;;;485    						key->value = DOOR_CLOSE_VAL;
0005d2  206a              MOVS     r0,#0x6a
0005d4  f8c80004          STR      r0,[r8,#4]
                  |L1.1496|
;;;486    						
;;;487    						BEEP(ON);
0005d8  f44f7180          MOV      r1,#0x100
0005dc  4811              LDR      r0,|L1.1572|
0005de  f7fffffe          BL       GPIO_SetBits
;;;488    						OSTimeDly(OS_TICKS_PER_SEC/10);
0005e2  2064              MOVS     r0,#0x64
0005e4  f7fffffe          BL       OSTimeDly
;;;489    						BEEP(OFF);
0005e8  f44f7180          MOV      r1,#0x100
0005ec  480d              LDR      r0,|L1.1572|
0005ee  f7fffffe          BL       GPIO_ResetBits
;;;490    						/*
;;;491    						门碰0表示关，1表示开
;;;492    						*/
;;;493    						report_state_change(STATE_DOOR, 1, g_vm.door);//汇报主柜门碰状态改变
0005f2  480d              LDR      r0,|L1.1576|
0005f4  7a42              LDRB     r2,[r0,#9]  ; g_vm
0005f6  2101              MOVS     r1,#1
0005f8  2004              MOVS     r0,#4
0005fa  f7fffffe          BL       report_state_change
;;;494    						if(!send_fsm_msg(key))
0005fe  4640              MOV      r0,r8
000600  f7fffffe          BL       send_fsm_msg
000604  b910              CBNZ     r0,|L1.1548|
;;;495    						release_fsm_msg(key);
000606  4640              MOV      r0,r8
000608  f7fffffe          BL       release_fsm_msg
                  |L1.1548|
;;;496    					}
;;;497    				}
00060c  bf00              NOP      
                  |L1.1550|
;;;498    			}
00060e  bf00              NOP      
                  |L1.1552|
;;;499    		}
;;;500    		
;;;501    		OSTimeDly(10);
000610  200a              MOVS     r0,#0xa
000612  f7fffffe          BL       OSTimeDly
                  |L1.1558|
000616  e63e              B        |L1.662|
;;;502    	}
;;;503    }
;;;504    
                          ENDP

                  |L1.1560|
                          DCD      pin
                  |L1.1564|
                          DCD      0x40011c00
                  |L1.1568|
                          DCD      keyValue
                  |L1.1572|
                          DCD      0x40010800
                  |L1.1576|
                          DCD      g_vm

                          AREA ||.constdata||, DATA, READONLY, ALIGN=1

                  keyValue
000000  3132332a          DCB      0x31,0x32,0x33,0x2a
000004  34353630          DCB      0x34,0x35,0x36,0x30
000008  37383923          DCB      0x37,0x38,0x39,0x23
00000c  2a302323          DCB      0x2a,0x30,0x23,0x23
                  pin
000010  04000200          DCW      0x0400,0x0200
000014  01000080          DCW      0x0100,0x0080

;*** Start embedded assembler ***

#line 1 "..\\USR\\Bsp\\bsp_key.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___9_bsp_key_c_Key_Run____REV16|
#line 129 "C:\\Keil_v5\\ARM\\CMSIS\\Include\\core_cmInstr.h"
|__asm___9_bsp_key_c_Key_Run____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___9_bsp_key_c_Key_Run____REVSH|
#line 144
|__asm___9_bsp_key_c_Key_Run____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
