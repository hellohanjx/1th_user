; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\output\log.o --asm_dir=.\Listing\ --list_dir=.\Listing\ --depend=.\output\log.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x -I..\bsp_lib -I..\UCOSII\port -I..\UCOSII\src -I..\UCOSII\uC-CPU -I..\Libraries\CMSIS -I..\User\INCLUDES -I..\LCD -I..\USR\Global -I..\USR -I..\USR\FSM -I..\USR\Commucation -I..\USR\Mdb -I..\USR\Drop -I..\USR\DriverBoard -I..\USR\Flash -I..\USR\Card -I..\USR\MSG -I..\USR\Bsp -I..\USR\SetPar -I..\User\QRCode -I..\USR\MEM -I..\USR\QRCode -I..\USR\SETUP -I..\USR\stm32 -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -IC:\Keil_v5\ARM\INC\ST\STM32F10x -D__MICROLIB -D__UVISION_VERSION=525 -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER --omf_browse=.\output\log.crf ..\USR\Bsp\log.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_return_value
                          REQUIRE _printf_u
                          REQUIRE _printf_int_dec
                  usart2_config PROC
;;;16     */
;;;17     static void usart2_config(void)
000000  b500              PUSH     {lr}
;;;18     {
000002  b085              SUB      sp,sp,#0x14
;;;19     	GPIO_InitTypeDef GPIO_InitStructure;	
;;;20     	USART_InitTypeDef USART_InitStructure;	 
;;;21     //	NVIC_InitTypeDef NVIC_InitStructure;	
;;;22     	
;;;23     
;;;24     	//使能引脚时钟，与复用功能时钟
;;;25     	RCC_APB1PeriphClockCmd( RCC_APB1Periph_USART2 , ENABLE);  
000004  2101              MOVS     r1,#1
000006  0448              LSLS     r0,r1,#17
000008  f7fffffe          BL       RCC_APB1PeriphClockCmd
;;;26     	RCC_APB2PeriphClockCmd( RCC_APB2Periph_GPIOA ,  ENABLE );
00000c  2101              MOVS     r1,#1
00000e  2004              MOVS     r0,#4
000010  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;27     	//TX 引脚
;;;28     	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_2;			//PA2
000014  2004              MOVS     r0,#4
000016  f8ad0010          STRH     r0,[sp,#0x10]
;;;29     	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;		//复用的推挽输出
00001a  2018              MOVS     r0,#0x18
00001c  f88d0013          STRB     r0,[sp,#0x13]
;;;30     	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;		
000020  2003              MOVS     r0,#3
000022  f88d0012          STRB     r0,[sp,#0x12]
;;;31     	GPIO_Init(GPIOA, &GPIO_InitStructure);
000026  a904              ADD      r1,sp,#0x10
000028  4867              LDR      r0,|L1.456|
00002a  f7fffffe          BL       GPIO_Init
;;;32         //RX 引脚
;;;33     	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_3;			//PA3
00002e  2008              MOVS     r0,#8
000030  f8ad0010          STRH     r0,[sp,#0x10]
;;;34     	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;//浮空输入
000034  2004              MOVS     r0,#4
000036  f88d0013          STRB     r0,[sp,#0x13]
;;;35     	GPIO_Init(GPIOA, &GPIO_InitStructure);
00003a  a904              ADD      r1,sp,#0x10
00003c  4862              LDR      r0,|L1.456|
00003e  f7fffffe          BL       GPIO_Init
;;;36     	//串口配置
;;;37     	USART_InitStructure.USART_BaudRate            = 115200  ;				//波特率
000042  f44f30e1          MOV      r0,#0x1c200
000046  9000              STR      r0,[sp,#0]
;;;38     	USART_InitStructure.USART_WordLength          = USART_WordLength_8b;           	//8位数据
000048  2000              MOVS     r0,#0
00004a  f8ad0004          STRH     r0,[sp,#4]
;;;39     	USART_InitStructure.USART_StopBits            = USART_StopBits_1;              	//1个停止位
00004e  f8ad0006          STRH     r0,[sp,#6]
;;;40     	USART_InitStructure.USART_Parity              = USART_Parity_No ;              	//无奇偶检验
000052  f8ad0008          STRH     r0,[sp,#8]
;;;41     	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;	//禁用硬件流控制
000056  f8ad000c          STRH     r0,[sp,#0xc]
;;;42     	USART_InitStructure.USART_Mode                = USART_Mode_Rx | USART_Mode_Tx  ;  //使能发送接收
00005a  200c              MOVS     r0,#0xc
00005c  f8ad000a          STRH     r0,[sp,#0xa]
;;;43     	USART_Init(USART2, &USART_InitStructure);
000060  4669              MOV      r1,sp
000062  485a              LDR      r0,|L1.460|
000064  f7fffffe          BL       USART_Init
;;;44     	
;;;45     	
;;;46     	//串口中断配置
;;;47     //	USART_ITConfig(USART2,USART_IT_RXNE, ENABLE);          //使能接收中断
;;;48     //	USART_ITConfig(USART2,USART_IT_ERR,ENABLE);				//使能错误中断
;;;49     //	
;;;50     //	USART_ITConfig(USART2,USART_IT_IDLE,ENABLE );		//使能空闲中断(只要这个就行)
;;;51     //	USART_ITConfig(USART2, USART_IT_TC, ENABLE);       
;;;52     //	USART_ClearITPendingBit(USART2,USART_FLAG_TC);
;;;53     //	USART_ClearITPendingBit(USART2, USART_IT_RXNE);
;;;54     
;;;55     
;;;56     	
;;;57     //	USART_ClearFlag(USART2,USART_FLAG_RXNE); 
;;;58     //	USART_ClearFlag(USART2,USART_FLAG_TC); 				//清发送完标志
;;;59     
;;;60     	USART_Cmd(USART2, ENABLE);     	//使能uart2外设
000068  2101              MOVS     r1,#1
00006a  4858              LDR      r0,|L1.460|
00006c  f7fffffe          BL       USART_Cmd
;;;61     	
;;;62     	//=============================
;;;63     	//中断使能，对应到中断向量表
;;;64     	//=============================
;;;65     //	NVIC_InitStructure.NVIC_IRQChannel = USART2_IRQn; 		                       	//USART2接收中断
;;;66     //	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1;                       //先占优先级
;;;67     //	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 3;		                        //从优先级
;;;68     //	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;									//中断通道使能
;;;69     //	NVIC_Init(&NVIC_InitStructure);
;;;70     }
000070  b005              ADD      sp,sp,#0x14
000072  bd00              POP      {pc}
;;;71     
                          ENDP

                  USART2_IRQHandler PROC
;;;78     */
;;;79     void USART2_IRQHandler(void)
000074  b510              PUSH     {r4,lr}
;;;80     {
;;;81     	uint32_t  sr;
;;;82     	sr = sr;//防止编译器报错
000076  bf00              NOP      
;;;83     	//sr = USART2->SR;
;;;84     	if(USART_GetITStatus(USART2, USART_IT_TXE) != RESET)//发送空
000078  f2407127          MOV      r1,#0x727
00007c  4853              LDR      r0,|L1.460|
00007e  f7fffffe          BL       USART_GetITStatus
000082  b120              CBZ      r0,|L1.142|
;;;85     	{
;;;86     		USART_ClearITPendingBit(USART2, USART_IT_TXE);
000084  f2407127          MOV      r1,#0x727
000088  4850              LDR      r0,|L1.460|
00008a  f7fffffe          BL       USART_ClearITPendingBit
                  |L1.142|
;;;87     	}
;;;88     	
;;;89     	if(USART_GetITStatus(USART2, USART_IT_TC) != RESET)//发送完成
00008e  f2406126          MOV      r1,#0x626
000092  484e              LDR      r0,|L1.460|
000094  f7fffffe          BL       USART_GetITStatus
000098  b190              CBZ      r0,|L1.192|
;;;90     	{
;;;91     		USART_ClearITPendingBit(USART2, USART_IT_TC);
00009a  f2406126          MOV      r1,#0x626
00009e  484b              LDR      r0,|L1.460|
0000a0  f7fffffe          BL       USART_ClearITPendingBit
;;;92     		if(pt[pt_len]!=0)
0000a4  484a              LDR      r0,|L1.464|
0000a6  6800              LDR      r0,[r0,#0]  ; pt
0000a8  494a              LDR      r1,|L1.468|
0000aa  7809              LDRB     r1,[r1,#0]  ; pt_len
0000ac  5c40              LDRB     r0,[r0,r1]
0000ae  b138              CBZ      r0,|L1.192|
;;;93     		//USART_SendData(USART2,pt[pt_len]);
;;;94     		USART2->DR = pt[pt_len];
0000b0  4847              LDR      r0,|L1.464|
0000b2  6800              LDR      r0,[r0,#0]  ; pt
0000b4  4947              LDR      r1,|L1.468|
0000b6  7809              LDRB     r1,[r1,#0]  ; pt_len
0000b8  5c40              LDRB     r0,[r0,r1]
0000ba  4944              LDR      r1,|L1.460|
0000bc  1d09              ADDS     r1,r1,#4
0000be  8008              STRH     r0,[r1,#0]
                  |L1.192|
;;;95     //		USART_ITConfig(USART2, USART_IT_TC, DISABLE);                                  
;;;96     	}
;;;97     	
;;;98     	if(USART_GetITStatus(USART2, USART_IT_RXNE) != RESET)//收到数据
0000c0  f2405125          MOV      r1,#0x525
0000c4  4841              LDR      r0,|L1.460|
0000c6  f7fffffe          BL       USART_GetITStatus
0000ca  b120              CBZ      r0,|L1.214|
;;;99     	{	 	
;;;100    		USART_ClearITPendingBit(USART2, USART_IT_RXNE);//清除接收中断标志
0000cc  f2405125          MOV      r1,#0x525
0000d0  483e              LDR      r0,|L1.460|
0000d2  f7fffffe          BL       USART_ClearITPendingBit
                  |L1.214|
;;;101    //		rx_len %= 100;
;;;102    //		rx_buffer[rx_len++]=USART_ReceiveData(USART2);//¶ÁÈ¡½ÓÊÕµ½µÄÊý¾ÝUSART2->DR,×Ô¶¯Çå³ý±êÖ¾Î»
;;;103    	}
;;;104    	
;;;105    	if(USART_GetITStatus(USART2, USART_IT_ORE) != RESET)//溢出错误
0000d6  f44f7158          MOV      r1,#0x360
0000da  483c              LDR      r0,|L1.460|
0000dc  f7fffffe          BL       USART_GetITStatus
0000e0  b140              CBZ      r0,|L1.244|
;;;106    	{//RDR 中有数据未读，但是移位寄存器有数据需要发送到RDR中
;;;107    		sr = USART_ReceiveData(USART2);
0000e2  483a              LDR      r0,|L1.460|
0000e4  f7fffffe          BL       USART_ReceiveData
0000e8  4604              MOV      r4,r0
;;;108    		USART_ClearITPendingBit(USART2, USART_IT_ORE);//请溢出错误标志
0000ea  f44f7158          MOV      r1,#0x360
0000ee  4837              LDR      r0,|L1.460|
0000f0  f7fffffe          BL       USART_ClearITPendingBit
                  |L1.244|
;;;109    	}
;;;110    	
;;;111    	if(USART_GetITStatus(USART2, USART_IT_IDLE) != RESET)//空闲
0000f4  f2404124          MOV      r1,#0x424
0000f8  4834              LDR      r0,|L1.460|
0000fa  f7fffffe          BL       USART_GetITStatus
0000fe  b118              CBZ      r0,|L1.264|
;;;112    	{
;;;113    		sr = USART_ReceiveData(USART2);
000100  4832              LDR      r0,|L1.460|
000102  f7fffffe          BL       USART_ReceiveData
000106  4604              MOV      r4,r0
                  |L1.264|
;;;114    		//获取DMA接收数据长度
;;;115    		
;;;116    	}
;;;117    
;;;118    	if(USART_GetITStatus(USART2 ,USART_IT_PE | USART_IT_FE | USART_IT_NE) != RESET)//其他错误
000108  f44f715a          MOV      r1,#0x368
00010c  482f              LDR      r0,|L1.460|
00010e  f7fffffe          BL       USART_GetITStatus
000112  b140              CBZ      r0,|L1.294|
;;;119    		{//没开对应的中断使能的话，是不会触发的
;;;120    		sr = USART_ReceiveData(USART2);
000114  482d              LDR      r0,|L1.460|
000116  f7fffffe          BL       USART_ReceiveData
00011a  4604              MOV      r4,r0
;;;121    		USART_ClearITPendingBit(USART2, USART_IT_PE | USART_IT_FE | USART_IT_NE);
00011c  f44f715a          MOV      r1,#0x368
000120  482a              LDR      r0,|L1.460|
000122  f7fffffe          BL       USART_ClearITPendingBit
                  |L1.294|
;;;122    	}
;;;123    }
000126  bd10              POP      {r4,pc}
;;;124    
                          ENDP

                  usart2_send PROC
;;;127    */
;;;128    void usart2_send(uint8_t data)
000128  bf00              NOP      
                  |L1.298|
;;;129    {
;;;130    	//TXE 弹仓空
;;;131    	//TC 枪膛空
;;;132    //	while(USART_GetFlagStatus(USART2,USART_FLAG_TC) == RESET );//Ã²ËÆµÃÓÃÕâ¸ö
;;;133    //	while(!(USART_GetFlagStatus(USART2,USART_FLAG_TXE) != RESET ));//
;;;134    	while((USART2->SR&0X40)==0){};//循环发送,直到发送完毕   
00012a  4928              LDR      r1,|L1.460|
00012c  8809              LDRH     r1,[r1,#0]
00012e  f0010140          AND      r1,r1,#0x40
000132  2900              CMP      r1,#0
000134  d0f9              BEQ      |L1.298|
;;;135    //	USART_SendData(USART2,(uint8_t)data);
;;;136       USART2->DR = (data & 0xff);	 
000136  b2c1              UXTB     r1,r0
000138  4a24              LDR      r2,|L1.460|
00013a  1d12              ADDS     r2,r2,#4
00013c  8011              STRH     r1,[r2,#0]
;;;137    
;;;138    }
00013e  4770              BX       lr
;;;139    
                          ENDP

                  log_send PROC
;;;149    */
;;;150    void log_send(uint8_t *dat, uint16_t line)
000140  b5fe              PUSH     {r1-r7,lr}
;;;151    {
000142  4605              MOV      r5,r0
000144  460e              MOV      r6,r1
;;;152    	uint16_t i ,len;
;;;153    	char tmp[10];
;;;154    	pt = dat;pt_len=0;
000146  4822              LDR      r0,|L1.464|
000148  6005              STR      r5,[r0,#0]  ; pt
00014a  2000              MOVS     r0,#0
00014c  4921              LDR      r1,|L1.468|
00014e  7008              STRB     r0,[r1,#0]
;;;155    	if(!TX_READY)
000150  4821              LDR      r0,|L1.472|
000152  7800              LDRB     r0,[r0,#0]  ; TX_READY
000154  b900              CBNZ     r0,|L1.344|
                  |L1.342|
;;;156    		return;
;;;157    	
;;;158    	
;;;159    	USART_Cmd(USART2, ENABLE);
;;;160    //	USART_ITConfig(USART2, USART_IT_TC, ENABLE);                                  
;;;161    	
;;;162    	for(i = 0; i < 300 && dat[i] != 0 ; i++)
;;;163    	{
;;;164    		usart2_send(dat[i]); 
;;;165    	}
;;;166    	
;;;167    	usart2_send('\n');
;;;168    	usart2_send('\r');
;;;169    	
;;;170    	len = sprintf(tmp, "%u", line);
;;;171    	for(i = 0; i < len; i++)
;;;172    	{
;;;173    		usart2_send( tmp[i]);
;;;174    	}
;;;175    }
000156  bdfe              POP      {r1-r7,pc}
                  |L1.344|
000158  2101              MOVS     r1,#1                 ;159
00015a  481c              LDR      r0,|L1.460|
00015c  f7fffffe          BL       USART_Cmd
000160  2400              MOVS     r4,#0                 ;162
000162  e004              B        |L1.366|
                  |L1.356|
000164  5d28              LDRB     r0,[r5,r4]            ;164
000166  f7fffffe          BL       usart2_send
00016a  1c60              ADDS     r0,r4,#1              ;162
00016c  b284              UXTH     r4,r0                 ;162
                  |L1.366|
00016e  f5b47f96          CMP      r4,#0x12c             ;162
000172  da02              BGE      |L1.378|
000174  5d28              LDRB     r0,[r5,r4]            ;162
000176  2800              CMP      r0,#0                 ;162
000178  d1f4              BNE      |L1.356|
                  |L1.378|
00017a  200a              MOVS     r0,#0xa               ;167
00017c  f7fffffe          BL       usart2_send
000180  200d              MOVS     r0,#0xd               ;168
000182  f7fffffe          BL       usart2_send
000186  4632              MOV      r2,r6                 ;170
000188  a114              ADR      r1,|L1.476|
00018a  4668              MOV      r0,sp                 ;170
00018c  f7fffffe          BL       __2sprintf
000190  b287              UXTH     r7,r0                 ;170
000192  2400              MOVS     r4,#0                 ;171
000194  e005              B        |L1.418|
                  |L1.406|
000196  f81d0004          LDRB     r0,[sp,r4]            ;173
00019a  f7fffffe          BL       usart2_send
00019e  1c60              ADDS     r0,r4,#1              ;171
0001a0  b284              UXTH     r4,r0                 ;171
                  |L1.418|
0001a2  42bc              CMP      r4,r7                 ;171
0001a4  dbf7              BLT      |L1.406|
0001a6  bf00              NOP      
0001a8  e7d5              B        |L1.342|
;;;176    
                          ENDP

                  log_init PROC
;;;179    */
;;;180    void log_init(void)
0001aa  b510              PUSH     {r4,lr}
;;;181    {
;;;182    	TIM_DeInit(TIM2);
0001ac  f04f4080          MOV      r0,#0x40000000
0001b0  f7fffffe          BL       TIM_DeInit
;;;183    	TIM_DeInit(TIM3);
0001b4  480a              LDR      r0,|L1.480|
0001b6  f7fffffe          BL       TIM_DeInit
;;;184    	
;;;185    	usart2_config();
0001ba  f7fffffe          BL       usart2_config
;;;186    	TX_READY = TRUE;
0001be  2001              MOVS     r0,#1
0001c0  4905              LDR      r1,|L1.472|
0001c2  7008              STRB     r0,[r1,#0]
;;;187    }
0001c4  bd10              POP      {r4,pc}
                          ENDP

0001c6  0000              DCW      0x0000
                  |L1.456|
                          DCD      0x40010800
                  |L1.460|
                          DCD      0x40004400
                  |L1.464|
                          DCD      ||pt||
                  |L1.468|
                          DCD      pt_len
                  |L1.472|
                          DCD      TX_READY
                  |L1.476|
0001dc  257500            DCB      "%u",0
0001df  00                DCB      0
                  |L1.480|
                          DCD      0x40000400

                          AREA ||.data||, DATA, ALIGN=2

                  TX_READY
000000  00000000          DCB      0x00,0x00,0x00,0x00
                  ||pt||
                          DCD      0x00000000
                  pt_len
000008  00                DCB      0x00

;*** Start embedded assembler ***

#line 1 "..\\USR\\Bsp\\log.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___5_log_c_TX_READY____REV16|
#line 129 "C:\\Keil_v5\\ARM\\CMSIS\\Include\\core_cmInstr.h"
|__asm___5_log_c_TX_READY____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___5_log_c_TX_READY____REVSH|
#line 144
|__asm___5_log_c_TX_READY____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
