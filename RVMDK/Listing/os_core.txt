; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\output\os_core.o --asm_dir=.\Listing\ --list_dir=.\Listing\ --depend=.\output\os_core.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x -I..\bsp_lib -I..\UCOSII\port -I..\UCOSII\src -I..\UCOSII\uC-CPU -I..\Libraries\CMSIS -I..\User\INCLUDES -I..\LCD -I..\USR\Global -I..\USR -I..\USR\FSM -I..\USR\Commucation -I..\USR\Mdb -I..\USR\Drop -I..\USR\DriverBoard -I..\USR\Flash -I..\USR\Card -I..\USR\MSG -I..\USR\Bsp -I..\USR\SetPar -I..\User\QRCode -I..\USR\MEM -I..\USR\QRCode -I..\USR\SETUP -I..\USR\stm32 -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -IC:\Keil_v5\ARM\INC\ST\STM32F10x -D__MICROLIB -D__UVISION_VERSION=525 -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER --omf_browse=.\output\os_core.crf ..\UCOSII\src\os_core.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  OS_StrCopy PROC
;;;1695   #if (OS_EVENT_NAME_SIZE > 1) || (OS_FLAG_NAME_SIZE > 1) || (OS_MEM_NAME_SIZE > 1) || (OS_TASK_NAME_SIZE > 1) || (OS_TMR_CFG_NAME_SIZE > 1)
;;;1696   INT8U  OS_StrCopy (INT8U *pdest, INT8U *psrc)
000000  4602              MOV      r2,r0
;;;1697   {
;;;1698       INT8U  len;
;;;1699   
;;;1700   
;;;1701       len = 0;
000002  2000              MOVS     r0,#0
;;;1702       while (*psrc != OS_ASCII_NUL) {
000004  e005              B        |L1.18|
                  |L1.6|
;;;1703           *pdest++ = *psrc++;
000006  f8113b01          LDRB     r3,[r1],#1
00000a  f8023b01          STRB     r3,[r2],#1
;;;1704           len++;
00000e  1c43              ADDS     r3,r0,#1
000010  b2d8              UXTB     r0,r3
                  |L1.18|
000012  780b              LDRB     r3,[r1,#0]            ;1702
000014  2b00              CMP      r3,#0                 ;1702
000016  d1f6              BNE      |L1.6|
;;;1705       }
;;;1706       *pdest = OS_ASCII_NUL;
000018  7013              STRB     r3,[r2,#0]
;;;1707       return (len);
;;;1708   }
00001a  4770              BX       lr
;;;1709   #endif
                          ENDP

                  OSEventNameGet PROC
;;;108    #if (OS_EVENT_EN) && (OS_EVENT_NAME_SIZE > 1)
;;;109    INT8U  OSEventNameGet (OS_EVENT *pevent, INT8U *pname, INT8U *perr)
00001c  e92d41f0          PUSH     {r4-r8,lr}
;;;110    {
000020  4605              MOV      r5,r0
000022  460e              MOV      r6,r1
000024  4614              MOV      r4,r2
;;;111        INT8U      len;
;;;112    #if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
;;;113        OS_CPU_SR  cpu_sr = 0;
000026  2700              MOVS     r7,#0
;;;114    #endif
;;;115    
;;;116    
;;;117    
;;;118    #if OS_ARG_CHK_EN > 0
;;;119        if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
000028  b914              CBNZ     r4,|L1.48|
;;;120            return (0);
00002a  2000              MOVS     r0,#0
                  |L1.44|
;;;121        }
;;;122        if (pevent == (OS_EVENT *)0) {               /* Is 'pevent' a NULL pointer?                        */
;;;123            *perr = OS_ERR_PEVENT_NULL;
;;;124            return (0);
;;;125        }
;;;126        if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
;;;127            *perr = OS_ERR_PNAME_NULL;
;;;128            return (0);
;;;129        }
;;;130    #endif
;;;131        if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
;;;132            *perr  = OS_ERR_NAME_GET_ISR;
;;;133            return (0);
;;;134        }
;;;135        switch (pevent->OSEventType) {
;;;136            case OS_EVENT_TYPE_SEM:
;;;137            case OS_EVENT_TYPE_MUTEX:
;;;138            case OS_EVENT_TYPE_MBOX:
;;;139            case OS_EVENT_TYPE_Q:
;;;140                 break;
;;;141    
;;;142            default:
;;;143                 *perr = OS_ERR_EVENT_TYPE;
;;;144                 return (0);
;;;145        }
;;;146        OS_ENTER_CRITICAL();
;;;147        len   = OS_StrCopy(pname, pevent->OSEventName);   /* Copy name from OS_EVENT                       */
;;;148        OS_EXIT_CRITICAL();
;;;149        *perr = OS_ERR_NONE;
;;;150        return (len);
;;;151    }
00002c  e8bd81f0          POP      {r4-r8,pc}
                  |L1.48|
000030  b91d              CBNZ     r5,|L1.58|
000032  2004              MOVS     r0,#4                 ;123
000034  7020              STRB     r0,[r4,#0]            ;123
000036  2000              MOVS     r0,#0                 ;124
000038  e7f8              B        |L1.44|
                  |L1.58|
00003a  b91e              CBNZ     r6,|L1.68|
00003c  200c              MOVS     r0,#0xc               ;127
00003e  7020              STRB     r0,[r4,#0]            ;127
000040  2000              MOVS     r0,#0                 ;128
000042  e7f3              B        |L1.44|
                  |L1.68|
000044  48fb              LDR      r0,|L1.1076|
000046  7800              LDRB     r0,[r0,#0]            ;131  ; OSIntNesting
000048  2800              CMP      r0,#0                 ;131
00004a  dd03              BLE      |L1.84|
00004c  2011              MOVS     r0,#0x11              ;132
00004e  7020              STRB     r0,[r4,#0]            ;132
000050  2000              MOVS     r0,#0                 ;133
000052  e7eb              B        |L1.44|
                  |L1.84|
000054  7828              LDRB     r0,[r5,#0]            ;135
000056  2801              CMP      r0,#1                 ;135
000058  d008              BEQ      |L1.108|
00005a  2802              CMP      r0,#2                 ;135
00005c  d007              BEQ      |L1.110|
00005e  2803              CMP      r0,#3                 ;135
000060  d002              BEQ      |L1.104|
000062  2804              CMP      r0,#4                 ;135
000064  d104              BNE      |L1.112|
000066  e000              B        |L1.106|
                  |L1.104|
000068  bf00              NOP                            ;137
                  |L1.106|
00006a  bf00              NOP                            ;138
                  |L1.108|
00006c  bf00              NOP                            ;139
                  |L1.110|
00006e  e003              B        |L1.120|
                  |L1.112|
000070  2001              MOVS     r0,#1                 ;143
000072  7020              STRB     r0,[r4,#0]            ;143
000074  2000              MOVS     r0,#0                 ;144
000076  e7d9              B        |L1.44|
                  |L1.120|
000078  bf00              NOP                            ;140
00007a  f7fffffe          BL       OS_CPU_SR_Save
00007e  4607              MOV      r7,r0                 ;146
000080  f105010f          ADD      r1,r5,#0xf            ;147
000084  4630              MOV      r0,r6                 ;147
000086  f7fffffe          BL       OS_StrCopy
00008a  4680              MOV      r8,r0                 ;147
00008c  4638              MOV      r0,r7                 ;148
00008e  f7fffffe          BL       OS_CPU_SR_Restore
000092  2000              MOVS     r0,#0                 ;149
000094  7020              STRB     r0,[r4,#0]            ;149
000096  4640              MOV      r0,r8                 ;150
000098  e7c8              B        |L1.44|
;;;152    #endif
                          ENDP

                  OS_StrLen PROC
;;;1727   #if (OS_EVENT_NAME_SIZE > 1) || (OS_FLAG_NAME_SIZE > 1) || (OS_MEM_NAME_SIZE > 1) || (OS_TASK_NAME_SIZE > 1) || (OS_TMR_CFG_NAME_SIZE > 1)
;;;1728   INT8U  OS_StrLen (INT8U *psrc)
00009a  4601              MOV      r1,r0
;;;1729   {
;;;1730       INT8U  len;
;;;1731   
;;;1732   
;;;1733       len = 0;
00009c  2000              MOVS     r0,#0
;;;1734       while (*psrc != OS_ASCII_NUL) {
00009e  e002              B        |L1.166|
                  |L1.160|
;;;1735           psrc++;
0000a0  1c49              ADDS     r1,r1,#1
;;;1736           len++;
0000a2  1c42              ADDS     r2,r0,#1
0000a4  b2d0              UXTB     r0,r2
                  |L1.166|
0000a6  780a              LDRB     r2,[r1,#0]            ;1734
0000a8  2a00              CMP      r2,#0                 ;1734
0000aa  d1f9              BNE      |L1.160|
;;;1737       }
;;;1738       return (len);
;;;1739   }
0000ac  4770              BX       lr
;;;1740   #endif
                          ENDP

                  OSEventNameSet PROC
;;;182    #if (OS_EVENT_EN) && (OS_EVENT_NAME_SIZE > 1)
;;;183    void  OSEventNameSet (OS_EVENT *pevent, INT8U *pname, INT8U *perr)
0000ae  e92d41f0          PUSH     {r4-r8,lr}
;;;184    {
0000b2  4605              MOV      r5,r0
0000b4  460e              MOV      r6,r1
0000b6  4614              MOV      r4,r2
;;;185        INT8U      len;
;;;186    #if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
;;;187        OS_CPU_SR  cpu_sr = 0;
0000b8  f04f0800          MOV      r8,#0
;;;188    #endif
;;;189    
;;;190    
;;;191    
;;;192    #if OS_ARG_CHK_EN > 0
;;;193        if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
0000bc  b90c              CBNZ     r4,|L1.194|
                  |L1.190|
;;;194            return;
;;;195        }
;;;196        if (pevent == (OS_EVENT *)0) {               /* Is 'pevent' a NULL pointer?                        */
;;;197            *perr = OS_ERR_PEVENT_NULL;
;;;198            return;
;;;199        }
;;;200        if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
;;;201            *perr = OS_ERR_PNAME_NULL;
;;;202            return;
;;;203        }
;;;204    #endif
;;;205        if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
;;;206            *perr = OS_ERR_NAME_SET_ISR;
;;;207            return;
;;;208        }
;;;209        switch (pevent->OSEventType) {
;;;210            case OS_EVENT_TYPE_SEM:
;;;211            case OS_EVENT_TYPE_MUTEX:
;;;212            case OS_EVENT_TYPE_MBOX:
;;;213            case OS_EVENT_TYPE_Q:
;;;214                 break;
;;;215    
;;;216            default:
;;;217                 *perr = OS_ERR_EVENT_TYPE;
;;;218                 return;
;;;219        }
;;;220        OS_ENTER_CRITICAL();
;;;221        len = OS_StrLen(pname);                           /* Can we fit the string in the storage area?    */
;;;222        if (len > (OS_EVENT_NAME_SIZE - 1)) {             /* No                                            */
;;;223            OS_EXIT_CRITICAL();
;;;224            *perr = OS_ERR_EVENT_NAME_TOO_LONG;
;;;225            return;
;;;226        }
;;;227        (void)OS_StrCopy(pevent->OSEventName, pname);     /* Yes, copy name to the event control block     */
;;;228        OS_EXIT_CRITICAL();
;;;229        *perr = OS_ERR_NONE;
;;;230    }
0000be  e8bd81f0          POP      {r4-r8,pc}
                  |L1.194|
0000c2  b915              CBNZ     r5,|L1.202|
0000c4  2004              MOVS     r0,#4                 ;197
0000c6  7020              STRB     r0,[r4,#0]            ;197
0000c8  e7f9              B        |L1.190|
                  |L1.202|
0000ca  b916              CBNZ     r6,|L1.210|
0000cc  200c              MOVS     r0,#0xc               ;201
0000ce  7020              STRB     r0,[r4,#0]            ;201
0000d0  e7f5              B        |L1.190|
                  |L1.210|
0000d2  48d8              LDR      r0,|L1.1076|
0000d4  7800              LDRB     r0,[r0,#0]            ;205  ; OSIntNesting
0000d6  2800              CMP      r0,#0                 ;205
0000d8  dd02              BLE      |L1.224|
0000da  2012              MOVS     r0,#0x12              ;206
0000dc  7020              STRB     r0,[r4,#0]            ;206
0000de  e7ee              B        |L1.190|
                  |L1.224|
0000e0  7828              LDRB     r0,[r5,#0]            ;209
0000e2  2801              CMP      r0,#1                 ;209
0000e4  d008              BEQ      |L1.248|
0000e6  2802              CMP      r0,#2                 ;209
0000e8  d007              BEQ      |L1.250|
0000ea  2803              CMP      r0,#3                 ;209
0000ec  d002              BEQ      |L1.244|
0000ee  2804              CMP      r0,#4                 ;209
0000f0  d104              BNE      |L1.252|
0000f2  e000              B        |L1.246|
                  |L1.244|
0000f4  bf00              NOP                            ;211
                  |L1.246|
0000f6  bf00              NOP                            ;212
                  |L1.248|
0000f8  bf00              NOP                            ;213
                  |L1.250|
0000fa  e002              B        |L1.258|
                  |L1.252|
0000fc  2001              MOVS     r0,#1                 ;217
0000fe  7020              STRB     r0,[r4,#0]            ;217
000100  e7dd              B        |L1.190|
                  |L1.258|
000102  bf00              NOP                            ;214
000104  f7fffffe          BL       OS_CPU_SR_Save
000108  4680              MOV      r8,r0                 ;220
00010a  4630              MOV      r0,r6                 ;221
00010c  f7fffffe          BL       OS_StrLen
000110  4607              MOV      r7,r0                 ;221
000112  2f01              CMP      r7,#1                 ;222
000114  dd05              BLE      |L1.290|
000116  4640              MOV      r0,r8                 ;223
000118  f7fffffe          BL       OS_CPU_SR_Restore
00011c  200b              MOVS     r0,#0xb               ;224
00011e  7020              STRB     r0,[r4,#0]            ;224
000120  e7cd              B        |L1.190|
                  |L1.290|
000122  4631              MOV      r1,r6                 ;227
000124  f105000f          ADD      r0,r5,#0xf            ;227
000128  f7fffffe          BL       OS_StrCopy
00012c  4640              MOV      r0,r8                 ;228
00012e  f7fffffe          BL       OS_CPU_SR_Restore
000132  2000              MOVS     r0,#0                 ;229
000134  7020              STRB     r0,[r4,#0]            ;229
000136  bf00              NOP      
000138  e7c1              B        |L1.190|
;;;231    #endif
                          ENDP

                  OS_TaskStatStkChk PROC
;;;1849   #if (OS_TASK_STAT_STK_CHK_EN > 0) && (OS_TASK_CREATE_EXT_EN > 0)
;;;1850   void  OS_TaskStatStkChk (void)
00013a  b57c              PUSH     {r2-r6,lr}
;;;1851   {
;;;1852       OS_TCB      *ptcb;
;;;1853       OS_STK_DATA  stk_data;
;;;1854       INT8U        err;
;;;1855       INT8U        prio;
;;;1856   
;;;1857   
;;;1858       for (prio = 0; prio <= OS_TASK_IDLE_PRIO; prio++) {
00013c  2500              MOVS     r5,#0
00013e  e014              B        |L1.362|
                  |L1.320|
;;;1859           err = OSTaskStkChk(prio, &stk_data);
000140  4669              MOV      r1,sp
000142  4628              MOV      r0,r5
000144  f7fffffe          BL       OSTaskStkChk
000148  4606              MOV      r6,r0
;;;1860           if (err == OS_ERR_NONE) {
00014a  b966              CBNZ     r6,|L1.358|
;;;1861               ptcb = OSTCBPrioTbl[prio];
00014c  48ba              LDR      r0,|L1.1080|
00014e  f8504025          LDR      r4,[r0,r5,LSL #2]
;;;1862               if (ptcb != (OS_TCB *)0) {                               /* Make sure task 'ptcb' is ...   */
000152  b144              CBZ      r4,|L1.358|
;;;1863                   if (ptcb != OS_TCB_RESERVED) {                       /* ... still valid.               */
000154  2c01              CMP      r4,#1
000156  d006              BEQ      |L1.358|
;;;1864   #if OS_TASK_PROFILE_EN > 0
;;;1865                       #if OS_STK_GROWTH == 1
;;;1866                       ptcb->OSTCBStkBase = ptcb->OSTCBStkBottom + ptcb->OSTCBStkSize;
000158  e9d40102          LDRD     r0,r1,[r4,#8]
00015c  eb000081          ADD      r0,r0,r1,LSL #2
000160  6420              STR      r0,[r4,#0x40]
;;;1867                       #else
;;;1868                       ptcb->OSTCBStkBase = ptcb->OSTCBStkBottom - ptcb->OSTCBStkSize;
;;;1869                       #endif
;;;1870                       ptcb->OSTCBStkUsed = stk_data.OSUsed;            /* Store the number of bytes used */
000162  9801              LDR      r0,[sp,#4]
000164  6460              STR      r0,[r4,#0x44]
                  |L1.358|
000166  1c68              ADDS     r0,r5,#1              ;1858
000168  b2c5              UXTB     r5,r0                 ;1858
                  |L1.362|
00016a  2d1e              CMP      r5,#0x1e              ;1858
00016c  dde8              BLE      |L1.320|
;;;1871   #endif
;;;1872                   }
;;;1873               }
;;;1874           }
;;;1875       }
;;;1876   }
00016e  bd7c              POP      {r2-r6,pc}
;;;1877   #endif
                          ENDP

                  OS_TaskStat PROC
;;;1804   #if OS_TASK_STAT_EN > 0
;;;1805   void  OS_TaskStat (void *p_arg)
000170  2400              MOVS     r4,#0
;;;1806   {
;;;1807   #if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
;;;1808       OS_CPU_SR  cpu_sr = 0;
;;;1809   #endif
;;;1810   
;;;1811   
;;;1812   
;;;1813       (void)p_arg;                                 /* Prevent compiler warning for not using 'p_arg'     */
;;;1814       while (OSStatRdy == OS_FALSE) {
000172  e002              B        |L1.378|
                  |L1.372|
;;;1815           OSTimeDly(2 * OS_TICKS_PER_SEC / 10);    /* Wait until statistic task is ready                 */
000174  20c8              MOVS     r0,#0xc8
000176  f7fffffe          BL       OSTimeDly
                  |L1.378|
00017a  48b0              LDR      r0,|L1.1084|
00017c  7800              LDRB     r0,[r0,#0]            ;1814  ; OSStatRdy
00017e  2800              CMP      r0,#0                 ;1814
000180  d0f8              BEQ      |L1.372|
;;;1816       }
;;;1817       OSIdleCtrMax /= 100L;
000182  48af              LDR      r0,|L1.1088|
000184  6800              LDR      r0,[r0,#0]  ; OSIdleCtrMax
000186  2164              MOVS     r1,#0x64
000188  fbb0f0f1          UDIV     r0,r0,r1
00018c  49ac              LDR      r1,|L1.1088|
00018e  6008              STR      r0,[r1,#0]  ; OSIdleCtrMax
;;;1818       if (OSIdleCtrMax == 0L) {
000190  4608              MOV      r0,r1
000192  6800              LDR      r0,[r0,#0]  ; OSIdleCtrMax
000194  b928              CBNZ     r0,|L1.418|
;;;1819           OSCPUUsage = 0;
000196  2000              MOVS     r0,#0
000198  49aa              LDR      r1,|L1.1092|
00019a  7008              STRB     r0,[r1,#0]
;;;1820           (void)OSTaskSuspend(OS_PRIO_SELF);
00019c  20ff              MOVS     r0,#0xff
00019e  f7fffffe          BL       OSTaskSuspend
                  |L1.418|
;;;1821       }
;;;1822       for (;;) {
0001a2  bf00              NOP      
                  |L1.420|
;;;1823           OS_ENTER_CRITICAL();
0001a4  f7fffffe          BL       OS_CPU_SR_Save
0001a8  4604              MOV      r4,r0
;;;1824           OSIdleCtrRun = OSIdleCtr;                /* Obtain the of the idle counter for the past second */
0001aa  48a7              LDR      r0,|L1.1096|
0001ac  6800              LDR      r0,[r0,#0]  ; OSIdleCtr
0001ae  49a7              LDR      r1,|L1.1100|
0001b0  6008              STR      r0,[r1,#0]  ; OSIdleCtrRun
;;;1825           OSIdleCtr    = 0L;                       /* Reset the idle counter for the next second         */
0001b2  2000              MOVS     r0,#0
0001b4  49a4              LDR      r1,|L1.1096|
0001b6  6008              STR      r0,[r1,#0]  ; OSIdleCtr
;;;1826           OS_EXIT_CRITICAL();
0001b8  4620              MOV      r0,r4
0001ba  f7fffffe          BL       OS_CPU_SR_Restore
;;;1827           OSCPUUsage   = (INT8U)(100L - OSIdleCtrRun / OSIdleCtrMax);
0001be  48a3              LDR      r0,|L1.1100|
0001c0  6800              LDR      r0,[r0,#0]  ; OSIdleCtrRun
0001c2  499f              LDR      r1,|L1.1088|
0001c4  6809              LDR      r1,[r1,#0]  ; OSIdleCtrMax
0001c6  fbb0f0f1          UDIV     r0,r0,r1
0001ca  f1c00064          RSB      r0,r0,#0x64
0001ce  499d              LDR      r1,|L1.1092|
0001d0  7008              STRB     r0,[r1,#0]
;;;1828           OSTaskStatHook();                        /* Invoke user definable hook                         */
0001d2  f7fffffe          BL       OSTaskStatHook
;;;1829   #if (OS_TASK_STAT_STK_CHK_EN > 0) && (OS_TASK_CREATE_EXT_EN > 0)
;;;1830           OS_TaskStatStkChk();                     /* Check the stacks for each task                     */
0001d6  f7fffffe          BL       OS_TaskStatStkChk
;;;1831   #endif
;;;1832           OSTimeDly(OS_TICKS_PER_SEC / 10);        /* Accumulate OSIdleCtr for the next 1/10 second      */
0001da  2064              MOVS     r0,#0x64
0001dc  f7fffffe          BL       OSTimeDly
0001e0  e7e0              B        |L1.420|
;;;1833       }
;;;1834   }
;;;1835   #endif
                          ENDP

                  OS_InitTaskStat PROC
;;;1433   #if OS_TASK_STAT_EN > 0
;;;1434   static  void  OS_InitTaskStat (void)
0001e2  b500              PUSH     {lr}
;;;1435   {
0001e4  b085              SUB      sp,sp,#0x14
;;;1436   #if OS_TASK_NAME_SIZE > 7
;;;1437       INT8U  err;
;;;1438   #endif
;;;1439   
;;;1440   
;;;1441   #if OS_TASK_CREATE_EXT_EN > 0
;;;1442       #if OS_STK_GROWTH == 1
;;;1443       (void)OSTaskCreateExt(OS_TaskStat,
0001e6  2003              MOVS     r0,#3
0001e8  2100              MOVS     r1,#0
0001ea  2280              MOVS     r2,#0x80
0001ec  4b98              LDR      r3,|L1.1104|
0001ee  e9cd3201          STRD     r3,r2,[sp,#4]
0001f2  e9cd1003          STRD     r1,r0,[sp,#0xc]
0001f6  f64f70fe          MOV      r0,#0xfffe
0001fa  231d              MOVS     r3,#0x1d
0001fc  4a95              LDR      r2,|L1.1108|
0001fe  9000              STR      r0,[sp,#0]
000200  f2af0093          ADR      r0,OS_TaskStat + 1
000204  f7fffffe          BL       OSTaskCreateExt
;;;1444                             (void *)0,                                   /* No args passed to OS_TaskStat()*/
;;;1445                             &OSTaskStatStk[OS_TASK_STAT_STK_SIZE - 1],   /* Set Top-Of-Stack               */
;;;1446                             OS_TASK_STAT_PRIO,                           /* One higher than the idle task  */
;;;1447                             OS_TASK_STAT_ID,
;;;1448                             &OSTaskStatStk[0],                           /* Set Bottom-Of-Stack            */
;;;1449                             OS_TASK_STAT_STK_SIZE,
;;;1450                             (void *)0,                                   /* No TCB extension               */
;;;1451                             OS_TASK_OPT_STK_CHK | OS_TASK_OPT_STK_CLR);  /* Enable stack checking + clear  */
;;;1452       #else
;;;1453       (void)OSTaskCreateExt(OS_TaskStat,
;;;1454                             (void *)0,                                   /* No args passed to OS_TaskStat()*/
;;;1455                             &OSTaskStatStk[0],                           /* Set Top-Of-Stack               */
;;;1456                             OS_TASK_STAT_PRIO,                           /* One higher than the idle task  */
;;;1457                             OS_TASK_STAT_ID,
;;;1458                             &OSTaskStatStk[OS_TASK_STAT_STK_SIZE - 1],   /* Set Bottom-Of-Stack            */
;;;1459                             OS_TASK_STAT_STK_SIZE,
;;;1460                             (void *)0,                                   /* No TCB extension               */
;;;1461                             OS_TASK_OPT_STK_CHK | OS_TASK_OPT_STK_CLR);  /* Enable stack checking + clear  */
;;;1462       #endif
;;;1463   #else
;;;1464       #if OS_STK_GROWTH == 1
;;;1465       (void)OSTaskCreate(OS_TaskStat,
;;;1466                          (void *)0,                                      /* No args passed to OS_TaskStat()*/
;;;1467                          &OSTaskStatStk[OS_TASK_STAT_STK_SIZE - 1],      /* Set Top-Of-Stack               */
;;;1468                          OS_TASK_STAT_PRIO);                             /* One higher than the idle task  */
;;;1469       #else
;;;1470       (void)OSTaskCreate(OS_TaskStat,
;;;1471                          (void *)0,                                      /* No args passed to OS_TaskStat()*/
;;;1472                          &OSTaskStatStk[0],                              /* Set Top-Of-Stack               */
;;;1473                          OS_TASK_STAT_PRIO);                             /* One higher than the idle task  */
;;;1474       #endif
;;;1475   #endif
;;;1476   
;;;1477   #if OS_TASK_NAME_SIZE > 14
;;;1478       OSTaskNameSet(OS_TASK_STAT_PRIO, (INT8U *)"uC/OS-II Stat", &err);
;;;1479   #else
;;;1480   #if OS_TASK_NAME_SIZE > 7
;;;1481       OSTaskNameSet(OS_TASK_STAT_PRIO, (INT8U *)"OS-Stat", &err);
;;;1482   #endif
;;;1483   #endif
;;;1484   }
000208  b005              ADD      sp,sp,#0x14
00020a  bd00              POP      {pc}
;;;1485   #endif
                          ENDP

                  OS_TaskIdle PROC
;;;1762   
;;;1763   void  OS_TaskIdle (void *p_arg)
00020c  2400              MOVS     r4,#0
;;;1764   {
;;;1765   #if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
;;;1766       OS_CPU_SR  cpu_sr = 0;
;;;1767   #endif
;;;1768   
;;;1769   
;;;1770   
;;;1771       (void)p_arg;                                 /* Prevent compiler warning for not using 'p_arg'     */
;;;1772       for (;;) {
00020e  bf00              NOP      
                  |L1.528|
;;;1773           OS_ENTER_CRITICAL();
000210  f7fffffe          BL       OS_CPU_SR_Save
000214  4604              MOV      r4,r0
;;;1774           OSIdleCtr++;
000216  488c              LDR      r0,|L1.1096|
000218  6800              LDR      r0,[r0,#0]  ; OSIdleCtr
00021a  1c40              ADDS     r0,r0,#1
00021c  498a              LDR      r1,|L1.1096|
00021e  6008              STR      r0,[r1,#0]  ; OSIdleCtr
;;;1775           OS_EXIT_CRITICAL();
000220  4620              MOV      r0,r4
000222  f7fffffe          BL       OS_CPU_SR_Restore
;;;1776           OSTaskIdleHook();                        /* Call user definable HOOK                           */
000226  f7fffffe          BL       OSTaskIdleHook
00022a  e7f1              B        |L1.528|
;;;1777       }
;;;1778   }
;;;1779   /*$PAGE*/
                          ENDP

                  OS_InitTaskIdle PROC
;;;1367   
;;;1368   static  void  OS_InitTaskIdle (void)
00022c  b500              PUSH     {lr}
;;;1369   {
00022e  b085              SUB      sp,sp,#0x14
;;;1370   #if OS_TASK_NAME_SIZE > 7
;;;1371       INT8U  err;
;;;1372   #endif
;;;1373   
;;;1374   
;;;1375   #if OS_TASK_CREATE_EXT_EN > 0
;;;1376       #if OS_STK_GROWTH == 1
;;;1377       (void)OSTaskCreateExt(OS_TaskIdle,
000230  2003              MOVS     r0,#3
000232  2100              MOVS     r1,#0
000234  2280              MOVS     r2,#0x80
000236  4b88              LDR      r3,|L1.1112|
000238  e9cd3201          STRD     r3,r2,[sp,#4]
00023c  e9cd1003          STRD     r1,r0,[sp,#0xc]
000240  f64f70ff          MOV      r0,#0xffff
000244  231e              MOVS     r3,#0x1e
000246  4a85              LDR      r2,|L1.1116|
000248  9000              STR      r0,[sp,#0]
00024a  f2af003f          ADR      r0,OS_TaskIdle + 1
00024e  f7fffffe          BL       OSTaskCreateExt
;;;1378                             (void *)0,                                 /* No arguments passed to OS_TaskIdle() */
;;;1379                             &OSTaskIdleStk[OS_TASK_IDLE_STK_SIZE - 1], /* Set Top-Of-Stack                     */
;;;1380                             OS_TASK_IDLE_PRIO,                         /* Lowest priority level                */
;;;1381                             OS_TASK_IDLE_ID,
;;;1382                             &OSTaskIdleStk[0],                         /* Set Bottom-Of-Stack                  */
;;;1383                             OS_TASK_IDLE_STK_SIZE,
;;;1384                             (void *)0,                                 /* No TCB extension                     */
;;;1385                             OS_TASK_OPT_STK_CHK | OS_TASK_OPT_STK_CLR);/* Enable stack checking + clear stack  */
;;;1386       #else
;;;1387       (void)OSTaskCreateExt(OS_TaskIdle,
;;;1388                             (void *)0,                                 /* No arguments passed to OS_TaskIdle() */
;;;1389                             &OSTaskIdleStk[0],                         /* Set Top-Of-Stack                     */
;;;1390                             OS_TASK_IDLE_PRIO,                         /* Lowest priority level                */
;;;1391                             OS_TASK_IDLE_ID,
;;;1392                             &OSTaskIdleStk[OS_TASK_IDLE_STK_SIZE - 1], /* Set Bottom-Of-Stack                  */
;;;1393                             OS_TASK_IDLE_STK_SIZE,
;;;1394                             (void *)0,                                 /* No TCB extension                     */
;;;1395                             OS_TASK_OPT_STK_CHK | OS_TASK_OPT_STK_CLR);/* Enable stack checking + clear stack  */
;;;1396       #endif
;;;1397   #else
;;;1398       #if OS_STK_GROWTH == 1
;;;1399       (void)OSTaskCreate(OS_TaskIdle,
;;;1400                          (void *)0,
;;;1401                          &OSTaskIdleStk[OS_TASK_IDLE_STK_SIZE - 1],
;;;1402                          OS_TASK_IDLE_PRIO);
;;;1403       #else
;;;1404       (void)OSTaskCreate(OS_TaskIdle,
;;;1405                          (void *)0,
;;;1406                          &OSTaskIdleStk[0],
;;;1407                          OS_TASK_IDLE_PRIO);
;;;1408       #endif
;;;1409   #endif
;;;1410   
;;;1411   #if OS_TASK_NAME_SIZE > 14
;;;1412       OSTaskNameSet(OS_TASK_IDLE_PRIO, (INT8U *)"uC/OS-II Idle", &err);
;;;1413   #else
;;;1414   #if OS_TASK_NAME_SIZE > 7
;;;1415       OSTaskNameSet(OS_TASK_IDLE_PRIO, (INT8U *)"OS-Idle", &err);
;;;1416   #endif
;;;1417   #endif
;;;1418   }
000252  b005              ADD      sp,sp,#0x14
000254  bd00              POP      {pc}
;;;1419   /*$PAGE*/
                          ENDP

                  OS_MemClr PROC
;;;1548   
;;;1549   void  OS_MemClr (INT8U *pdest, INT16U size)
000256  e004              B        |L1.610|
                  |L1.600|
;;;1550   {
;;;1551       while (size > 0) {
;;;1552           *pdest++ = (INT8U)0;
000258  2200              MOVS     r2,#0
00025a  f8002b01          STRB     r2,[r0],#1
;;;1553           size--;
00025e  1e4a              SUBS     r2,r1,#1
000260  b291              UXTH     r1,r2
                  |L1.610|
000262  2900              CMP      r1,#0                 ;1551
000264  dcf8              BGT      |L1.600|
;;;1554       }
;;;1555   }
000266  4770              BX       lr
;;;1556   /*$PAGE*/
                          ENDP

                  OS_InitEventList PROC
;;;1240   
;;;1241   static  void  OS_InitEventList (void)
000268  b530              PUSH     {r4,r5,lr}
;;;1242   {
;;;1243   #if (OS_EVENT_EN) && (OS_MAX_EVENTS > 0)
;;;1244   #if (OS_MAX_EVENTS > 1)
;;;1245       INT16U     i;
;;;1246       OS_EVENT  *pevent1;
;;;1247       OS_EVENT  *pevent2;
;;;1248   
;;;1249   
;;;1250       OS_MemClr((INT8U *)&OSEventTbl[0], sizeof(OSEventTbl)); /* Clear the event table                   */
00026a  f44f7116          MOV      r1,#0x258
00026e  487c              LDR      r0,|L1.1120|
000270  f7fffffe          BL       OS_MemClr
;;;1251       pevent1 = &OSEventTbl[0];
000274  4b7a              LDR      r3,|L1.1120|
;;;1252       pevent2 = &OSEventTbl[1];
000276  f1030514          ADD      r5,r3,#0x14
;;;1253       for (i = 0; i < (OS_MAX_EVENTS - 1); i++) {             /* Init. list of free EVENT control blocks */
00027a  2400              MOVS     r4,#0
00027c  e00a              B        |L1.660|
                  |L1.638|
;;;1254           pevent1->OSEventType    = OS_EVENT_TYPE_UNUSED;
00027e  2000              MOVS     r0,#0
000280  7018              STRB     r0,[r3,#0]
;;;1255           pevent1->OSEventPtr     = pevent2;
000282  605d              STR      r5,[r3,#4]
;;;1256   #if OS_EVENT_NAME_SIZE > 1
;;;1257           pevent1->OSEventName[0] = '?';                      /* Unknown name                            */
000284  203f              MOVS     r0,#0x3f
000286  73d8              STRB     r0,[r3,#0xf]
;;;1258           pevent1->OSEventName[1] = OS_ASCII_NUL;
000288  2100              MOVS     r1,#0
00028a  7419              STRB     r1,[r3,#0x10]
;;;1259   #endif
;;;1260           pevent1++;
00028c  3314              ADDS     r3,r3,#0x14
;;;1261           pevent2++;
00028e  3514              ADDS     r5,r5,#0x14
000290  1c60              ADDS     r0,r4,#1              ;1253
000292  b284              UXTH     r4,r0                 ;1253
                  |L1.660|
000294  2c1d              CMP      r4,#0x1d              ;1253
000296  dbf2              BLT      |L1.638|
;;;1262       }
;;;1263       pevent1->OSEventType            = OS_EVENT_TYPE_UNUSED;
000298  2000              MOVS     r0,#0
00029a  7018              STRB     r0,[r3,#0]
;;;1264       pevent1->OSEventPtr             = (OS_EVENT *)0;
00029c  6058              STR      r0,[r3,#4]
;;;1265   #if OS_EVENT_NAME_SIZE > 1
;;;1266       pevent1->OSEventName[0]         = '?';
00029e  203f              MOVS     r0,#0x3f
0002a0  73d8              STRB     r0,[r3,#0xf]
;;;1267       pevent1->OSEventName[1]         = OS_ASCII_NUL;
0002a2  2100              MOVS     r1,#0
0002a4  7419              STRB     r1,[r3,#0x10]
;;;1268   #endif
;;;1269       OSEventFreeList                 = &OSEventTbl[0];
0002a6  486e              LDR      r0,|L1.1120|
0002a8  496e              LDR      r1,|L1.1124|
0002aa  6008              STR      r0,[r1,#0]  ; OSEventFreeList
;;;1270   #else
;;;1271       OSEventFreeList                 = &OSEventTbl[0];       /* Only have ONE event control block       */
;;;1272       OSEventFreeList->OSEventType    = OS_EVENT_TYPE_UNUSED;
;;;1273       OSEventFreeList->OSEventPtr     = (OS_EVENT *)0;
;;;1274   #if OS_EVENT_NAME_SIZE > 1
;;;1275       OSEventFreeList->OSEventName[0] = '?';                  /* Unknown name                            */
;;;1276       OSEventFreeList->OSEventName[1] = OS_ASCII_NUL;
;;;1277   #endif
;;;1278   #endif
;;;1279   #endif
;;;1280   }
0002ac  bd30              POP      {r4,r5,pc}
;;;1281   /*$PAGE*/
                          ENDP

                  OS_InitTCBList PROC
;;;1499   
;;;1500   static  void  OS_InitTCBList (void)
0002ae  b530              PUSH     {r4,r5,lr}
;;;1501   {
;;;1502       INT8U    i;
;;;1503       OS_TCB  *ptcb1;
;;;1504       OS_TCB  *ptcb2;
;;;1505   
;;;1506   
;;;1507       OS_MemClr((INT8U *)&OSTCBTbl[0],     sizeof(OSTCBTbl));      /* Clear all the TCBs                 */
0002b0  f240510c          MOV      r1,#0x50c
0002b4  486c              LDR      r0,|L1.1128|
0002b6  f7fffffe          BL       OS_MemClr
;;;1508       OS_MemClr((INT8U *)&OSTCBPrioTbl[0], sizeof(OSTCBPrioTbl));  /* Clear the priority table           */
0002ba  217c              MOVS     r1,#0x7c
0002bc  485e              LDR      r0,|L1.1080|
0002be  f7fffffe          BL       OS_MemClr
;;;1509       ptcb1 = &OSTCBTbl[0];
0002c2  4b69              LDR      r3,|L1.1128|
;;;1510       ptcb2 = &OSTCBTbl[1];
0002c4  f103054c          ADD      r5,r3,#0x4c
;;;1511       for (i = 0; i < (OS_MAX_TASKS + OS_N_SYS_TASKS - 1); i++) {  /* Init. list of free TCBs            */
0002c8  2400              MOVS     r4,#0
0002ca  e00a              B        |L1.738|
                  |L1.716|
;;;1512           ptcb1->OSTCBNext = ptcb2;
0002cc  615d              STR      r5,[r3,#0x14]
;;;1513   #if OS_TASK_NAME_SIZE > 1
;;;1514           ptcb1->OSTCBTaskName[0] = '?';                           /* Unknown name                       */
0002ce  203f              MOVS     r0,#0x3f
0002d0  f8830048          STRB     r0,[r3,#0x48]
;;;1515           ptcb1->OSTCBTaskName[1] = OS_ASCII_NUL;
0002d4  2100              MOVS     r1,#0
0002d6  2049              MOVS     r0,#0x49
0002d8  54c1              STRB     r1,[r0,r3]
;;;1516   #endif
;;;1517           ptcb1++;
0002da  334c              ADDS     r3,r3,#0x4c
;;;1518           ptcb2++;
0002dc  354c              ADDS     r5,r5,#0x4c
0002de  1c60              ADDS     r0,r4,#1              ;1511
0002e0  b2c4              UXTB     r4,r0                 ;1511
                  |L1.738|
0002e2  2c10              CMP      r4,#0x10              ;1511
0002e4  d3f2              BCC      |L1.716|
;;;1519       }
;;;1520       ptcb1->OSTCBNext = (OS_TCB *)0;                              /* Last OS_TCB                        */
0002e6  2000              MOVS     r0,#0
0002e8  6158              STR      r0,[r3,#0x14]
;;;1521   #if OS_TASK_NAME_SIZE > 1
;;;1522       ptcb1->OSTCBTaskName[0] = '?';                               /* Unknown name                       */
0002ea  203f              MOVS     r0,#0x3f
0002ec  f8830048          STRB     r0,[r3,#0x48]
;;;1523       ptcb1->OSTCBTaskName[1] = OS_ASCII_NUL;
0002f0  2100              MOVS     r1,#0
0002f2  2049              MOVS     r0,#0x49
0002f4  54c1              STRB     r1,[r0,r3]
;;;1524   #endif
;;;1525       OSTCBList               = (OS_TCB *)0;                       /* TCB lists initializations          */
0002f6  2000              MOVS     r0,#0
0002f8  495c              LDR      r1,|L1.1132|
0002fa  6008              STR      r0,[r1,#0]  ; OSTCBList
;;;1526       OSTCBFreeList           = &OSTCBTbl[0];
0002fc  485a              LDR      r0,|L1.1128|
0002fe  495c              LDR      r1,|L1.1136|
000300  6008              STR      r0,[r1,#0]  ; OSTCBFreeList
;;;1527   }
000302  bd30              POP      {r4,r5,pc}
;;;1528   /*$PAGE*/
                          ENDP

                  OS_InitRdyList PROC
;;;1330   
;;;1331   static  void  OS_InitRdyList (void)
000304  2200              MOVS     r2,#0
;;;1332   {
;;;1333       INT8U    i;
;;;1334   #if OS_LOWEST_PRIO <= 63
;;;1335       INT8U   *prdytbl;
;;;1336   #else
;;;1337       INT16U  *prdytbl;
;;;1338   #endif
;;;1339   
;;;1340   
;;;1341       OSRdyGrp      = 0;                                     /* Clear the ready list                     */
000306  4b5b              LDR      r3,|L1.1140|
000308  701a              STRB     r2,[r3,#0]
;;;1342       prdytbl       = &OSRdyTbl[0];
00030a  495b              LDR      r1,|L1.1144|
;;;1343       for (i = 0; i < OS_RDY_TBL_SIZE; i++) {
00030c  2000              MOVS     r0,#0
00030e  e004              B        |L1.794|
                  |L1.784|
;;;1344           *prdytbl++ = 0;
000310  2200              MOVS     r2,#0
000312  f8012b01          STRB     r2,[r1],#1
000316  1c42              ADDS     r2,r0,#1              ;1343
000318  b2d0              UXTB     r0,r2                 ;1343
                  |L1.794|
00031a  2804              CMP      r0,#4                 ;1343
00031c  dbf8              BLT      |L1.784|
;;;1345       }
;;;1346   
;;;1347       OSPrioCur     = 0;
00031e  2200              MOVS     r2,#0
000320  4b56              LDR      r3,|L1.1148|
000322  701a              STRB     r2,[r3,#0]
;;;1348       OSPrioHighRdy = 0;
000324  4b56              LDR      r3,|L1.1152|
000326  701a              STRB     r2,[r3,#0]
;;;1349   
;;;1350       OSTCBHighRdy  = (OS_TCB *)0;
000328  4b56              LDR      r3,|L1.1156|
00032a  601a              STR      r2,[r3,#0]  ; OSTCBHighRdy
;;;1351       OSTCBCur      = (OS_TCB *)0;
00032c  4b56              LDR      r3,|L1.1160|
00032e  601a              STR      r2,[r3,#0]  ; OSTCBCur
;;;1352   }
000330  4770              BX       lr
;;;1353   
                          ENDP

                  OS_InitMisc PROC
;;;1294   
;;;1295   static  void  OS_InitMisc (void)
000332  2000              MOVS     r0,#0
;;;1296   {
;;;1297   #if OS_TIME_GET_SET_EN > 0
;;;1298       OSTime        = 0L;                                    /* Clear the 32-bit system clock            */
000334  4955              LDR      r1,|L1.1164|
000336  6008              STR      r0,[r1,#0]  ; OSTime
;;;1299   #endif
;;;1300   
;;;1301       OSIntNesting  = 0;                                     /* Clear the interrupt nesting counter      */
000338  493e              LDR      r1,|L1.1076|
00033a  7008              STRB     r0,[r1,#0]
;;;1302       OSLockNesting = 0;                                     /* Clear the scheduling lock counter        */
00033c  4954              LDR      r1,|L1.1168|
00033e  7008              STRB     r0,[r1,#0]
;;;1303   
;;;1304       OSTaskCtr     = 0;                                     /* Clear the number of tasks                */
000340  4954              LDR      r1,|L1.1172|
000342  7008              STRB     r0,[r1,#0]
;;;1305   
;;;1306       OSRunning     = OS_FALSE;                              /* Indicate that multitasking not started   */
000344  4954              LDR      r1,|L1.1176|
000346  7008              STRB     r0,[r1,#0]
;;;1307   
;;;1308       OSCtxSwCtr    = 0;                                     /* Clear the context switch counter         */
000348  4954              LDR      r1,|L1.1180|
00034a  6008              STR      r0,[r1,#0]  ; OSCtxSwCtr
;;;1309       OSIdleCtr     = 0L;                                    /* Clear the 32-bit idle counter            */
00034c  493e              LDR      r1,|L1.1096|
00034e  6008              STR      r0,[r1,#0]  ; OSIdleCtr
;;;1310   
;;;1311   #if OS_TASK_STAT_EN > 0
;;;1312       OSIdleCtrRun  = 0L;
000350  493e              LDR      r1,|L1.1100|
000352  6008              STR      r0,[r1,#0]  ; OSIdleCtrRun
;;;1313       OSIdleCtrMax  = 0L;
000354  493a              LDR      r1,|L1.1088|
000356  6008              STR      r0,[r1,#0]  ; OSIdleCtrMax
;;;1314       OSStatRdy     = OS_FALSE;                              /* Statistic task is not ready              */
000358  4938              LDR      r1,|L1.1084|
00035a  7008              STRB     r0,[r1,#0]
;;;1315   #endif
;;;1316   }
00035c  4770              BX       lr
;;;1317   /*$PAGE*/
                          ENDP

                  OSInit PROC
;;;553    
;;;554    void  OSInit (void)
00035e  b510              PUSH     {r4,lr}
;;;555    {
;;;556        OSInitHookBegin();                                           /* Call port specific initialization code   */
000360  f7fffffe          BL       OSInitHookBegin
;;;557    
;;;558        OS_InitMisc();                                               /* Initialize miscellaneous variables       */
000364  f7fffffe          BL       OS_InitMisc
;;;559    
;;;560        OS_InitRdyList();                                            /* Initialize the Ready List                */
000368  f7fffffe          BL       OS_InitRdyList
;;;561    
;;;562        OS_InitTCBList();                                            /* Initialize the free list of OS_TCBs      */
00036c  f7fffffe          BL       OS_InitTCBList
;;;563    
;;;564        OS_InitEventList();                                          /* Initialize the free list of OS_EVENTs    */
000370  f7fffffe          BL       OS_InitEventList
;;;565    
;;;566    #if (OS_FLAG_EN > 0) && (OS_MAX_FLAGS > 0)
;;;567        OS_FlagInit();                                               /* Initialize the event flag structures     */
000374  f7fffffe          BL       OS_FlagInit
;;;568    #endif
;;;569    
;;;570    #if (OS_MEM_EN > 0) && (OS_MAX_MEM_PART > 0)
;;;571        OS_MemInit();                                                /* Initialize the memory manager            */
000378  f7fffffe          BL       OS_MemInit
;;;572    #endif
;;;573    
;;;574    #if (OS_Q_EN > 0) && (OS_MAX_QS > 0)
;;;575        OS_QInit();                                                  /* Initialize the message queue structures  */
00037c  f7fffffe          BL       OS_QInit
;;;576    #endif
;;;577    
;;;578        OS_InitTaskIdle();                                           /* Create the Idle Task                     */
000380  f7fffffe          BL       OS_InitTaskIdle
;;;579    #if OS_TASK_STAT_EN > 0
;;;580        OS_InitTaskStat();                                           /* Create the Statistic Task                */
000384  f7fffffe          BL       OS_InitTaskStat
;;;581    #endif
;;;582    
;;;583    #if OS_TMR_EN > 0
;;;584        OSTmr_Init();                                                /* Initialize the Timer Manager             */
;;;585    #endif
;;;586    
;;;587        OSInitHookEnd();                                             /* Call port specific init. code            */
000388  f7fffffe          BL       OSInitHookEnd
;;;588    
;;;589    #if OS_DEBUG_EN > 0
;;;590        OSDebugInit();
;;;591    #endif
;;;592    }
00038c  bd10              POP      {r4,pc}
;;;593    /*$PAGE*/
                          ENDP

                  OSIntEnter PROC
;;;618    
;;;619    void  OSIntEnter (void)
00038e  4842              LDR      r0,|L1.1176|
;;;620    {
;;;621        if (OSRunning == OS_TRUE) {
000390  7800              LDRB     r0,[r0,#0]  ; OSRunning
000392  2801              CMP      r0,#1
000394  d108              BNE      |L1.936|
;;;622            if (OSIntNesting < 255u) {
000396  4827              LDR      r0,|L1.1076|
000398  7800              LDRB     r0,[r0,#0]  ; OSIntNesting
00039a  28ff              CMP      r0,#0xff
00039c  d204              BCS      |L1.936|
;;;623                OSIntNesting++;                      /* Increment ISR nesting level                        */
00039e  4825              LDR      r0,|L1.1076|
0003a0  7800              LDRB     r0,[r0,#0]  ; OSIntNesting
0003a2  1c40              ADDS     r0,r0,#1
0003a4  4923              LDR      r1,|L1.1076|
0003a6  7008              STRB     r0,[r1,#0]
                  |L1.936|
;;;624            }
;;;625        }
;;;626    }
0003a8  4770              BX       lr
;;;627    /*$PAGE*/
                          ENDP

                  OS_SchedNew PROC
;;;1647   
;;;1648   static  void  OS_SchedNew (void)
0003aa  493d              LDR      r1,|L1.1184|
;;;1649   {
;;;1650   #if OS_LOWEST_PRIO <= 63                         /* See if we support up to 64 tasks                   */
;;;1651       INT8U   y;
;;;1652   
;;;1653   
;;;1654       y             = OSUnMapTbl[OSRdyGrp];
0003ac  4a31              LDR      r2,|L1.1140|
0003ae  7812              LDRB     r2,[r2,#0]  ; OSRdyGrp
0003b0  5c88              LDRB     r0,[r1,r2]
;;;1655       OSPrioHighRdy = (INT8U)((y << 3) + OSUnMapTbl[OSRdyTbl[y]]);
0003b2  4931              LDR      r1,|L1.1144|
0003b4  5c09              LDRB     r1,[r1,r0]
0003b6  4a3a              LDR      r2,|L1.1184|
0003b8  5c51              LDRB     r1,[r2,r1]
0003ba  eb0101c0          ADD      r1,r1,r0,LSL #3
0003be  4a30              LDR      r2,|L1.1152|
0003c0  7011              STRB     r1,[r2,#0]
;;;1656   #else                                            /* We support up to 256 tasks                         */
;;;1657       INT8U   y;
;;;1658       INT16U *ptbl;
;;;1659   
;;;1660   
;;;1661       if ((OSRdyGrp & 0xFF) != 0) {
;;;1662           y = OSUnMapTbl[OSRdyGrp & 0xFF];
;;;1663       } else {
;;;1664           y = OSUnMapTbl[(OSRdyGrp >> 8) & 0xFF] + 8;
;;;1665       }
;;;1666       ptbl = &OSRdyTbl[y];
;;;1667       if ((*ptbl & 0xFF) != 0) {
;;;1668           OSPrioHighRdy = (INT8U)((y << 4) + OSUnMapTbl[(*ptbl & 0xFF)]);
;;;1669       } else {
;;;1670           OSPrioHighRdy = (INT8U)((y << 4) + OSUnMapTbl[(*ptbl >> 8) & 0xFF] + 8);
;;;1671       }
;;;1672   #endif
;;;1673   }
0003c2  4770              BX       lr
;;;1674   
                          ENDP

                  OSIntExit PROC
;;;646    
;;;647    void  OSIntExit (void)
0003c4  b510              PUSH     {r4,lr}
;;;648    {
;;;649    #if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
;;;650        OS_CPU_SR  cpu_sr = 0;
0003c6  2400              MOVS     r4,#0
;;;651    #endif
;;;652    
;;;653    
;;;654    
;;;655        if (OSRunning == OS_TRUE) {
0003c8  4833              LDR      r0,|L1.1176|
0003ca  7800              LDRB     r0,[r0,#0]  ; OSRunning
0003cc  2801              CMP      r0,#1
0003ce  d130              BNE      |L1.1074|
;;;656            OS_ENTER_CRITICAL();
0003d0  f7fffffe          BL       OS_CPU_SR_Save
0003d4  4604              MOV      r4,r0
;;;657            if (OSIntNesting > 0) {                            /* Prevent OSIntNesting from wrapping       */
0003d6  4817              LDR      r0,|L1.1076|
0003d8  7800              LDRB     r0,[r0,#0]  ; OSIntNesting
0003da  2800              CMP      r0,#0
0003dc  dd04              BLE      |L1.1000|
;;;658                OSIntNesting--;
0003de  4815              LDR      r0,|L1.1076|
0003e0  7800              LDRB     r0,[r0,#0]  ; OSIntNesting
0003e2  1e40              SUBS     r0,r0,#1
0003e4  4913              LDR      r1,|L1.1076|
0003e6  7008              STRB     r0,[r1,#0]
                  |L1.1000|
;;;659            }
;;;660            if (OSIntNesting == 0) {                           /* Reschedule only if all ISRs complete ... */
0003e8  4812              LDR      r0,|L1.1076|
0003ea  7800              LDRB     r0,[r0,#0]  ; OSIntNesting
0003ec  b9f0              CBNZ     r0,|L1.1068|
;;;661                if (OSLockNesting == 0) {                      /* ... and not locked.                      */
0003ee  4828              LDR      r0,|L1.1168|
0003f0  7800              LDRB     r0,[r0,#0]  ; OSLockNesting
0003f2  b9d8              CBNZ     r0,|L1.1068|
;;;662                    OS_SchedNew();
0003f4  f7fffffe          BL       OS_SchedNew
;;;663                    if (OSPrioHighRdy != OSPrioCur) {          /* No Ctx Sw if current task is highest rdy */
0003f8  4821              LDR      r0,|L1.1152|
0003fa  7800              LDRB     r0,[r0,#0]  ; OSPrioHighRdy
0003fc  491f              LDR      r1,|L1.1148|
0003fe  7809              LDRB     r1,[r1,#0]  ; OSPrioCur
000400  4288              CMP      r0,r1
000402  d013              BEQ      |L1.1068|
;;;664                        OSTCBHighRdy  = OSTCBPrioTbl[OSPrioHighRdy];
000404  480c              LDR      r0,|L1.1080|
000406  491e              LDR      r1,|L1.1152|
000408  7809              LDRB     r1,[r1,#0]  ; OSPrioHighRdy
00040a  f8500021          LDR      r0,[r0,r1,LSL #2]
00040e  491d              LDR      r1,|L1.1156|
000410  6008              STR      r0,[r1,#0]  ; OSTCBHighRdy
;;;665    #if OS_TASK_PROFILE_EN > 0
;;;666                        OSTCBHighRdy->OSTCBCtxSwCtr++;         /* Inc. # of context switches to this task  */
000412  4608              MOV      r0,r1
000414  6800              LDR      r0,[r0,#0]  ; OSTCBHighRdy
000416  6b40              LDR      r0,[r0,#0x34]
000418  1c40              ADDS     r0,r0,#1
00041a  6809              LDR      r1,[r1,#0]  ; OSTCBHighRdy
00041c  6348              STR      r0,[r1,#0x34]
;;;667    #endif
;;;668                        OSCtxSwCtr++;                          /* Keep track of the number of ctx switches */
00041e  481f              LDR      r0,|L1.1180|
000420  6800              LDR      r0,[r0,#0]  ; OSCtxSwCtr
000422  1c40              ADDS     r0,r0,#1
000424  491d              LDR      r1,|L1.1180|
000426  6008              STR      r0,[r1,#0]  ; OSCtxSwCtr
;;;669                        OSIntCtxSw();                          /* Perform interrupt level ctx switch       */
000428  f7fffffe          BL       OSIntCtxSw
                  |L1.1068|
;;;670                    }
;;;671                }
;;;672            }
;;;673            OS_EXIT_CRITICAL();
00042c  4620              MOV      r0,r4
00042e  f7fffffe          BL       OS_CPU_SR_Restore
                  |L1.1074|
;;;674        }
;;;675    }
000432  bd10              POP      {r4,pc}
                  |L1.1076|
                          DCD      OSIntNesting
                  |L1.1080|
                          DCD      OSTCBPrioTbl
                  |L1.1084|
                          DCD      OSStatRdy
                  |L1.1088|
                          DCD      OSIdleCtrMax
                  |L1.1092|
                          DCD      OSCPUUsage
                  |L1.1096|
                          DCD      OSIdleCtr
                  |L1.1100|
                          DCD      OSIdleCtrRun
                  |L1.1104|
                          DCD      OSTaskStatStk
                  |L1.1108|
                          DCD      OSTaskStatStk+0x1fc
                  |L1.1112|
                          DCD      OSTaskIdleStk
                  |L1.1116|
                          DCD      OSTaskIdleStk+0x1fc
                  |L1.1120|
                          DCD      OSEventTbl
                  |L1.1124|
                          DCD      OSEventFreeList
                  |L1.1128|
                          DCD      OSTCBTbl
                  |L1.1132|
                          DCD      OSTCBList
                  |L1.1136|
                          DCD      OSTCBFreeList
                  |L1.1140|
                          DCD      OSRdyGrp
                  |L1.1144|
                          DCD      OSRdyTbl
                  |L1.1148|
                          DCD      OSPrioCur
                  |L1.1152|
                          DCD      OSPrioHighRdy
                  |L1.1156|
                          DCD      OSTCBHighRdy
                  |L1.1160|
                          DCD      OSTCBCur
                  |L1.1164|
                          DCD      OSTime
                  |L1.1168|
                          DCD      OSLockNesting
                  |L1.1172|
                          DCD      OSTaskCtr
                  |L1.1176|
                          DCD      OSRunning
                  |L1.1180|
                          DCD      OSCtxSwCtr
                  |L1.1184|
                          DCD      OSUnMapTbl
                          ENDP

                  OSSchedLock PROC
;;;693    #if OS_SCHED_LOCK_EN > 0
;;;694    void  OSSchedLock (void)
0004a4  b510              PUSH     {r4,lr}
;;;695    {
;;;696    #if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
;;;697        OS_CPU_SR  cpu_sr = 0;
0004a6  2400              MOVS     r4,#0
;;;698    #endif
;;;699    
;;;700    
;;;701    
;;;702        if (OSRunning == OS_TRUE) {                  /* Make sure multitasking is running                  */
0004a8  48fe              LDR      r0,|L1.2212|
0004aa  7800              LDRB     r0,[r0,#0]  ; OSRunning
0004ac  2801              CMP      r0,#1
0004ae  d111              BNE      |L1.1236|
;;;703            OS_ENTER_CRITICAL();
0004b0  f7fffffe          BL       OS_CPU_SR_Save
0004b4  4604              MOV      r4,r0
;;;704            if (OSIntNesting == 0) {                 /* Can't call from an ISR                             */
0004b6  48fc              LDR      r0,|L1.2216|
0004b8  7800              LDRB     r0,[r0,#0]  ; OSIntNesting
0004ba  b940              CBNZ     r0,|L1.1230|
;;;705                if (OSLockNesting < 255u) {          /* Prevent OSLockNesting from wrapping back to 0      */
0004bc  48fb              LDR      r0,|L1.2220|
0004be  7800              LDRB     r0,[r0,#0]  ; OSLockNesting
0004c0  28ff              CMP      r0,#0xff
0004c2  d204              BCS      |L1.1230|
;;;706                    OSLockNesting++;                 /* Increment lock nesting level                       */
0004c4  48f9              LDR      r0,|L1.2220|
0004c6  7800              LDRB     r0,[r0,#0]  ; OSLockNesting
0004c8  1c40              ADDS     r0,r0,#1
0004ca  49f8              LDR      r1,|L1.2220|
0004cc  7008              STRB     r0,[r1,#0]
                  |L1.1230|
;;;707                }
;;;708            }
;;;709            OS_EXIT_CRITICAL();
0004ce  4620              MOV      r0,r4
0004d0  f7fffffe          BL       OS_CPU_SR_Restore
                  |L1.1236|
;;;710        }
;;;711    }
0004d4  bd10              POP      {r4,pc}
;;;712    #endif
                          ENDP

                  OS_Sched PROC
;;;1605   
;;;1606   void  OS_Sched (void)
0004d6  b510              PUSH     {r4,lr}
;;;1607   {
;;;1608   #if OS_CRITICAL_METHOD == 3                            /* Allocate storage for CPU status register     */
;;;1609       OS_CPU_SR  cpu_sr = 0;
0004d8  2400              MOVS     r4,#0
;;;1610   #endif
;;;1611   
;;;1612   
;;;1613   
;;;1614       OS_ENTER_CRITICAL();
0004da  f7fffffe          BL       OS_CPU_SR_Save
0004de  4604              MOV      r4,r0
;;;1615       if (OSIntNesting == 0) {                           /* Schedule only if all ISRs done and ...       */
0004e0  48f1              LDR      r0,|L1.2216|
0004e2  7800              LDRB     r0,[r0,#0]  ; OSIntNesting
0004e4  b9f0              CBNZ     r0,|L1.1316|
;;;1616           if (OSLockNesting == 0) {                      /* ... scheduler is not locked                  */
0004e6  48f1              LDR      r0,|L1.2220|
0004e8  7800              LDRB     r0,[r0,#0]  ; OSLockNesting
0004ea  b9d8              CBNZ     r0,|L1.1316|
;;;1617               OS_SchedNew();
0004ec  f7fffffe          BL       OS_SchedNew
;;;1618               if (OSPrioHighRdy != OSPrioCur) {          /* No Ctx Sw if current task is highest rdy     */
0004f0  48ef              LDR      r0,|L1.2224|
0004f2  7800              LDRB     r0,[r0,#0]  ; OSPrioHighRdy
0004f4  49ef              LDR      r1,|L1.2228|
0004f6  7809              LDRB     r1,[r1,#0]  ; OSPrioCur
0004f8  4288              CMP      r0,r1
0004fa  d013              BEQ      |L1.1316|
;;;1619                   OSTCBHighRdy = OSTCBPrioTbl[OSPrioHighRdy];
0004fc  48ee              LDR      r0,|L1.2232|
0004fe  49ec              LDR      r1,|L1.2224|
000500  7809              LDRB     r1,[r1,#0]  ; OSPrioHighRdy
000502  f8500021          LDR      r0,[r0,r1,LSL #2]
000506  49ed              LDR      r1,|L1.2236|
000508  6008              STR      r0,[r1,#0]  ; OSTCBHighRdy
;;;1620   #if OS_TASK_PROFILE_EN > 0
;;;1621                   OSTCBHighRdy->OSTCBCtxSwCtr++;         /* Inc. # of context switches to this task      */
00050a  4608              MOV      r0,r1
00050c  6800              LDR      r0,[r0,#0]  ; OSTCBHighRdy
00050e  6b40              LDR      r0,[r0,#0x34]
000510  1c40              ADDS     r0,r0,#1
000512  6809              LDR      r1,[r1,#0]  ; OSTCBHighRdy
000514  6348              STR      r0,[r1,#0x34]
;;;1622   #endif
;;;1623                   OSCtxSwCtr++;                          /* Increment context switch counter             */
000516  48ea              LDR      r0,|L1.2240|
000518  6800              LDR      r0,[r0,#0]  ; OSCtxSwCtr
00051a  1c40              ADDS     r0,r0,#1
00051c  49e8              LDR      r1,|L1.2240|
00051e  6008              STR      r0,[r1,#0]  ; OSCtxSwCtr
;;;1624                   OS_TASK_SW();                          /* Perform a context switch                     */
000520  f7fffffe          BL       OSCtxSw
                  |L1.1316|
;;;1625               }
;;;1626           }
;;;1627       }
;;;1628       OS_EXIT_CRITICAL();
000524  4620              MOV      r0,r4
000526  f7fffffe          BL       OS_CPU_SR_Restore
;;;1629   }
00052a  bd10              POP      {r4,pc}
;;;1630   
                          ENDP

                  OSSchedUnlock PROC
;;;730    #if OS_SCHED_LOCK_EN > 0
;;;731    void  OSSchedUnlock (void)
00052c  b510              PUSH     {r4,lr}
;;;732    {
;;;733    #if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
;;;734        OS_CPU_SR  cpu_sr = 0;
00052e  2400              MOVS     r4,#0
;;;735    #endif
;;;736    
;;;737    
;;;738    
;;;739        if (OSRunning == OS_TRUE) {                            /* Make sure multitasking is running        */
000530  48dc              LDR      r0,|L1.2212|
000532  7800              LDRB     r0,[r0,#0]  ; OSRunning
000534  2801              CMP      r0,#1
000536  d122              BNE      |L1.1406|
;;;740            OS_ENTER_CRITICAL();
000538  f7fffffe          BL       OS_CPU_SR_Save
00053c  4604              MOV      r4,r0
;;;741            if (OSLockNesting > 0) {                           /* Do not decrement if already 0            */
00053e  48db              LDR      r0,|L1.2220|
000540  7800              LDRB     r0,[r0,#0]  ; OSLockNesting
000542  2800              CMP      r0,#0
000544  dd18              BLE      |L1.1400|
;;;742                OSLockNesting--;                               /* Decrement lock nesting level             */
000546  48d9              LDR      r0,|L1.2220|
000548  7800              LDRB     r0,[r0,#0]  ; OSLockNesting
00054a  1e40              SUBS     r0,r0,#1
00054c  49d7              LDR      r1,|L1.2220|
00054e  7008              STRB     r0,[r1,#0]
;;;743                if (OSLockNesting == 0) {                      /* See if scheduler is enabled and ...      */
000550  4608              MOV      r0,r1
000552  7800              LDRB     r0,[r0,#0]  ; OSLockNesting
000554  b960              CBNZ     r0,|L1.1392|
;;;744                    if (OSIntNesting == 0) {                   /* ... not in an ISR                        */
000556  48d4              LDR      r0,|L1.2216|
000558  7800              LDRB     r0,[r0,#0]  ; OSIntNesting
00055a  b928              CBNZ     r0,|L1.1384|
;;;745                        OS_EXIT_CRITICAL();
00055c  4620              MOV      r0,r4
00055e  f7fffffe          BL       OS_CPU_SR_Restore
;;;746                        OS_Sched();                            /* See if a HPT is ready                    */
000562  f7fffffe          BL       OS_Sched
000566  e00a              B        |L1.1406|
                  |L1.1384|
;;;747                    } else {
;;;748                        OS_EXIT_CRITICAL();
000568  4620              MOV      r0,r4
00056a  f7fffffe          BL       OS_CPU_SR_Restore
00056e  e006              B        |L1.1406|
                  |L1.1392|
;;;749                    }
;;;750                } else {
;;;751                    OS_EXIT_CRITICAL();
000570  4620              MOV      r0,r4
000572  f7fffffe          BL       OS_CPU_SR_Restore
000576  e002              B        |L1.1406|
                  |L1.1400|
;;;752                }
;;;753            } else {
;;;754                OS_EXIT_CRITICAL();
000578  4620              MOV      r0,r4
00057a  f7fffffe          BL       OS_CPU_SR_Restore
                  |L1.1406|
;;;755            }
;;;756        }
;;;757    }
00057e  bd10              POP      {r4,pc}
;;;758    #endif
                          ENDP

                  OSStart PROC
;;;780    
;;;781    void  OSStart (void)
000580  b510              PUSH     {r4,lr}
;;;782    {
;;;783        if (OSRunning == OS_FALSE) {
000582  48c8              LDR      r0,|L1.2212|
000584  7800              LDRB     r0,[r0,#0]  ; OSRunning
000586  b990              CBNZ     r0,|L1.1454|
;;;784            OS_SchedNew();                               /* Find highest priority's task priority number   */
000588  f7fffffe          BL       OS_SchedNew
;;;785            OSPrioCur     = OSPrioHighRdy;
00058c  48c8              LDR      r0,|L1.2224|
00058e  7800              LDRB     r0,[r0,#0]  ; OSPrioHighRdy
000590  49c8              LDR      r1,|L1.2228|
000592  7008              STRB     r0,[r1,#0]
;;;786            OSTCBHighRdy  = OSTCBPrioTbl[OSPrioHighRdy]; /* Point to highest priority task ready to run    */
000594  48c8              LDR      r0,|L1.2232|
000596  49c6              LDR      r1,|L1.2224|
000598  7809              LDRB     r1,[r1,#0]  ; OSPrioHighRdy
00059a  f8500021          LDR      r0,[r0,r1,LSL #2]
00059e  49c7              LDR      r1,|L1.2236|
0005a0  6008              STR      r0,[r1,#0]  ; OSTCBHighRdy
;;;787            OSTCBCur      = OSTCBHighRdy;
0005a2  4608              MOV      r0,r1
0005a4  6800              LDR      r0,[r0,#0]  ; OSTCBHighRdy
0005a6  49c7              LDR      r1,|L1.2244|
0005a8  6008              STR      r0,[r1,#0]  ; OSTCBCur
;;;788            OSStartHighRdy();                            /* Execute target specific code to start task     */
0005aa  f7fffffe          BL       OSStartHighRdy
                  |L1.1454|
;;;789        }
;;;790    }
0005ae  bd10              POP      {r4,pc}
;;;791    /*$PAGE*/
                          ENDP

                  OSStatInit PROC
;;;812    #if OS_TASK_STAT_EN > 0
;;;813    void  OSStatInit (void)
0005b0  b510              PUSH     {r4,lr}
;;;814    {
;;;815    #if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
;;;816        OS_CPU_SR  cpu_sr = 0;
0005b2  2400              MOVS     r4,#0
;;;817    #endif
;;;818    
;;;819    
;;;820    
;;;821        OSTimeDly(2);                                /* Synchronize with clock tick                        */
0005b4  2002              MOVS     r0,#2
0005b6  f7fffffe          BL       OSTimeDly
;;;822        OS_ENTER_CRITICAL();
0005ba  f7fffffe          BL       OS_CPU_SR_Save
0005be  4604              MOV      r4,r0
;;;823        OSIdleCtr    = 0L;                           /* Clear idle counter                                 */
0005c0  2000              MOVS     r0,#0
0005c2  49c1              LDR      r1,|L1.2248|
0005c4  6008              STR      r0,[r1,#0]  ; OSIdleCtr
;;;824        OS_EXIT_CRITICAL();
0005c6  4620              MOV      r0,r4
0005c8  f7fffffe          BL       OS_CPU_SR_Restore
;;;825        OSTimeDly(OS_TICKS_PER_SEC / 10);            /* Determine MAX. idle counter value for 1/10 second  */
0005cc  2064              MOVS     r0,#0x64
0005ce  f7fffffe          BL       OSTimeDly
;;;826        OS_ENTER_CRITICAL();
0005d2  f7fffffe          BL       OS_CPU_SR_Save
0005d6  4604              MOV      r4,r0
;;;827        OSIdleCtrMax = OSIdleCtr;                    /* Store maximum idle counter count in 1/10 second    */
0005d8  48bb              LDR      r0,|L1.2248|
0005da  6800              LDR      r0,[r0,#0]  ; OSIdleCtr
0005dc  49bb              LDR      r1,|L1.2252|
0005de  6008              STR      r0,[r1,#0]  ; OSIdleCtrMax
;;;828        OSStatRdy    = OS_TRUE;
0005e0  2001              MOVS     r0,#1
0005e2  49bb              LDR      r1,|L1.2256|
0005e4  7008              STRB     r0,[r1,#0]
;;;829        OS_EXIT_CRITICAL();
0005e6  4620              MOV      r0,r4
0005e8  f7fffffe          BL       OS_CPU_SR_Restore
;;;830    }
0005ec  bd10              POP      {r4,pc}
;;;831    #endif
                          ENDP

                  OSTimeTick PROC
;;;846    
;;;847    void  OSTimeTick (void)
0005ee  b570              PUSH     {r4-r6,lr}
;;;848    {
;;;849        OS_TCB    *ptcb;
;;;850    #if OS_TICK_STEP_EN > 0
;;;851        BOOLEAN    step;
;;;852    #endif
;;;853    #if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register     */
;;;854        OS_CPU_SR  cpu_sr = 0;
0005f0  2600              MOVS     r6,#0
;;;855    #endif
;;;856    
;;;857    
;;;858    
;;;859    #if OS_TIME_TICK_HOOK_EN > 0
;;;860        OSTimeTickHook();                                      /* Call user definable hook                     */
0005f2  f7fffffe          BL       OSTimeTickHook
;;;861    #endif
;;;862    #if OS_TIME_GET_SET_EN > 0
;;;863        OS_ENTER_CRITICAL();                                   /* Update the 32-bit tick counter               */
0005f6  f7fffffe          BL       OS_CPU_SR_Save
0005fa  4606              MOV      r6,r0
;;;864        OSTime++;
0005fc  48b5              LDR      r0,|L1.2260|
0005fe  6800              LDR      r0,[r0,#0]  ; OSTime
000600  1c40              ADDS     r0,r0,#1
000602  49b4              LDR      r1,|L1.2260|
000604  6008              STR      r0,[r1,#0]  ; OSTime
;;;865        OS_EXIT_CRITICAL();
000606  4630              MOV      r0,r6
000608  f7fffffe          BL       OS_CPU_SR_Restore
;;;866    #endif
;;;867        if (OSRunning == OS_TRUE) {
00060c  48a5              LDR      r0,|L1.2212|
00060e  7800              LDRB     r0,[r0,#0]  ; OSRunning
000610  2801              CMP      r0,#1
000612  d153              BNE      |L1.1724|
;;;868    #if OS_TICK_STEP_EN > 0
;;;869            switch (OSTickStepState) {                         /* Determine whether we need to process a tick  */
000614  48b0              LDR      r0,|L1.2264|
000616  7800              LDRB     r0,[r0,#0]  ; OSTickStepState
000618  b120              CBZ      r0,|L1.1572|
00061a  2801              CMP      r0,#1
00061c  d004              BEQ      |L1.1576|
00061e  2802              CMP      r0,#2
000620  d109              BNE      |L1.1590|
000622  e003              B        |L1.1580|
                  |L1.1572|
;;;870                case OS_TICK_STEP_DIS:                         /* Yes, stepping is disabled                    */
;;;871                     step = OS_TRUE;
000624  2501              MOVS     r5,#1
;;;872                     break;
000626  e00b              B        |L1.1600|
                  |L1.1576|
;;;873    
;;;874                case OS_TICK_STEP_WAIT:                        /* No,  waiting for uC/OS-View to set ...       */
;;;875                     step = OS_FALSE;                          /*      .. OSTickStepState to OS_TICK_STEP_ONCE */
000628  2500              MOVS     r5,#0
;;;876                     break;
00062a  e009              B        |L1.1600|
                  |L1.1580|
;;;877    
;;;878                case OS_TICK_STEP_ONCE:                        /* Yes, process tick once and wait for next ... */
;;;879                     step            = OS_TRUE;                /*      ... step command from uC/OS-View        */
00062c  2501              MOVS     r5,#1
;;;880                     OSTickStepState = OS_TICK_STEP_WAIT;
00062e  2001              MOVS     r0,#1
000630  49a9              LDR      r1,|L1.2264|
000632  7008              STRB     r0,[r1,#0]
;;;881                     break;
000634  e004              B        |L1.1600|
                  |L1.1590|
;;;882    
;;;883                default:                                       /* Invalid case, correct situation              */
;;;884                     step            = OS_TRUE;
000636  2501              MOVS     r5,#1
;;;885                     OSTickStepState = OS_TICK_STEP_DIS;
000638  2000              MOVS     r0,#0
00063a  49a7              LDR      r1,|L1.2264|
00063c  7008              STRB     r0,[r1,#0]
;;;886                     break;
00063e  bf00              NOP      
                  |L1.1600|
000640  bf00              NOP                            ;872
;;;887            }
;;;888            if (step == OS_FALSE) {                            /* Return if waiting for step command           */
000642  b905              CBNZ     r5,|L1.1606|
                  |L1.1604|
;;;889                return;
;;;890            }
;;;891    #endif
;;;892            ptcb = OSTCBList;                                  /* Point at first TCB in TCB list               */
;;;893            while (ptcb->OSTCBPrio != OS_TASK_IDLE_PRIO) {     /* Go through all TCBs in TCB list              */
;;;894                OS_ENTER_CRITICAL();
;;;895                if (ptcb->OSTCBDly != 0) {                     /* No, Delayed or waiting for event with TO     */
;;;896                    if (--ptcb->OSTCBDly == 0) {               /* Decrement nbr of ticks to end of delay       */
;;;897                                                               /* Check for timeout                            */
;;;898                        if ((ptcb->OSTCBStat & OS_STAT_PEND_ANY) != OS_STAT_RDY) {
;;;899                            ptcb->OSTCBStat  &= ~(INT8U)OS_STAT_PEND_ANY;          /* Yes, Clear status flag   */
;;;900                            ptcb->OSTCBStatPend = OS_STAT_PEND_TO;                 /* Indicate PEND timeout    */
;;;901                        } else {
;;;902                            ptcb->OSTCBStatPend = OS_STAT_PEND_OK;
;;;903                        }
;;;904    
;;;905                        if ((ptcb->OSTCBStat & OS_STAT_SUSPEND) == OS_STAT_RDY) {  /* Is task suspended?       */
;;;906                            OSRdyGrp               |= ptcb->OSTCBBitY;             /* No,  Make ready          */
;;;907                            OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
;;;908                        }
;;;909                    }
;;;910                }
;;;911                ptcb = ptcb->OSTCBNext;                        /* Point at next TCB in TCB list                */
;;;912                OS_EXIT_CRITICAL();
;;;913            }
;;;914        }
;;;915    }
000644  bd70              POP      {r4-r6,pc}
                  |L1.1606|
000646  48a5              LDR      r0,|L1.2268|
000648  6804              LDR      r4,[r0,#0]            ;892  ; OSTCBList
00064a  e033              B        |L1.1716|
                  |L1.1612|
00064c  f7fffffe          BL       OS_CPU_SR_Save
000650  4606              MOV      r6,r0                 ;894
000652  8d60              LDRH     r0,[r4,#0x2a]         ;895
000654  b350              CBZ      r0,|L1.1708|
000656  8d60              LDRH     r0,[r4,#0x2a]         ;896
000658  1e40              SUBS     r0,r0,#1              ;896
00065a  b280              UXTH     r0,r0                 ;896
00065c  8560              STRH     r0,[r4,#0x2a]         ;896
00065e  bb28              CBNZ     r0,|L1.1708|
000660  f894002c          LDRB     r0,[r4,#0x2c]         ;898
000664  f0000037          AND      r0,r0,#0x37           ;898
000668  b140              CBZ      r0,|L1.1660|
00066a  f8140f2c          LDRB     r0,[r4,#0x2c]!        ;899
00066e  f0200037          BIC      r0,r0,#0x37           ;899
000672  7020              STRB     r0,[r4,#0]            ;899
000674  2001              MOVS     r0,#1                 ;900
000676  7060              STRB     r0,[r4,#1]            ;900
000678  3c2c              SUBS     r4,r4,#0x2c           ;900
00067a  e002              B        |L1.1666|
                  |L1.1660|
00067c  2000              MOVS     r0,#0                 ;902
00067e  f884002d          STRB     r0,[r4,#0x2d]         ;902
                  |L1.1666|
000682  f894002c          LDRB     r0,[r4,#0x2c]         ;905
000686  f0000008          AND      r0,r0,#8              ;905
00068a  b978              CBNZ     r0,|L1.1708|
00068c  3430              ADDS     r4,r4,#0x30           ;906
00068e  78a0              LDRB     r0,[r4,#2]            ;906
000690  4993              LDR      r1,|L1.2272|
000692  7809              LDRB     r1,[r1,#0]            ;906  ; OSRdyGrp
000694  4308              ORRS     r0,r0,r1              ;906
000696  4992              LDR      r1,|L1.2272|
000698  7008              STRB     r0,[r1,#0]            ;906
00069a  7820              LDRB     r0,[r4,#0]            ;907
00069c  4991              LDR      r1,|L1.2276|
00069e  5c08              LDRB     r0,[r1,r0]            ;907
0006a0  7861              LDRB     r1,[r4,#1]            ;907
0006a2  4308              ORRS     r0,r0,r1              ;907
0006a4  f8141930          LDRB     r1,[r4],#-0x30        ;907
0006a8  4a8e              LDR      r2,|L1.2276|
0006aa  5450              STRB     r0,[r2,r1]            ;907
                  |L1.1708|
0006ac  6964              LDR      r4,[r4,#0x14]         ;911
0006ae  4630              MOV      r0,r6                 ;912
0006b0  f7fffffe          BL       OS_CPU_SR_Restore
                  |L1.1716|
0006b4  f894002e          LDRB     r0,[r4,#0x2e]         ;893
0006b8  281e              CMP      r0,#0x1e              ;893
0006ba  d1c7              BNE      |L1.1612|
                  |L1.1724|
0006bc  bf00              NOP      
0006be  e7c1              B        |L1.1604|
;;;916    
                          ENDP

                  OSVersion PROC
;;;931    
;;;932    INT16U  OSVersion (void)
0006c0  f44f708f          MOV      r0,#0x11e
;;;933    {
;;;934        return (OS_VERSION);
;;;935    }
0006c4  4770              BX       lr
;;;936    
                          ENDP

                  OS_Dummy PROC
;;;950    #if OS_TASK_DEL_EN > 0
;;;951    void  OS_Dummy (void)
0006c6  4770              BX       lr
;;;952    {
;;;953    }
;;;954    #endif
                          ENDP

                  OS_EventTaskRemove PROC
;;;1133   #if (OS_EVENT_EN)
;;;1134   void  OS_EventTaskRemove (OS_TCB   *ptcb,
0006c8  b510              PUSH     {r4,lr}
;;;1135                             OS_EVENT *pevent)
;;;1136   {
;;;1137       INT8U  y;
;;;1138   
;;;1139   
;;;1140       y                       =  ptcb->OSTCBY;
0006ca  f8902030          LDRB     r2,[r0,#0x30]
;;;1141       pevent->OSEventTbl[y]  &= ~ptcb->OSTCBBitX;         /* Remove task from wait list                  */
0006ce  f101030b          ADD      r3,r1,#0xb
0006d2  5c9b              LDRB     r3,[r3,r2]
0006d4  f8904031          LDRB     r4,[r0,#0x31]
0006d8  43a3              BICS     r3,r3,r4
0006da  f101040b          ADD      r4,r1,#0xb
0006de  54a3              STRB     r3,[r4,r2]
;;;1142       if (pevent->OSEventTbl[y] == 0) {
0006e0  4623              MOV      r3,r4
0006e2  5c9b              LDRB     r3,[r3,r2]
0006e4  b923              CBNZ     r3,|L1.1776|
;;;1143           pevent->OSEventGrp &= ~ptcb->OSTCBBitY;
0006e6  7a8b              LDRB     r3,[r1,#0xa]
0006e8  f8904032          LDRB     r4,[r0,#0x32]
0006ec  43a3              BICS     r3,r3,r4
0006ee  728b              STRB     r3,[r1,#0xa]
                  |L1.1776|
;;;1144       }
;;;1145   }
0006f0  bd10              POP      {r4,pc}
;;;1146   #endif
                          ENDP

                  OS_EventTaskRdy PROC
;;;984    #if (OS_EVENT_EN)
;;;985    INT8U  OS_EventTaskRdy (OS_EVENT *pevent, void *pmsg, INT8U msk, INT8U pend_stat)
0006f2  e92d4ff0          PUSH     {r4-r11,lr}
;;;986    {
0006f6  4605              MOV      r5,r0
0006f8  460f              MOV      r7,r1
0006fa  4690              MOV      r8,r2
0006fc  4699              MOV      r9,r3
;;;987        OS_TCB  *ptcb;
;;;988        INT8U    y;
;;;989        INT8U    x;
;;;990        INT8U    prio;
;;;991    #if OS_LOWEST_PRIO > 63
;;;992        INT16U  *ptbl;
;;;993    #endif
;;;994    
;;;995    
;;;996    #if OS_LOWEST_PRIO <= 63
;;;997        y    = OSUnMapTbl[pevent->OSEventGrp];              /* Find HPT waiting for message                */
0006fe  7aa8              LDRB     r0,[r5,#0xa]
000700  4979              LDR      r1,|L1.2280|
000702  5c0e              LDRB     r6,[r1,r0]
;;;998        x    = OSUnMapTbl[pevent->OSEventTbl[y]];
000704  f105000b          ADD      r0,r5,#0xb
000708  5d80              LDRB     r0,[r0,r6]
00070a  f811b000          LDRB     r11,[r1,r0]
;;;999        prio = (INT8U)((y << 3) + x);                       /* Find priority of task getting the msg       */
00070e  eb0b00c6          ADD      r0,r11,r6,LSL #3
000712  f0000aff          AND      r10,r0,#0xff
;;;1000   #else
;;;1001       if ((pevent->OSEventGrp & 0xFF) != 0) {             /* Find HPT waiting for message                */
;;;1002           y = OSUnMapTbl[ pevent->OSEventGrp & 0xFF];
;;;1003       } else {
;;;1004           y = OSUnMapTbl[(pevent->OSEventGrp >> 8) & 0xFF] + 8;
;;;1005       }
;;;1006       ptbl = &pevent->OSEventTbl[y];
;;;1007       if ((*ptbl & 0xFF) != 0) {
;;;1008           x = OSUnMapTbl[*ptbl & 0xFF];
;;;1009       } else {
;;;1010           x = OSUnMapTbl[(*ptbl >> 8) & 0xFF] + 8;
;;;1011       }
;;;1012       prio = (INT8U)((y << 4) + x);                       /* Find priority of task getting the msg       */
;;;1013   #endif
;;;1014   
;;;1015       ptcb                  =  OSTCBPrioTbl[prio];        /* Point to this task's OS_TCB                 */
000716  4868              LDR      r0,|L1.2232|
000718  f850402a          LDR      r4,[r0,r10,LSL #2]
;;;1016       ptcb->OSTCBDly        =  0;                         /* Prevent OSTimeTick() from readying task     */
00071c  2000              MOVS     r0,#0
00071e  3420              ADDS     r4,r4,#0x20
000720  8160              STRH     r0,[r4,#0xa]
;;;1017   #if ((OS_Q_EN > 0) && (OS_MAX_QS > 0)) || (OS_MBOX_EN > 0)
;;;1018       ptcb->OSTCBMsg        =  pmsg;                      /* Send message directly to waiting task       */
000722  6027              STR      r7,[r4,#0]
;;;1019   #else
;;;1020       pmsg                  =  pmsg;                      /* Prevent compiler warning if not used        */
;;;1021   #endif
;;;1022       ptcb->OSTCBStat      &= ~msk;                       /* Clear bit associated with event type        */
000724  7b20              LDRB     r0,[r4,#0xc]
000726  ea200008          BIC      r0,r0,r8
00072a  7320              STRB     r0,[r4,#0xc]
;;;1023       ptcb->OSTCBStatPend   =  pend_stat;                 /* Set pend status of post or abort            */
00072c  f884900d          STRB     r9,[r4,#0xd]
;;;1024                                                           /* See if task is ready (could be susp'd)      */
;;;1025       if ((ptcb->OSTCBStat &   OS_STAT_SUSPEND) == OS_STAT_RDY) {
000730  7b20              LDRB     r0,[r4,#0xc]
000732  3c20              SUBS     r4,r4,#0x20
000734  f0000008          AND      r0,r0,#8
000738  b968              CBNZ     r0,|L1.1878|
;;;1026           OSRdyGrp         |=  ptcb->OSTCBBitY;           /* Put task in the ready to run list           */
00073a  f8940032          LDRB     r0,[r4,#0x32]
00073e  4968              LDR      r1,|L1.2272|
000740  7809              LDRB     r1,[r1,#0]  ; OSRdyGrp
000742  4308              ORRS     r0,r0,r1
000744  4966              LDR      r1,|L1.2272|
000746  7008              STRB     r0,[r1,#0]
;;;1027           OSRdyTbl[y]      |=  ptcb->OSTCBBitX;
000748  4866              LDR      r0,|L1.2276|
00074a  5d80              LDRB     r0,[r0,r6]
00074c  f8941031          LDRB     r1,[r4,#0x31]
000750  4308              ORRS     r0,r0,r1
000752  4964              LDR      r1,|L1.2276|
000754  5588              STRB     r0,[r1,r6]
                  |L1.1878|
;;;1028       }
;;;1029   
;;;1030       OS_EventTaskRemove(ptcb, pevent);                   /* Remove this task from event   wait list     */
000756  4629              MOV      r1,r5
000758  4620              MOV      r0,r4
00075a  f7fffffe          BL       OS_EventTaskRemove
;;;1031   #if (OS_EVENT_MULTI_EN > 0)
;;;1032       if (ptcb->OSTCBEventMultiPtr != (OS_EVENT **)0) {   /* Remove this task from events' wait lists    */
;;;1033           OS_EventTaskRemoveMulti(ptcb, ptcb->OSTCBEventMultiPtr);
;;;1034           ptcb->OSTCBEventPtr       = (OS_EVENT  *)pevent;/* Return event as first multi-pend event ready*/
;;;1035       }
;;;1036   #endif
;;;1037   
;;;1038       return (prio);
00075e  4650              MOV      r0,r10
;;;1039   }
000760  e8bd8ff0          POP      {r4-r11,pc}
;;;1040   #endif
                          ENDP

                  OS_EventTaskWait PROC
;;;1056   #if (OS_EVENT_EN)
;;;1057   void  OS_EventTaskWait (OS_EVENT *pevent)
000764  b510              PUSH     {r4,lr}
;;;1058   {
;;;1059       INT8U  y;
;;;1060   
;;;1061   
;;;1062       OSTCBCur->OSTCBEventPtr               = pevent;                 /* Store ptr to ECB in TCB         */
000766  4a57              LDR      r2,|L1.2244|
000768  6812              LDR      r2,[r2,#0]  ; OSTCBCur
00076a  61d0              STR      r0,[r2,#0x1c]
;;;1063   
;;;1064       pevent->OSEventTbl[OSTCBCur->OSTCBY] |= OSTCBCur->OSTCBBitX;    /* Put task in waiting list        */
00076c  4a55              LDR      r2,|L1.2244|
00076e  6812              LDR      r2,[r2,#0]  ; OSTCBCur
000770  f8923030          LDRB     r3,[r2,#0x30]
000774  f100020b          ADD      r2,r0,#0xb
000778  5cd2              LDRB     r2,[r2,r3]
00077a  4b52              LDR      r3,|L1.2244|
00077c  681b              LDR      r3,[r3,#0]  ; OSTCBCur
00077e  f8933031          LDRB     r3,[r3,#0x31]
000782  431a              ORRS     r2,r2,r3
000784  4b4f              LDR      r3,|L1.2244|
000786  681b              LDR      r3,[r3,#0]  ; OSTCBCur
000788  f8934030          LDRB     r4,[r3,#0x30]
00078c  f100030b          ADD      r3,r0,#0xb
000790  551a              STRB     r2,[r3,r4]
;;;1065       pevent->OSEventGrp                   |= OSTCBCur->OSTCBBitY;
000792  7a82              LDRB     r2,[r0,#0xa]
000794  4b4b              LDR      r3,|L1.2244|
000796  681b              LDR      r3,[r3,#0]  ; OSTCBCur
000798  f8933032          LDRB     r3,[r3,#0x32]
00079c  431a              ORRS     r2,r2,r3
00079e  7282              STRB     r2,[r0,#0xa]
;;;1066   
;;;1067       y             =  OSTCBCur->OSTCBY;            /* Task no longer ready                              */
0007a0  4a48              LDR      r2,|L1.2244|
0007a2  6812              LDR      r2,[r2,#0]  ; OSTCBCur
0007a4  f8921030          LDRB     r1,[r2,#0x30]
;;;1068       OSRdyTbl[y]  &= ~OSTCBCur->OSTCBBitX;
0007a8  4a4e              LDR      r2,|L1.2276|
0007aa  5c52              LDRB     r2,[r2,r1]
0007ac  4b45              LDR      r3,|L1.2244|
0007ae  681b              LDR      r3,[r3,#0]  ; OSTCBCur
0007b0  f8933031          LDRB     r3,[r3,#0x31]
0007b4  439a              BICS     r2,r2,r3
0007b6  4b4b              LDR      r3,|L1.2276|
0007b8  545a              STRB     r2,[r3,r1]
;;;1069       if (OSRdyTbl[y] == 0) {
0007ba  461a              MOV      r2,r3
0007bc  5c52              LDRB     r2,[r2,r1]
0007be  b942              CBNZ     r2,|L1.2002|
;;;1070           OSRdyGrp &= ~OSTCBCur->OSTCBBitY;         /* Clear event grp bit if this was only task pending */
0007c0  4a40              LDR      r2,|L1.2244|
0007c2  6812              LDR      r2,[r2,#0]  ; OSTCBCur
0007c4  f8923032          LDRB     r3,[r2,#0x32]
0007c8  4a45              LDR      r2,|L1.2272|
0007ca  7812              LDRB     r2,[r2,#0]  ; OSRdyGrp
0007cc  439a              BICS     r2,r2,r3
0007ce  4b44              LDR      r3,|L1.2272|
0007d0  701a              STRB     r2,[r3,#0]
                  |L1.2002|
;;;1071       }
;;;1072   }
0007d2  bd10              POP      {r4,pc}
;;;1073   #endif
                          ENDP

                  OS_EventWaitListInit PROC
;;;1208   #if (OS_EVENT_EN)
;;;1209   void  OS_EventWaitListInit (OS_EVENT *pevent)
0007d4  2300              MOVS     r3,#0
;;;1210   {
;;;1211   #if OS_LOWEST_PRIO <= 63
;;;1212       INT8U  *ptbl;
;;;1213   #else
;;;1214       INT16U *ptbl;
;;;1215   #endif
;;;1216       INT8U   i;
;;;1217   
;;;1218   
;;;1219       pevent->OSEventGrp = 0;                      /* No task waiting on event                           */
0007d6  7283              STRB     r3,[r0,#0xa]
;;;1220       ptbl               = &pevent->OSEventTbl[0];
0007d8  f100010b          ADD      r1,r0,#0xb
;;;1221   
;;;1222       for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
0007dc  2200              MOVS     r2,#0
0007de  e004              B        |L1.2026|
                  |L1.2016|
;;;1223           *ptbl++ = 0;
0007e0  2300              MOVS     r3,#0
0007e2  f8013b01          STRB     r3,[r1],#1
0007e6  1c53              ADDS     r3,r2,#1              ;1222
0007e8  b2da              UXTB     r2,r3                 ;1222
                  |L1.2026|
0007ea  2a04              CMP      r2,#4                 ;1222
0007ec  dbf8              BLT      |L1.2016|
;;;1224       }
;;;1225   }
0007ee  4770              BX       lr
;;;1226   #endif
                          ENDP

                  OS_MemCopy PROC
;;;1580   
;;;1581   void  OS_MemCopy (INT8U *pdest, INT8U *psrc, INT16U size)
0007f0  e005              B        |L1.2046|
                  |L1.2034|
;;;1582   {
;;;1583       while (size > 0) {
;;;1584           *pdest++ = *psrc++;
0007f2  f8113b01          LDRB     r3,[r1],#1
0007f6  f8003b01          STRB     r3,[r0],#1
;;;1585           size--;
0007fa  1e53              SUBS     r3,r2,#1
0007fc  b29a              UXTH     r2,r3
                  |L1.2046|
0007fe  2a00              CMP      r2,#0                 ;1583
000800  dcf7              BGT      |L1.2034|
;;;1586       }
;;;1587   }
000802  4770              BX       lr
;;;1588   /*$PAGE*/
                          ENDP

                  OS_TCBInit PROC
;;;1921   
;;;1922   INT8U  OS_TCBInit (INT8U prio, OS_STK *ptos, OS_STK *pbos, INT16U id, INT32U stk_size, void *pext, INT16U opt)
000804  e92d4ff8          PUSH     {r3-r11,lr}
;;;1923   {
000808  4605              MOV      r5,r0
00080a  460e              MOV      r6,r1
00080c  4617              MOV      r7,r2
00080e  4698              MOV      r8,r3
000810  e9ddab0b          LDRD     r10,r11,[sp,#0x2c]
000814  f8dd9028          LDR      r9,[sp,#0x28]
;;;1924       OS_TCB    *ptcb;
;;;1925   #if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
;;;1926       OS_CPU_SR  cpu_sr = 0;
000818  2000              MOVS     r0,#0
00081a  9000              STR      r0,[sp,#0]
;;;1927   #endif
;;;1928   
;;;1929   
;;;1930   
;;;1931       OS_ENTER_CRITICAL();
00081c  f7fffffe          BL       OS_CPU_SR_Save
000820  9000              STR      r0,[sp,#0]
;;;1932       ptcb = OSTCBFreeList;                                  /* Get a free TCB from the free TCB list    */
000822  4832              LDR      r0,|L1.2284|
000824  6804              LDR      r4,[r0,#0]  ; OSTCBFreeList
;;;1933       if (ptcb != (OS_TCB *)0) {
000826  2c00              CMP      r4,#0
000828  d07e              BEQ      |L1.2344|
;;;1934           OSTCBFreeList            = ptcb->OSTCBNext;        /* Update pointer to free TCB list          */
00082a  f8540f14          LDR      r0,[r4,#0x14]!
00082e  492f              LDR      r1,|L1.2284|
000830  6008              STR      r0,[r1,#0]  ; OSTCBFreeList
;;;1935           OS_EXIT_CRITICAL();
000832  9800              LDR      r0,[sp,#0]
000834  f7fffffe          BL       OS_CPU_SR_Restore
;;;1936           ptcb->OSTCBStkPtr        = ptos;                   /* Load Stack pointer in TCB                */
000838  f8446c14          STR      r6,[r4,#-0x14]
;;;1937           ptcb->OSTCBPrio          = prio;                   /* Load task priority into TCB              */
00083c  76a5              STRB     r5,[r4,#0x1a]
;;;1938           ptcb->OSTCBStat          = OS_STAT_RDY;            /* Task is ready to run                     */
00083e  2000              MOVS     r0,#0
000840  7620              STRB     r0,[r4,#0x18]
;;;1939           ptcb->OSTCBStatPend      = OS_STAT_PEND_OK;        /* Clear pend status                        */
000842  7660              STRB     r0,[r4,#0x19]
;;;1940           ptcb->OSTCBDly           = 0;                      /* Task is not delayed                      */
000844  82e0              STRH     r0,[r4,#0x16]
;;;1941   
;;;1942   #if OS_TASK_CREATE_EXT_EN > 0
;;;1943           ptcb->OSTCBExtPtr        = pext;                   /* Store pointer to TCB extension           */
000846  f844ac10          STR      r10,[r4,#-0x10]
;;;1944           ptcb->OSTCBStkSize       = stk_size;               /* Store stack size                         */
00084a  f8449c08          STR      r9,[r4,#-8]
;;;1945           ptcb->OSTCBStkBottom     = pbos;                   /* Store pointer to bottom of stack         */
00084e  f8447c0c          STR      r7,[r4,#-0xc]
;;;1946           ptcb->OSTCBOpt           = opt;                    /* Store task options                       */
000852  f824bc04          STRH     r11,[r4,#-4]
;;;1947           ptcb->OSTCBId            = id;                     /* Store task ID                            */
000856  f8248c02          STRH     r8,[r4,#-2]
;;;1948   #else
;;;1949           pext                     = pext;                   /* Prevent compiler warning if not used     */
;;;1950           stk_size                 = stk_size;
;;;1951           pbos                     = pbos;
;;;1952           opt                      = opt;
;;;1953           id                       = id;
;;;1954   #endif
;;;1955   
;;;1956   #if OS_TASK_DEL_EN > 0
;;;1957           ptcb->OSTCBDelReq        = OS_ERR_NONE;
00085a  77e0              STRB     r0,[r4,#0x1f]
;;;1958   #endif
;;;1959   
;;;1960   #if OS_LOWEST_PRIO <= 63
;;;1961           ptcb->OSTCBY             = (INT8U)(prio >> 3);          /* Pre-compute X, Y, BitX and BitY     */
00085c  10e8              ASRS     r0,r5,#3
00085e  7720              STRB     r0,[r4,#0x1c]
;;;1962           ptcb->OSTCBX             = (INT8U)(prio & 0x07);
000860  f0050007          AND      r0,r5,#7
000864  76e0              STRB     r0,[r4,#0x1b]
;;;1963           ptcb->OSTCBBitY          = (INT8U)(1 << ptcb->OSTCBY);
000866  7f21              LDRB     r1,[r4,#0x1c]
000868  2001              MOVS     r0,#1
00086a  4088              LSLS     r0,r0,r1
00086c  77a0              STRB     r0,[r4,#0x1e]
;;;1964           ptcb->OSTCBBitX          = (INT8U)(1 << ptcb->OSTCBX);
00086e  7ee1              LDRB     r1,[r4,#0x1b]
000870  2001              MOVS     r0,#1
000872  4088              LSLS     r0,r0,r1
000874  7760              STRB     r0,[r4,#0x1d]
;;;1965   #else
;;;1966           ptcb->OSTCBY             = (INT8U)((prio >> 4) & 0xFF); /* Pre-compute X, Y, BitX and BitY     */
;;;1967           ptcb->OSTCBX             = (INT8U) (prio & 0x0F);
;;;1968           ptcb->OSTCBBitY          = (INT16U)(1 << ptcb->OSTCBY);
;;;1969           ptcb->OSTCBBitX          = (INT16U)(1 << ptcb->OSTCBX);
;;;1970   #endif
;;;1971   
;;;1972   #if (OS_EVENT_EN)
;;;1973           ptcb->OSTCBEventPtr      = (OS_EVENT  *)0;         /* Task is not pending on an  event         */
000876  2000              MOVS     r0,#0
000878  60a0              STR      r0,[r4,#8]
;;;1974   #if (OS_EVENT_MULTI_EN > 0)
;;;1975           ptcb->OSTCBEventMultiPtr = (OS_EVENT **)0;         /* Task is not pending on any events        */
;;;1976   #endif
;;;1977   #endif
;;;1978   
;;;1979   #if (OS_FLAG_EN > 0) && (OS_MAX_FLAGS > 0) && (OS_TASK_DEL_EN > 0)
;;;1980           ptcb->OSTCBFlagNode  = (OS_FLAG_NODE *)0;          /* Task is not pending on an event flag     */
00087a  6120              STR      r0,[r4,#0x10]
;;;1981   #endif
;;;1982   
;;;1983   #if (OS_MBOX_EN > 0) || ((OS_Q_EN > 0) && (OS_MAX_QS > 0))
;;;1984           ptcb->OSTCBMsg       = (void *)0;                  /* No message received                      */
00087c  60e0              STR      r0,[r4,#0xc]
;;;1985   #endif
;;;1986   
;;;1987   #if OS_TASK_PROFILE_EN > 0
;;;1988           ptcb->OSTCBCtxSwCtr    = 0L;                       /* Initialize profiling variables           */
00087e  6220              STR      r0,[r4,#0x20]
;;;1989           ptcb->OSTCBCyclesStart = 0L;
000880  62a0              STR      r0,[r4,#0x28]
;;;1990           ptcb->OSTCBCyclesTot   = 0L;
000882  6260              STR      r0,[r4,#0x24]
;;;1991           ptcb->OSTCBStkBase     = (OS_STK *)0;
000884  62e0              STR      r0,[r4,#0x2c]
;;;1992           ptcb->OSTCBStkUsed     = 0L;
000886  6320              STR      r0,[r4,#0x30]
;;;1993   #endif
;;;1994   
;;;1995   #if OS_TASK_NAME_SIZE > 1
;;;1996           ptcb->OSTCBTaskName[0] = '?';                      /* Unknown name at task creation            */
000888  203f              MOVS     r0,#0x3f
00088a  f8840034          STRB     r0,[r4,#0x34]
00088e  3c14              SUBS     r4,r4,#0x14
;;;1997           ptcb->OSTCBTaskName[1] = OS_ASCII_NUL;
000890  2100              MOVS     r1,#0
000892  2049              MOVS     r0,#0x49
000894  5501              STRB     r1,[r0,r4]
;;;1998   #endif
;;;1999   
;;;2000           OSTCBInitHook(ptcb);
000896  4620              MOV      r0,r4
000898  f7fffffe          BL       OSTCBInitHook
;;;2001   
;;;2002           OSTaskCreateHook(ptcb);                            /* Call user defined hook                   */
00089c  4620              MOV      r0,r4
00089e  f7fffffe          BL       OSTaskCreateHook
;;;2003   
;;;2004           OS_ENTER_CRITICAL();
0008a2  e025              B        |L1.2288|
                  |L1.2212|
                          DCD      OSRunning
                  |L1.2216|
                          DCD      OSIntNesting
                  |L1.2220|
                          DCD      OSLockNesting
                  |L1.2224|
                          DCD      OSPrioHighRdy
                  |L1.2228|
                          DCD      OSPrioCur
                  |L1.2232|
                          DCD      OSTCBPrioTbl
                  |L1.2236|
                          DCD      OSTCBHighRdy
                  |L1.2240|
                          DCD      OSCtxSwCtr
                  |L1.2244|
                          DCD      OSTCBCur
                  |L1.2248|
                          DCD      OSIdleCtr
                  |L1.2252|
                          DCD      OSIdleCtrMax
                  |L1.2256|
                          DCD      OSStatRdy
                  |L1.2260|
                          DCD      OSTime
                  |L1.2264|
                          DCD      OSTickStepState
                  |L1.2268|
                          DCD      OSTCBList
                  |L1.2272|
                          DCD      OSRdyGrp
                  |L1.2276|
                          DCD      OSRdyTbl
                  |L1.2280|
                          DCD      OSUnMapTbl
                  |L1.2284|
                          DCD      OSTCBFreeList
                  |L1.2288|
0008f0  f7fffffe          BL       OS_CPU_SR_Save
0008f4  9000              STR      r0,[sp,#0]
;;;2005           OSTCBPrioTbl[prio] = ptcb;
0008f6  4819              LDR      r0,|L1.2396|
0008f8  f8404025          STR      r4,[r0,r5,LSL #2]
;;;2006           ptcb->OSTCBNext    = OSTCBList;                    /* Link into TCB chain                      */
0008fc  4818              LDR      r0,|L1.2400|
0008fe  6800              LDR      r0,[r0,#0]  ; OSTCBList
000900  6160              STR      r0,[r4,#0x14]
;;;2007           ptcb->OSTCBPrev    = (OS_TCB *)0;
000902  2000              MOVS     r0,#0
000904  61a0              STR      r0,[r4,#0x18]
;;;2008           if (OSTCBList != (OS_TCB *)0) {
000906  4816              LDR      r0,|L1.2400|
000908  6800              LDR      r0,[r0,#0]  ; OSTCBList
00090a  b110              CBZ      r0,|L1.2322|
;;;2009               OSTCBList->OSTCBPrev = ptcb;
00090c  4814              LDR      r0,|L1.2400|
00090e  6800              LDR      r0,[r0,#0]  ; OSTCBList
000910  6184              STR      r4,[r0,#0x18]
                  |L1.2322|
;;;2010           }
;;;2011           OSTCBList               = ptcb;
000912  4813              LDR      r0,|L1.2400|
000914  6004              STR      r4,[r0,#0]  ; OSTCBList
;;;2012           OSRdyGrp               |= ptcb->OSTCBBitY;         /* Make task ready to run                   */
000916  3430              ADDS     r4,r4,#0x30
000918  78a0              LDRB     r0,[r4,#2]
00091a  4912              LDR      r1,|L1.2404|
00091c  7809              LDRB     r1,[r1,#0]  ; OSRdyGrp
00091e  4308              ORRS     r0,r0,r1
000920  4910              LDR      r1,|L1.2404|
000922  7008              STRB     r0,[r1,#0]
;;;2013           OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
000924  7820              LDRB     r0,[r4,#0]
000926  e000              B        |L1.2346|
                  |L1.2344|
000928  e012              B        |L1.2384|
                  |L1.2346|
00092a  490f              LDR      r1,|L1.2408|
00092c  5c08              LDRB     r0,[r1,r0]
00092e  7861              LDRB     r1,[r4,#1]
000930  4308              ORRS     r0,r0,r1
000932  f8141930          LDRB     r1,[r4],#-0x30
000936  4a0c              LDR      r2,|L1.2408|
000938  5450              STRB     r0,[r2,r1]
;;;2014           OSTaskCtr++;                                       /* Increment the #tasks counter             */
00093a  480c              LDR      r0,|L1.2412|
00093c  7800              LDRB     r0,[r0,#0]  ; OSTaskCtr
00093e  1c40              ADDS     r0,r0,#1
000940  490a              LDR      r1,|L1.2412|
000942  7008              STRB     r0,[r1,#0]
;;;2015           OS_EXIT_CRITICAL();
000944  9800              LDR      r0,[sp,#0]
000946  f7fffffe          BL       OS_CPU_SR_Restore
;;;2016           return (OS_ERR_NONE);
00094a  2000              MOVS     r0,#0
                  |L1.2380|
;;;2017       }
;;;2018       OS_EXIT_CRITICAL();
;;;2019       return (OS_ERR_TASK_NO_MORE_TCB);
;;;2020   }
00094c  e8bd8ff8          POP      {r3-r11,pc}
                  |L1.2384|
000950  9800              LDR      r0,[sp,#0]            ;2018
000952  f7fffffe          BL       OS_CPU_SR_Restore
000956  2042              MOVS     r0,#0x42              ;2019
000958  e7f8              B        |L1.2380|
                          ENDP

00095a  0000              DCW      0x0000
                  |L1.2396|
                          DCD      OSTCBPrioTbl
                  |L1.2400|
                          DCD      OSTCBList
                  |L1.2404|
                          DCD      OSRdyGrp
                  |L1.2408|
                          DCD      OSRdyTbl
                  |L1.2412|
                          DCD      OSTaskCtr

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  OSEventTbl
                          %        600
                  OSFlagTbl
                          %        120
                  OSTaskStatStk
                          %        512
                  OSTaskIdleStk
                          %        512
                  OSTCBPrioTbl
                          %        124
                  OSTCBTbl
                          %        1292
                  OSMemTbl
                          %        144
                  OSQTbl
                          %        240

                          AREA ||.constdata||, DATA, READONLY, ALIGN=0

                  OSUnMapTbl
000000  00000100          DCB      0x00,0x00,0x01,0x00
000004  02000100          DCB      0x02,0x00,0x01,0x00
000008  03000100          DCB      0x03,0x00,0x01,0x00
00000c  02000100          DCB      0x02,0x00,0x01,0x00
000010  04000100          DCB      0x04,0x00,0x01,0x00
000014  02000100          DCB      0x02,0x00,0x01,0x00
000018  03000100          DCB      0x03,0x00,0x01,0x00
00001c  02000100          DCB      0x02,0x00,0x01,0x00
000020  05000100          DCB      0x05,0x00,0x01,0x00
000024  02000100          DCB      0x02,0x00,0x01,0x00
000028  03000100          DCB      0x03,0x00,0x01,0x00
00002c  02000100          DCB      0x02,0x00,0x01,0x00
000030  04000100          DCB      0x04,0x00,0x01,0x00
000034  02000100          DCB      0x02,0x00,0x01,0x00
000038  03000100          DCB      0x03,0x00,0x01,0x00
00003c  02000100          DCB      0x02,0x00,0x01,0x00
000040  06000100          DCB      0x06,0x00,0x01,0x00
000044  02000100          DCB      0x02,0x00,0x01,0x00
000048  03000100          DCB      0x03,0x00,0x01,0x00
00004c  02000100          DCB      0x02,0x00,0x01,0x00
000050  04000100          DCB      0x04,0x00,0x01,0x00
000054  02000100          DCB      0x02,0x00,0x01,0x00
000058  03000100          DCB      0x03,0x00,0x01,0x00
00005c  02000100          DCB      0x02,0x00,0x01,0x00
000060  05000100          DCB      0x05,0x00,0x01,0x00
000064  02000100          DCB      0x02,0x00,0x01,0x00
000068  03000100          DCB      0x03,0x00,0x01,0x00
00006c  02000100          DCB      0x02,0x00,0x01,0x00
000070  04000100          DCB      0x04,0x00,0x01,0x00
000074  02000100          DCB      0x02,0x00,0x01,0x00
000078  03000100          DCB      0x03,0x00,0x01,0x00
00007c  02000100          DCB      0x02,0x00,0x01,0x00
000080  07000100          DCB      0x07,0x00,0x01,0x00
000084  02000100          DCB      0x02,0x00,0x01,0x00
000088  03000100          DCB      0x03,0x00,0x01,0x00
00008c  02000100          DCB      0x02,0x00,0x01,0x00
000090  04000100          DCB      0x04,0x00,0x01,0x00
000094  02000100          DCB      0x02,0x00,0x01,0x00
000098  03000100          DCB      0x03,0x00,0x01,0x00
00009c  02000100          DCB      0x02,0x00,0x01,0x00
0000a0  05000100          DCB      0x05,0x00,0x01,0x00
0000a4  02000100          DCB      0x02,0x00,0x01,0x00
0000a8  03000100          DCB      0x03,0x00,0x01,0x00
0000ac  02000100          DCB      0x02,0x00,0x01,0x00
0000b0  04000100          DCB      0x04,0x00,0x01,0x00
0000b4  02000100          DCB      0x02,0x00,0x01,0x00
0000b8  03000100          DCB      0x03,0x00,0x01,0x00
0000bc  02000100          DCB      0x02,0x00,0x01,0x00
0000c0  06000100          DCB      0x06,0x00,0x01,0x00
0000c4  02000100          DCB      0x02,0x00,0x01,0x00
0000c8  03000100          DCB      0x03,0x00,0x01,0x00
0000cc  02000100          DCB      0x02,0x00,0x01,0x00
0000d0  04000100          DCB      0x04,0x00,0x01,0x00
0000d4  02000100          DCB      0x02,0x00,0x01,0x00
0000d8  03000100          DCB      0x03,0x00,0x01,0x00
0000dc  02000100          DCB      0x02,0x00,0x01,0x00
0000e0  05000100          DCB      0x05,0x00,0x01,0x00
0000e4  02000100          DCB      0x02,0x00,0x01,0x00
0000e8  03000100          DCB      0x03,0x00,0x01,0x00
0000ec  02000100          DCB      0x02,0x00,0x01,0x00
0000f0  04000100          DCB      0x04,0x00,0x01,0x00
0000f4  02000100          DCB      0x02,0x00,0x01,0x00
0000f8  03000100          DCB      0x03,0x00,0x01,0x00
0000fc  02000100          DCB      0x02,0x00,0x01,0x00

                          AREA ||.data||, DATA, ALIGN=2

                  OSCtxSwCtr
                          DCD      0x00000000
                  OSEventFreeList
                          DCD      0x00000000
                  OSFlagFreeList
                          DCD      0x00000000
                  OSCPUUsage
00000c  00000000          DCB      0x00,0x00,0x00,0x00
                  OSIdleCtrMax
                          DCD      0x00000000
                  OSIdleCtrRun
                          DCD      0x00000000
                  OSStatRdy
000018  00                DCB      0x00
                  OSIntNesting
000019  00                DCB      0x00
                  OSLockNesting
00001a  00                DCB      0x00
                  OSPrioCur
00001b  00                DCB      0x00
                  OSPrioHighRdy
00001c  00                DCB      0x00
                  OSRdyGrp
00001d  00                DCB      0x00
                  OSRdyTbl
00001e  0000              DCB      0x00,0x00
000020  0000              DCB      0x00,0x00
                  OSRunning
000022  00                DCB      0x00
                  OSTaskCtr
000023  00                DCB      0x00
                  OSIdleCtr
                          DCD      0x00000000
                  OSTCBCur
                          DCD      0x00000000
                  OSTCBFreeList
                          DCD      0x00000000
                  OSTCBHighRdy
                          DCD      0x00000000
                  OSTCBList
                          DCD      0x00000000
                  OSTickStepState
000038  00000000          DCB      0x00,0x00,0x00,0x00
                  OSMemFreeList
                          DCD      0x00000000
                  OSQFreeList
                          DCD      0x00000000
                  OSTime
                          DCD      0x00000000
