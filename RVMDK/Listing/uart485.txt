; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\output\uart485.o --asm_dir=.\Listing\ --list_dir=.\Listing\ --depend=.\output\uart485.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x -I..\bsp_lib -I..\UCOSII\port -I..\UCOSII\src -I..\UCOSII\uC-CPU -I..\Libraries\CMSIS -I..\User\INCLUDES -I..\LCD -I..\USR\Global -I..\USR -I..\USR\FSM -I..\USR\Commucation -I..\USR\Mdb -I..\USR\Drop -I..\USR\DriverBoard -I..\USR\Flash -I..\USR\Card -I..\USR\MSG -I..\USR\Bsp -I..\USR\SetPar -I..\User\QRCode -I..\USR\MEM -I..\USR\QRCode -I..\USR\SETUP -I..\USR\stm32 -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -IC:\Keil_v5\ARM\INC\ST\STM32F10x -D__MICROLIB -D__UVISION_VERSION=525 -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER --omf_browse=.\output\uart485.crf ..\bsp_lib\uart485.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  uart_485_config PROC
;;;25     */
;;;26     void uart_485_config(void)
000000  b500              PUSH     {lr}
;;;27     {
000002  b087              SUB      sp,sp,#0x1c
;;;28     	GPIO_InitTypeDef GPIO_InitStructure;
;;;29     	USART_InitTypeDef USART_InitStructure;
;;;30     	NVIC_InitTypeDef NVIC_InitStructure;
;;;31     	
;;;32     	//这里需要打开一下GPIO口时钟，或者在统一的文件中打开，后面就不用打开了
;;;33     	RCC_APB1PeriphClockCmd(RCC_APB1Periph_UART5 ,ENABLE);//代开uart5外设时钟
000004  2101              MOVS     r1,#1
000006  0508              LSLS     r0,r1,#20
000008  f7fffffe          BL       RCC_APB1PeriphClockCmd
;;;34     	
;;;35     	//485 tx
;;;36     	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_12;
00000c  f44f5080          MOV      r0,#0x1000
000010  f8ad0018          STRH     r0,[sp,#0x18]
;;;37     	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
000014  2018              MOVS     r0,#0x18
000016  f88d001b          STRB     r0,[sp,#0x1b]
;;;38     	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
00001a  2003              MOVS     r0,#3
00001c  f88d001a          STRB     r0,[sp,#0x1a]
;;;39     	GPIO_Init(GPIOC, &GPIO_InitStructure);
000020  a906              ADD      r1,sp,#0x18
000022  48db              LDR      r0,|L1.912|
000024  f7fffffe          BL       GPIO_Init
;;;40     	//485_RX
;;;41     	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_2;
000028  2004              MOVS     r0,#4
00002a  f8ad0018          STRH     r0,[sp,#0x18]
;;;42     	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
00002e  f88d001b          STRB     r0,[sp,#0x1b]
;;;43     	GPIO_Init(GPIOD, &GPIO_InitStructure);	
000032  a906              ADD      r1,sp,#0x18
000034  48d7              LDR      r0,|L1.916|
000036  f7fffffe          BL       GPIO_Init
;;;44     	//485_DIR
;;;45     	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_11;
00003a  f44f6000          MOV      r0,#0x800
00003e  f8ad0018          STRH     r0,[sp,#0x18]
;;;46     	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
000042  2010              MOVS     r0,#0x10
000044  f88d001b          STRB     r0,[sp,#0x1b]
;;;47     	GPIO_Init(GPIOG, &GPIO_InitStructure);	
000048  a906              ADD      r1,sp,#0x18
00004a  48d3              LDR      r0,|L1.920|
00004c  f7fffffe          BL       GPIO_Init
;;;48     	
;;;49     	
;;;50     	USART_DeInit (UART5);
000050  48d2              LDR      r0,|L1.924|
000052  f7fffffe          BL       USART_DeInit
;;;51     	USART_InitStructure.USART_BaudRate = 9600;
000056  f44f5016          MOV      r0,#0x2580
00005a  9002              STR      r0,[sp,#8]
;;;52     	USART_InitStructure.USART_WordLength = USART_WordLength_8b;
00005c  2000              MOVS     r0,#0
00005e  f8ad000c          STRH     r0,[sp,#0xc]
;;;53     	USART_InitStructure.USART_StopBits = USART_StopBits_1;
000062  f8ad000e          STRH     r0,[sp,#0xe]
;;;54     	USART_InitStructure.USART_Parity = USART_Parity_No ;
000066  f8ad0010          STRH     r0,[sp,#0x10]
;;;55     	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
00006a  f8ad0014          STRH     r0,[sp,#0x14]
;;;56     	USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
00006e  200c              MOVS     r0,#0xc
000070  f8ad0012          STRH     r0,[sp,#0x12]
;;;57     	USART_Init(UART5, &USART_InitStructure);
000074  a902              ADD      r1,sp,#8
000076  48c9              LDR      r0,|L1.924|
000078  f7fffffe          BL       USART_Init
;;;58     	
;;;59     	USART_ClearFlag(UART5, USART_FLAG_TC);//清发送完成标志
00007c  2140              MOVS     r1,#0x40
00007e  48c7              LDR      r0,|L1.924|
000080  f7fffffe          BL       USART_ClearFlag
;;;60     	USART_ClearFlag(UART5, USART_IT_IDLE);//清发送完成标志
000084  f2404124          MOV      r1,#0x424
000088  48c4              LDR      r0,|L1.924|
00008a  f7fffffe          BL       USART_ClearFlag
;;;61     	USART_ClearFlag(UART5, USART_IT_RXNE);//清发送完成标志
00008e  f2405125          MOV      r1,#0x525
000092  48c2              LDR      r0,|L1.924|
000094  f7fffffe          BL       USART_ClearFlag
;;;62     	
;;;63     	USART_ITConfig(UART5,  USART_FLAG_TC, DISABLE); 
000098  2200              MOVS     r2,#0
00009a  2140              MOVS     r1,#0x40
00009c  48bf              LDR      r0,|L1.924|
00009e  f7fffffe          BL       USART_ITConfig
;;;64     	USART_ITConfig(UART5,  USART_IT_IDLE, DISABLE); 
0000a2  2200              MOVS     r2,#0
0000a4  f2404124          MOV      r1,#0x424
0000a8  48bc              LDR      r0,|L1.924|
0000aa  f7fffffe          BL       USART_ITConfig
;;;65     	USART_ITConfig(UART5,  USART_IT_RXNE, DISABLE); 
0000ae  2200              MOVS     r2,#0
0000b0  f2405125          MOV      r1,#0x525
0000b4  48b9              LDR      r0,|L1.924|
0000b6  f7fffffe          BL       USART_ITConfig
;;;66     	USART_ITConfig(UART5,  USART_IT_FE, DISABLE); 
0000ba  2200              MOVS     r2,#0
0000bc  f44f71b0          MOV      r1,#0x160
0000c0  48b6              LDR      r0,|L1.924|
0000c2  f7fffffe          BL       USART_ITConfig
;;;67     	USART_ITConfig(UART5,  USART_IT_NE, DISABLE); 
0000c6  2200              MOVS     r2,#0
0000c8  f44f7118          MOV      r1,#0x260
0000cc  48b3              LDR      r0,|L1.924|
0000ce  f7fffffe          BL       USART_ITConfig
;;;68     	USART_ITConfig(UART5,  USART_IT_PE, DISABLE); 
0000d2  2200              MOVS     r2,#0
0000d4  2128              MOVS     r1,#0x28
0000d6  48b1              LDR      r0,|L1.924|
0000d8  f7fffffe          BL       USART_ITConfig
;;;69     	USART_ITConfig(UART5,  USART_IT_CTS, DISABLE); 	
0000dc  2200              MOVS     r2,#0
0000de  f640116a          MOV      r1,#0x96a
0000e2  48ae              LDR      r0,|L1.924|
0000e4  f7fffffe          BL       USART_ITConfig
;;;70     	
;;;71     	NVIC_InitStructure.NVIC_IRQChannel = UART5_IRQn; 		   //USART5接收中断
0000e8  2035              MOVS     r0,#0x35
0000ea  f88d0004          STRB     r0,[sp,#4]
;;;72     	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1;  //先占优先级
0000ee  2001              MOVS     r0,#1
0000f0  f88d0005          STRB     r0,[sp,#5]
;;;73     	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;		   //次占优先级
0000f4  2000              MOVS     r0,#0
0000f6  f88d0006          STRB     r0,[sp,#6]
;;;74     	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
0000fa  2001              MOVS     r0,#1
0000fc  f88d0007          STRB     r0,[sp,#7]
;;;75     	NVIC_Init(&NVIC_InitStructure);
000100  a801              ADD      r0,sp,#4
000102  f7fffffe          BL       NVIC_Init
;;;76     	
;;;77     	USART_Cmd(UART5, ENABLE);
000106  2101              MOVS     r1,#1
000108  48a4              LDR      r0,|L1.924|
00010a  f7fffffe          BL       USART_Cmd
;;;78     	
;;;79     	USART_GetFlagStatus(UART5, USART_FLAG_TC);
00010e  2140              MOVS     r1,#0x40
000110  48a2              LDR      r0,|L1.924|
000112  f7fffffe          BL       USART_GetFlagStatus
;;;80     	sem_485_lock = OSSemCreate(1);
000116  2001              MOVS     r0,#1
000118  f7fffffe          BL       OSSemCreate
00011c  49a0              LDR      r1,|L1.928|
00011e  6008              STR      r0,[r1,#0]  ; sem_485_lock
;;;81     	sem_485_cmd = OSSemCreate(0);
000120  2000              MOVS     r0,#0
000122  f7fffffe          BL       OSSemCreate
000126  499f              LDR      r1,|L1.932|
000128  6008              STR      r0,[r1,#0]  ; sem_485_cmd
;;;82     }
00012a  b007              ADD      sp,sp,#0x1c
00012c  bd00              POP      {pc}
;;;83     /*
                          ENDP

                  bus_Lock_485 PROC
;;;85     */
;;;86     void bus_Lock_485(void)
00012e  b508              PUSH     {r3,lr}
;;;87     {
;;;88     	uint8_t err;
;;;89     //	while(sem_485_lock == NULL);
;;;90     	OSSemPend(sem_485_lock, 0, &err);
000130  466a              MOV      r2,sp
000132  2100              MOVS     r1,#0
000134  489a              LDR      r0,|L1.928|
000136  6800              LDR      r0,[r0,#0]  ; sem_485_lock
000138  f7fffffe          BL       OSSemPend
;;;91     }
00013c  bd08              POP      {r3,pc}
;;;92     
                          ENDP

                  bus_Unlock_485 PROC
;;;95     */
;;;96     void bus_Unlock_485(void)
00013e  b510              PUSH     {r4,lr}
;;;97     {
;;;98     //	while(sem_485_lock == NULL);
;;;99     	OSSemPost(sem_485_lock);
000140  4897              LDR      r0,|L1.928|
000142  6800              LDR      r0,[r0,#0]  ; sem_485_lock
000144  f7fffffe          BL       OSSemPost
;;;100    }
000148  bd10              POP      {r4,pc}
;;;101    
                          ENDP

                  send_to_485Bus PROC
;;;105    */
;;;106    uint8_t send_to_485Bus(UART485_CMD_DATA* cmd)
00014a  b538              PUSH     {r3-r5,lr}
;;;107    {
00014c  4604              MOV      r4,r0
;;;108    	uint8_t err;
;;;109    	USART_ITConfig(UART5,USART_IT_RXNE, DISABLE);
00014e  2200              MOVS     r2,#0
000150  f2405125          MOV      r1,#0x525
000154  4891              LDR      r0,|L1.924|
000156  f7fffffe          BL       USART_ITConfig
;;;110    	err = UART5->SR;
00015a  4890              LDR      r0,|L1.924|
00015c  8800              LDRH     r0,[r0,#0]
00015e  b2c0              UXTB     r0,r0
000160  9000              STR      r0,[sp,#0]
;;;111    	err = UART5->DR;//清洗寄存器
000162  488e              LDR      r0,|L1.924|
000164  8880              LDRH     r0,[r0,#4]
000166  b2c0              UXTB     r0,r0
000168  9000              STR      r0,[sp,#0]
;;;112    	
;;;113    	USART_ClearFlag(UART5, USART_FLAG_TC);//清发送完成标志
00016a  2140              MOVS     r1,#0x40
00016c  488b              LDR      r0,|L1.924|
00016e  f7fffffe          BL       USART_ClearFlag
;;;114    	USART_ClearFlag(UART5, USART_IT_IDLE);//清发送完成标志
000172  f2404124          MOV      r1,#0x424
000176  4889              LDR      r0,|L1.924|
000178  f7fffffe          BL       USART_ClearFlag
;;;115    	USART_ClearFlag(UART5, USART_IT_RXNE);//清发送完成标志
00017c  f2405125          MOV      r1,#0x525
000180  4886              LDR      r0,|L1.924|
000182  f7fffffe          BL       USART_ClearFlag
;;;116    	USART_GetFlagStatus(UART5, USART_FLAG_TC);
000186  2140              MOVS     r1,#0x40
000188  4884              LDR      r0,|L1.924|
00018a  f7fffffe          BL       USART_GetFlagStatus
;;;117    //	while (!(UART5->SR & USART_FLAG_TXE));
;;;118    //		GPIO_SetBits(GPIOG,GPIO_Pin_11);
;;;119    	OPEN_485_SEND;
00018e  f44f6100          MOV      r1,#0x800
000192  4881              LDR      r0,|L1.920|
000194  f7fffffe          BL       GPIO_SetBits
;;;120    	OSSemAccept(sem_485_cmd);//清除信号量
000198  4882              LDR      r0,|L1.932|
00019a  6800              LDR      r0,[r0,#0]  ; sem_485_cmd
00019c  f7fffffe          BL       OSSemAccept
;;;121    	/*
;;;122    	485全局指针指向
;;;123    	*/
;;;124    	cur485Cmd = cmd;
0001a0  4881              LDR      r0,|L1.936|
0001a2  6004              STR      r4,[r0,#0]  ; cur485Cmd
;;;125    	cur485Cmd->recv_len = 0;
0001a4  2000              MOVS     r0,#0
0001a6  4980              LDR      r1,|L1.936|
0001a8  6809              LDR      r1,[r1,#0]  ; cur485Cmd
0001aa  7308              STRB     r0,[r1,#0xc]
;;;126    	cur485Cmd->sendCount = 0;
0001ac  497e              LDR      r1,|L1.936|
0001ae  6809              LDR      r1,[r1,#0]  ; cur485Cmd
0001b0  7348              STRB     r0,[r1,#0xd]
;;;127    	USART_ITConfig(UART5,USART_IT_TC, ENABLE);   		//开启发送中断
0001b2  2201              MOVS     r2,#1
0001b4  f2406126          MOV      r1,#0x626
0001b8  4878              LDR      r0,|L1.924|
0001ba  f7fffffe          BL       USART_ITConfig
;;;128    	UART5->DR = cur485Cmd->cmd[cur485Cmd->sendCount++];	//开始发数据
0001be  497a              LDR      r1,|L1.936|
0001c0  6809              LDR      r1,[r1,#0]  ; cur485Cmd
0001c2  7b48              LDRB     r0,[r1,#0xd]
0001c4  1c41              ADDS     r1,r0,#1
0001c6  4a78              LDR      r2,|L1.936|
0001c8  6812              LDR      r2,[r2,#0]  ; cur485Cmd
0001ca  7351              STRB     r1,[r2,#0xd]
0001cc  4976              LDR      r1,|L1.936|
0001ce  6809              LDR      r1,[r1,#0]  ; cur485Cmd
0001d0  6849              LDR      r1,[r1,#4]
0001d2  5c09              LDRB     r1,[r1,r0]
0001d4  4a71              LDR      r2,|L1.924|
0001d6  8091              STRH     r1,[r2,#4]
;;;129    	OSSemPend(sem_485_cmd, cur485Cmd->timeout, &err);	//等待
0001d8  4873              LDR      r0,|L1.936|
0001da  6800              LDR      r0,[r0,#0]  ; cur485Cmd
0001dc  89c1              LDRH     r1,[r0,#0xe]
0001de  466a              MOV      r2,sp
0001e0  4870              LDR      r0,|L1.932|
0001e2  6800              LDR      r0,[r0,#0]  ; sem_485_cmd
0001e4  f7fffffe          BL       OSSemPend
;;;130    	cur485Cmd = 0;//防止野指针
0001e8  2000              MOVS     r0,#0
0001ea  496f              LDR      r1,|L1.936|
0001ec  6008              STR      r0,[r1,#0]  ; cur485Cmd
;;;131    	return err;
0001ee  f89d0000          LDRB     r0,[sp,#0]
;;;132    }
0001f2  bd38              POP      {r3-r5,pc}
;;;133    
                          ENDP

                  TIM3_IRQHandler PROC
;;;140    uint8_t flag = 0;
;;;141    void TIM3_IRQHandler(void)
0001f4  b510              PUSH     {r4,lr}
;;;142    { 
;;;143      if(TIM_GetITStatus(TIM3, TIM_IT_Update) != RESET)
0001f6  2101              MOVS     r1,#1
0001f8  486c              LDR      r0,|L1.940|
0001fa  f7fffffe          BL       TIM_GetITStatus
0001fe  b380              CBZ      r0,|L1.610|
;;;144        { 
;;;145    		TIM_ClearITPendingBit(TIM3, TIM_IT_Update);
000200  2101              MOVS     r1,#1
000202  486a              LDR      r0,|L1.940|
000204  f7fffffe          BL       TIM_ClearITPendingBit
;;;146    		TIM_Cmd(TIM3, DISABLE);
000208  2100              MOVS     r1,#0
00020a  4868              LDR      r0,|L1.940|
00020c  f7fffffe          BL       TIM_Cmd
;;;147    		if(flag == 0)
000210  4867              LDR      r0,|L1.944|
000212  7800              LDRB     r0,[r0,#0]  ; flag
000214  b918              CBNZ     r0,|L1.542|
;;;148    			rx_len = 100;
000216  2064              MOVS     r0,#0x64
000218  4966              LDR      r1,|L1.948|
00021a  6008              STR      r0,[r1,#0]  ; rx_len
00021c  e002              B        |L1.548|
                  |L1.542|
;;;149    		else
;;;150    			rx_len = 0;
00021e  2000              MOVS     r0,#0
000220  4964              LDR      r1,|L1.948|
000222  6008              STR      r0,[r1,#0]  ; rx_len
                  |L1.548|
;;;151    		flag++;
000224  4862              LDR      r0,|L1.944|
000226  7800              LDRB     r0,[r0,#0]  ; flag
000228  1c40              ADDS     r0,r0,#1
00022a  4961              LDR      r1,|L1.944|
00022c  7008              STRB     r0,[r1,#0]
;;;152    		flag %= 1;
00022e  2000              MOVS     r0,#0
000230  7008              STRB     r0,[r1,#0]
;;;153    		//这里可以发送一个消息
;;;154    		//这里不能申请消息。
;;;155    		
;;;156    		if(cur485Cmd != NULL)//当前有命令需要执行
000232  485d              LDR      r0,|L1.936|
000234  6800              LDR      r0,[r0,#0]  ; cur485Cmd
000236  b1a0              CBZ      r0,|L1.610|
;;;157    		{
;;;158    			if(cur485Cmd->isFinished(cur485Cmd->recv, &(cur485Cmd->recv_len)))
000238  495b              LDR      r1,|L1.936|
00023a  6809              LDR      r1,[r1,#0]  ; cur485Cmd
00023c  6888              LDR      r0,[r1,#8]
00023e  495a              LDR      r1,|L1.936|
000240  6809              LDR      r1,[r1,#0]  ; cur485Cmd
000242  690a              LDR      r2,[r1,#0x10]
000244  4958              LDR      r1,|L1.936|
000246  6809              LDR      r1,[r1,#0]  ; cur485Cmd
000248  310c              ADDS     r1,r1,#0xc
00024a  4790              BLX      r2
00024c  b148              CBZ      r0,|L1.610|
;;;159    			{
;;;160    //				OPEN_485_SEND;			//485方向转换为发送
;;;161    				OSSemPost(sem_485_cmd); //通知数据接收完成
00024e  4855              LDR      r0,|L1.932|
000250  6800              LDR      r0,[r0,#0]  ; sem_485_cmd
000252  f7fffffe          BL       OSSemPost
;;;162    				USART_ITConfig(UART5, USART_IT_RXNE, DISABLE);//关485接收中断
000256  2200              MOVS     r2,#0
000258  f2405125          MOV      r1,#0x525
00025c  484f              LDR      r0,|L1.924|
00025e  f7fffffe          BL       USART_ITConfig
                  |L1.610|
;;;163    			}
;;;164    		}
;;;165    		
;;;166    		
;;;167        } 
;;;168    } 
000262  bd10              POP      {r4,pc}
;;;169    
                          ENDP

                  UART5_IRQHandler PROC
;;;173    
;;;174    void UART5_IRQHandler(void)
000264  b570              PUSH     {r4-r6,lr}
;;;175    {
;;;176    	uint8_t sr;
;;;177    	sr = sr;
000266  bf00              NOP      
;;;178    	if(USART_GetITStatus(UART5, USART_IT_RXNE) != RESET)//接收到数据
000268  f2405125          MOV      r1,#0x525
00026c  484b              LDR      r0,|L1.924|
00026e  f7fffffe          BL       USART_GetITStatus
000272  b328              CBZ      r0,|L1.704|
;;;179    	{
;;;180    		start_tim3_ms(20);//开始计数器计时
000274  2014              MOVS     r0,#0x14
000276  f7fffffe          BL       start_tim3_ms
;;;181    
;;;182    		sr = UART5->SR;
00027a  4848              LDR      r0,|L1.924|
00027c  8800              LDRH     r0,[r0,#0]
00027e  b2c4              UXTB     r4,r0
;;;183    		USART_ClearITPendingBit(UART5, USART_IT_RXNE);
000280  f2405125          MOV      r1,#0x525
000284  4845              LDR      r0,|L1.924|
000286  f7fffffe          BL       USART_ClearITPendingBit
;;;184    //		rx_len %= 1000;
;;;185    //		rx[rx_len++] = UART5->DR;
;;;186    		
;;;187    		
;;;188    		if(cur485Cmd != NULL)//当前有命令需要执行
00028a  4847              LDR      r0,|L1.936|
00028c  6800              LDR      r0,[r0,#0]  ; cur485Cmd
00028e  2800              CMP      r0,#0
000290  d07d              BEQ      |L1.910|
;;;189    		{
;;;190    			uint8_t data = UART5->DR;
000292  4942              LDR      r1,|L1.924|
000294  8889              LDRH     r1,[r1,#4]
000296  b2c8              UXTB     r0,r1
;;;191    			cur485Cmd->recv[cur485Cmd->recv_len++] = data;
000298  4a43              LDR      r2,|L1.936|
00029a  6812              LDR      r2,[r2,#0]  ; cur485Cmd
00029c  7b11              LDRB     r1,[r2,#0xc]
00029e  1c4a              ADDS     r2,r1,#1
0002a0  4b41              LDR      r3,|L1.936|
0002a2  681b              LDR      r3,[r3,#0]  ; cur485Cmd
0002a4  731a              STRB     r2,[r3,#0xc]
0002a6  4a40              LDR      r2,|L1.936|
0002a8  6812              LDR      r2,[r2,#0]  ; cur485Cmd
0002aa  6892              LDR      r2,[r2,#8]
0002ac  5450              STRB     r0,[r2,r1]
;;;192    			rx[rx_len++] = data;
0002ae  4941              LDR      r1,|L1.948|
0002b0  680a              LDR      r2,[r1,#0]  ; rx_len
0002b2  6809              LDR      r1,[r1,#0]  ; rx_len
0002b4  1c49              ADDS     r1,r1,#1
0002b6  4b3f              LDR      r3,|L1.948|
0002b8  6019              STR      r1,[r3,#0]  ; rx_len
0002ba  493f              LDR      r1,|L1.952|
0002bc  5488              STRB     r0,[r1,r2]
;;;193    //			if(cur485Cmd->isFinished(cur485Cmd->recv, &(cur485Cmd->recv_len)))
;;;194    //			{
;;;195    //				OPEN_485_SEND;			//485方向转换为接收
;;;196    //				OSSemPost(sem_485_cmd); //通知数据接收完成
;;;197    //				USART_ITConfig(UART5, USART_IT_RXNE, DISABLE);//关485接收中断
;;;198    //			}
;;;199    		}
0002be  e066              B        |L1.910|
                  |L1.704|
;;;200    	}
;;;201    	else
;;;202    	if(USART_GetITStatus(UART5, USART_IT_TC) != RESET)//发送完成，每次一字节
0002c0  f2406126          MOV      r1,#0x626
0002c4  4835              LDR      r0,|L1.924|
0002c6  f7fffffe          BL       USART_GetITStatus
0002ca  2800              CMP      r0,#0
0002cc  d03f              BEQ      |L1.846|
;;;203    	{
;;;204    		USART_ClearITPendingBit(UART5, USART_IT_TC);//清除中断待处理位
0002ce  f2406126          MOV      r1,#0x626
0002d2  4832              LDR      r0,|L1.924|
0002d4  f7fffffe          BL       USART_ClearITPendingBit
;;;205    		if(cur485Cmd != NULL)//当前有命令需要执行
0002d8  4833              LDR      r0,|L1.936|
0002da  6800              LDR      r0,[r0,#0]  ; cur485Cmd
0002dc  2800              CMP      r0,#0
0002de  d056              BEQ      |L1.910|
;;;206    		{
;;;207    			if(cur485Cmd->sendCount<cur485Cmd->cmd_len)
0002e0  4831              LDR      r0,|L1.936|
0002e2  6800              LDR      r0,[r0,#0]  ; cur485Cmd
0002e4  7b40              LDRB     r0,[r0,#0xd]
0002e6  4930              LDR      r1,|L1.936|
0002e8  6809              LDR      r1,[r1,#0]  ; cur485Cmd
0002ea  7849              LDRB     r1,[r1,#1]
0002ec  4288              CMP      r0,r1
0002ee  da0d              BGE      |L1.780|
;;;208    				UART5->DR=cur485Cmd->cmd[cur485Cmd->sendCount++];
0002f0  492d              LDR      r1,|L1.936|
0002f2  6809              LDR      r1,[r1,#0]  ; cur485Cmd
0002f4  7b48              LDRB     r0,[r1,#0xd]
0002f6  1c41              ADDS     r1,r0,#1
0002f8  4a2b              LDR      r2,|L1.936|
0002fa  6812              LDR      r2,[r2,#0]  ; cur485Cmd
0002fc  7351              STRB     r1,[r2,#0xd]
0002fe  492a              LDR      r1,|L1.936|
000300  6809              LDR      r1,[r1,#0]  ; cur485Cmd
000302  6849              LDR      r1,[r1,#4]
000304  5c09              LDRB     r1,[r1,r0]
000306  4a25              LDR      r2,|L1.924|
000308  8091              STRH     r1,[r2,#4]
00030a  e040              B        |L1.910|
                  |L1.780|
;;;209    			else
;;;210    			{
;;;211    				USART_ITConfig(UART5, USART_IT_TC,DISABLE);//关485发送中断
00030c  2200              MOVS     r2,#0
00030e  f2406126          MOV      r1,#0x626
000312  4822              LDR      r0,|L1.924|
000314  f7fffffe          BL       USART_ITConfig
;;;212    				if(cur485Cmd->needAck)//需要应答的指令
000318  4823              LDR      r0,|L1.936|
00031a  6800              LDR      r0,[r0,#0]  ; cur485Cmd
00031c  7800              LDRB     r0,[r0,#0]
00031e  b188              CBZ      r0,|L1.836|
;;;213    				{
;;;214    					USART_ITConfig(UART5, USART_IT_TC, DISABLE);//关发送中断
000320  2200              MOVS     r2,#0
000322  f2406126          MOV      r1,#0x626
000326  481d              LDR      r0,|L1.924|
000328  f7fffffe          BL       USART_ITConfig
;;;215    					USART_ITConfig(UART5, USART_IT_RXNE, ENABLE);//打开485接收中断
00032c  2201              MOVS     r2,#1
00032e  f2405125          MOV      r1,#0x525
000332  481a              LDR      r0,|L1.924|
000334  f7fffffe          BL       USART_ITConfig
;;;216    					
;;;217    					OPEN_485_RECV;	//485方向变为接收
000338  f44f6100          MOV      r1,#0x800
00033c  4816              LDR      r0,|L1.920|
00033e  f7fffffe          BL       GPIO_ResetBits
000342  e024              B        |L1.910|
                  |L1.836|
;;;218    //					for(sr = 0; sr < 100; sr++);
;;;219    //					cur485Cmd->recv_len = 0;
;;;220    
;;;221    					
;;;222    				}
;;;223    				else//不需要应答的指令，直接释放信号量
;;;224    				{
;;;225    					OSSemPost(sem_485_cmd);
000344  4817              LDR      r0,|L1.932|
000346  6800              LDR      r0,[r0,#0]  ; sem_485_cmd
000348  f7fffffe          BL       OSSemPost
00034c  e01f              B        |L1.910|
                  |L1.846|
;;;226    				}
;;;227    			}
;;;228    		}
;;;229    	}
;;;230    	else
;;;231    	{
;;;232    		if( USART_GetITStatus(UART5, USART_IT_IDLE) != RESET )
00034e  f2404124          MOV      r1,#0x424
000352  4812              LDR      r0,|L1.924|
000354  f7fffffe          BL       USART_GetITStatus
000358  b148              CBZ      r0,|L1.878|
;;;233    		{
;;;234    			uint8_t sr = USART_ReceiveData(UART5);
00035a  4810              LDR      r0,|L1.924|
00035c  f7fffffe          BL       USART_ReceiveData
000360  b2c5              UXTB     r5,r0
;;;235    			USART_ClearITPendingBit(UART5, USART_IT_IDLE);
000362  f2404124          MOV      r1,#0x424
000366  480d              LDR      r0,|L1.924|
000368  f7fffffe          BL       USART_ClearITPendingBit
;;;236    		}
00036c  bf00              NOP      
                  |L1.878|
;;;237    		if(USART_GetITStatus(UART5, USART_IT_PE | USART_IT_FE | USART_IT_NE) != RESET)//其他错误
00036e  f44f715a          MOV      r1,#0x368
000372  480a              LDR      r0,|L1.924|
000374  f7fffffe          BL       USART_GetITStatus
000378  b148              CBZ      r0,|L1.910|
;;;238    		{
;;;239    		uint8_t sr = USART_ReceiveData(UART5);
00037a  4808              LDR      r0,|L1.924|
00037c  f7fffffe          BL       USART_ReceiveData
000380  b2c5              UXTB     r5,r0
;;;240    			USART_ClearITPendingBit(UART5, USART_IT_PE | USART_IT_FE | USART_IT_NE);
000382  f44f715a          MOV      r1,#0x368
000386  4805              LDR      r0,|L1.924|
000388  f7fffffe          BL       USART_ClearITPendingBit
;;;241    		}
00038c  bf00              NOP      
                  |L1.910|
;;;242    	}
;;;243    }
00038e  bd70              POP      {r4-r6,pc}
;;;244    
                          ENDP

                  |L1.912|
                          DCD      0x40011000
                  |L1.916|
                          DCD      0x40011400
                  |L1.920|
                          DCD      0x40012000
                  |L1.924|
                          DCD      0x40005000
                  |L1.928|
                          DCD      sem_485_lock
                  |L1.932|
                          DCD      sem_485_cmd
                  |L1.936|
                          DCD      cur485Cmd
                  |L1.940|
                          DCD      0x40000400
                  |L1.944|
                          DCD      flag
                  |L1.948|
                          DCD      rx_len
                  |L1.952|
                          DCD      ||rx||

                          AREA ||.bss||, DATA, NOINIT, ALIGN=0

                  ||rx||
                          %        200

                          AREA ||.data||, DATA, ALIGN=2

                  sem_485_lock
                          DCD      0x00000000
                  sem_485_cmd
                          DCD      0x00000000
                  cur485Cmd
                          DCD      0x00000000
                  rx_len
                          DCD      0x00000000
                  flag
000010  00                DCB      0x00

;*** Start embedded assembler ***

#line 1 "..\\bsp_lib\\uart485.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___9_uart485_c_6c715929____REV16|
#line 129 "C:\\Keil_v5\\ARM\\CMSIS\\Include\\core_cmInstr.h"
|__asm___9_uart485_c_6c715929____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___9_uart485_c_6c715929____REVSH|
#line 144
|__asm___9_uart485_c_6c715929____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
