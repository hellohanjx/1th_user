; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\output\rtc.o --asm_dir=.\Listing\ --list_dir=.\Listing\ --depend=.\output\rtc.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x -I..\bsp_lib -I..\UCOSII\port -I..\UCOSII\src -I..\UCOSII\uC-CPU -I..\Libraries\CMSIS -I..\User\INCLUDES -I..\LCD -I..\USR\Global -I..\USR -I..\USR\FSM -I..\USR\Commucation -I..\USR\Mdb -I..\USR\Drop -I..\USR\DriverBoard -I..\USR\Flash -I..\USR\Card -I..\USR\MSG -I..\USR\Bsp -I..\USR\SetPar -I..\User\QRCode -I..\USR\MEM -I..\USR\QRCode -I..\USR\SETUP -I..\USR\stm32 -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -IC:\Keil_v5\ARM\INC\ST\STM32F10x -D__MICROLIB -D__UVISION_VERSION=525 -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER --omf_browse=.\output\rtc.crf ..\bsp_lib\rtc.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  Is_Leap_Year PROC
;;;23     //返回值:该年份是不是闰年.1,是.0,不是
;;;24     uint8_t Is_Leap_Year(uint16_t year)
000000  4601              MOV      r1,r0
;;;25     {			  
;;;26     	if(year%4==0) //必须能被4整除
000002  17ca              ASRS     r2,r1,#31
000004  eb017292          ADD      r2,r1,r2,LSR #30
000008  1092              ASRS     r2,r2,#2
00000a  eba10282          SUB      r2,r1,r2,LSL #2
00000e  b992              CBNZ     r2,|L1.54|
;;;27     	{ 
;;;28     		if(year%100==0) 
000010  2064              MOVS     r0,#0x64
000012  fb91f2f0          SDIV     r2,r1,r0
000016  fb001012          MLS      r0,r0,r2,r1
00001a  b950              CBNZ     r0,|L1.50|
;;;29     		{ 
;;;30     			if(year%400==0)return 1;//如果以00结尾,还要能被400整除 	   
00001c  f44f70c8          MOV      r0,#0x190
000020  fb91f2f0          SDIV     r2,r1,r0
000024  fb001012          MLS      r0,r0,r2,r1
000028  b908              CBNZ     r0,|L1.46|
00002a  2001              MOVS     r0,#1
                  |L1.44|
;;;31     			else return 0;   
;;;32     		}else return 1;   
;;;33     	}else return 0;	
;;;34     }	 			   
00002c  4770              BX       lr
                  |L1.46|
00002e  2000              MOVS     r0,#0                 ;31
000030  e7fc              B        |L1.44|
                  |L1.50|
000032  2001              MOVS     r0,#1                 ;32
000034  e7fa              B        |L1.44|
                  |L1.54|
000036  2000              MOVS     r0,#0                 ;33
000038  e7f8              B        |L1.44|
;;;35     
                          ENDP

                  RTC_Set PROC
;;;45     
;;;46     static bool RTC_Set(uint16_t syear,uint8_t smon,uint8_t sday,uint8_t hour,uint8_t min,uint8_t sec) 
00003a  e92d5ff0          PUSH     {r4-r12,lr}
;;;47     { 
00003e  4606              MOV      r6,r0
000040  460f              MOV      r7,r1
000042  4690              MOV      r8,r2
000044  4699              MOV      r9,r3
000046  e9ddab0a          LDRD     r10,r11,[sp,#0x28]
;;;48     	uint16_t t; 
;;;49     	uint32_t seccount=0; 
00004a  2400              MOVS     r4,#0
;;;50     	if(syear<1970 || syear>2099)
00004c  f24070b2          MOV      r0,#0x7b2
000050  4286              CMP      r6,r0
000052  db03              BLT      |L1.92|
000054  f6400033          MOV      r0,#0x833
000058  4286              CMP      r6,r0
00005a  dd02              BLE      |L1.98|
                  |L1.92|
;;;51     		return FALSE;    
00005c  2000              MOVS     r0,#0
                  |L1.94|
;;;52     	
;;;53     	for(t=1970;t<syear;t++)             //把所有年份的秒钟相加 
;;;54     	{      
;;;55     		if(Is_Leap_Year(t))
;;;56     			seccount+=31622400;			//闰年的秒钟数 
;;;57     		else 
;;;58     			seccount+=31536000;         //平年的秒钟数 
;;;59     	} 
;;;60     	smon-=1; 
;;;61     	for(t=0;t<smon;t++)                	//把前面月份的秒钟数相加 
;;;62     	{    
;;;63     		seccount+=(uint32_t)mon_table[t]*86400;    	//月份秒钟数相加 
;;;64     		if(Is_Leap_Year(syear)&&t==1)
;;;65     			seccount+=86400;					//闰年 2 月份增加一天的秒钟数
;;;66     	} 
;;;67     	seccount+=(uint32_t)(sday-1)*86400;                //把前面日期的秒钟数相加   
;;;68     	seccount+=(uint32_t)hour*3600;                     //小时秒钟数 
;;;69     	seccount+=(uint32_t)min*60;                        //分钟秒钟数 
;;;70     	seccount+=sec;                                //最后的秒钟加上去 
;;;71     	
;;;72     	RCC_APB1PeriphClockCmd(RCC_APB1Periph_PWR | RCC_APB1Periph_BKP, ENABLE);      //使能PWR 和BKP 外设时钟    
;;;73     	PWR_BackupAccessCmd(ENABLE);      				//使能 RTC和后备寄存器访问   
;;;74     	RTC_SetCounter(seccount);                       //设置RTC计数器的值
;;;75     	RTC_WaitForLastTask();                        	//等待最近一次对RTC寄存器的写操作完成    
;;;76     	return TRUE;        
;;;77     } 
00005e  e8bd9ff0          POP      {r4-r12,pc}
                  |L1.98|
000062  f24075b2          MOV      r5,#0x7b2             ;53
000066  e00a              B        |L1.126|
                  |L1.104|
000068  4628              MOV      r0,r5                 ;55
00006a  f7fffffe          BL       Is_Leap_Year
00006e  b110              CBZ      r0,|L1.118|
000070  48fd              LDR      r0,|L1.1128|
000072  4404              ADD      r4,r4,r0              ;56
000074  e001              B        |L1.122|
                  |L1.118|
000076  48fd              LDR      r0,|L1.1132|
000078  4404              ADD      r4,r4,r0              ;58
                  |L1.122|
00007a  1c68              ADDS     r0,r5,#1              ;53
00007c  b285              UXTH     r5,r0                 ;53
                  |L1.126|
00007e  42b5              CMP      r5,r6                 ;53
000080  dbf2              BLT      |L1.104|
000082  1e78              SUBS     r0,r7,#1              ;60
000084  b2c7              UXTB     r7,r0                 ;60
000086  2500              MOVS     r5,#0                 ;61
000088  e010              B        |L1.172|
                  |L1.138|
00008a  48f9              LDR      r0,|L1.1136|
00008c  5d40              LDRB     r0,[r0,r5]            ;63
00008e  f24021a3          MOV      r1,#0x2a3             ;63
000092  4348              MULS     r0,r1,r0              ;63
000094  eb0414c0          ADD      r4,r4,r0,LSL #7       ;63
000098  4630              MOV      r0,r6                 ;64
00009a  f7fffffe          BL       Is_Leap_Year
00009e  b118              CBZ      r0,|L1.168|
0000a0  2d01              CMP      r5,#1                 ;64
0000a2  d101              BNE      |L1.168|
0000a4  48f3              LDR      r0,|L1.1140|
0000a6  4404              ADD      r4,r4,r0              ;65
                  |L1.168|
0000a8  1c68              ADDS     r0,r5,#1              ;61
0000aa  b285              UXTH     r5,r0                 ;61
                  |L1.172|
0000ac  42bd              CMP      r5,r7                 ;61
0000ae  dbec              BLT      |L1.138|
0000b0  f1a80001          SUB      r0,r8,#1              ;67
0000b4  f24021a3          MOV      r1,#0x2a3             ;67
0000b8  4348              MULS     r0,r1,r0              ;67
0000ba  eb0414c0          ADD      r4,r4,r0,LSL #7       ;67
0000be  ebc91049          RSB      r0,r9,r9,LSL #5       ;68
0000c2  ebc02009          RSB      r0,r0,r9,LSL #8       ;68
0000c6  eb041400          ADD      r4,r4,r0,LSL #4       ;68
0000ca  ebca100a          RSB      r0,r10,r10,LSL #4     ;69
0000ce  eb040480          ADD      r4,r4,r0,LSL #2       ;69
0000d2  445c              ADD      r4,r4,r11             ;70
0000d4  2101              MOVS     r1,#1                 ;72
0000d6  f04f50c0          MOV      r0,#0x18000000        ;72
0000da  f7fffffe          BL       RCC_APB1PeriphClockCmd
0000de  2001              MOVS     r0,#1                 ;73
0000e0  f7fffffe          BL       PWR_BackupAccessCmd
0000e4  4620              MOV      r0,r4                 ;74
0000e6  f7fffffe          BL       RTC_SetCounter
0000ea  f7fffffe          BL       RTC_WaitForLastTask
0000ee  2001              MOVS     r0,#1                 ;76
0000f0  e7b5              B        |L1.94|
;;;78     
                          ENDP

                  RTC_Get_Week PROC
;;;83     //返回值：星期号																						 
;;;84     static uint16_t RTC_Get_Week(uint16_t year,uint8_t month,uint8_t day)
0000f2  b5f0              PUSH     {r4-r7,lr}
;;;85     {	
0000f4  4603              MOV      r3,r0
0000f6  460c              MOV      r4,r1
0000f8  4615              MOV      r5,r2
;;;86     	uint16_t temp2;
;;;87     	uint8_t yearH,yearL;
;;;88     	
;;;89     	yearH=year/100;	yearL=year%100; 
0000fa  2064              MOVS     r0,#0x64
0000fc  fb93f0f0          SDIV     r0,r3,r0
000100  b2c6              UXTB     r6,r0
000102  2064              MOVS     r0,#0x64
000104  fb93f7f0          SDIV     r7,r3,r0
000108  fb003017          MLS      r0,r0,r7,r3
00010c  b2c1              UXTB     r1,r0
;;;90     	// 如果为21世纪,年份数加100  
;;;91     	if (yearH>19)yearL+=100;
00010e  2e13              CMP      r6,#0x13
000110  dd02              BLE      |L1.280|
000112  f1010064          ADD      r0,r1,#0x64
000116  b2c1              UXTB     r1,r0
                  |L1.280|
;;;92     	// 所过闰年数只算1900年之后的  
;;;93     	temp2=yearL+yearL/4;
000118  4608              MOV      r0,r1
00011a  17cf              ASRS     r7,r1,#31
00011c  eb017797          ADD      r7,r1,r7,LSR #30
000120  eb0107a7          ADD      r7,r1,r7,ASR #2
000124  b2ba              UXTH     r2,r7
;;;94     	temp2=temp2%7; 
000126  2007              MOVS     r0,#7
000128  fb92f7f0          SDIV     r7,r2,r0
00012c  fb002017          MLS      r0,r0,r7,r2
000130  b282              UXTH     r2,r0
;;;95     	temp2=temp2+day+table_week[month-1];
000132  1957              ADDS     r7,r2,r5
000134  1e60              SUBS     r0,r4,#1
000136  f8dfc340          LDR      r12,|L1.1144|
00013a  f81c0000          LDRB     r0,[r12,r0]
00013e  4438              ADD      r0,r0,r7
000140  b282              UXTH     r2,r0
;;;96     	if (yearL%4==0&&month<3)temp2--;
000142  17cf              ASRS     r7,r1,#31
000144  eb017797          ADD      r7,r1,r7,LSR #30
000148  10bf              ASRS     r7,r7,#2
00014a  eba10787          SUB      r7,r1,r7,LSL #2
00014e  b91f              CBNZ     r7,|L1.344|
000150  2c03              CMP      r4,#3
000152  da01              BGE      |L1.344|
000154  1e50              SUBS     r0,r2,#1
000156  b282              UXTH     r2,r0
                  |L1.344|
;;;97     	return(temp2%7);
000158  2007              MOVS     r0,#7
00015a  fb92f7f0          SDIV     r7,r2,r0
00015e  fb002017          MLS      r0,r0,r7,r2
000162  b280              UXTH     r0,r0
;;;98     }			  
000164  bdf0              POP      {r4-r7,pc}
;;;99     
                          ENDP

                  RTC_Get PROC
;;;102    //返回值:0,成功;其他:错误代码.
;;;103    static uint32_t RTC_Get(void)
000166  b570              PUSH     {r4-r6,lr}
;;;104    {
;;;105    	static uint16_t daycnt=0;
;;;106    	uint32_t timecount=0; 
000168  2600              MOVS     r6,#0
;;;107    	uint32_t temp=0;
00016a  2400              MOVS     r4,#0
;;;108    	uint16_t temp1=0;
00016c  2500              MOVS     r5,#0
;;;109    	
;;;110    	timecount = RTC_GetCounter();//其实就是得到计数器中总共多少秒，然后开始计算
00016e  f7fffffe          BL       RTC_GetCounter
000172  4606              MOV      r6,r0
;;;111    
;;;112     	temp=timecount/86400;   //得到天数(秒钟数对应的)
000174  48bf              LDR      r0,|L1.1140|
000176  fbb6f4f0          UDIV     r4,r6,r0
;;;113    	if(daycnt!=temp)//超过一天了
00017a  48c0              LDR      r0,|L1.1148|
00017c  8800              LDRH     r0,[r0,#0]  ; daycnt
00017e  42a0              CMP      r0,r4
000180  d03a              BEQ      |L1.504|
;;;114    	{	  
;;;115    		daycnt=temp;
000182  49be              LDR      r1,|L1.1148|
000184  800c              STRH     r4,[r1,#0]
;;;116    		temp1 = 1970;	//从1970年开始
000186  f24075b2          MOV      r5,#0x7b2
;;;117    		while(temp>=365)
00018a  e00e              B        |L1.426|
                  |L1.396|
;;;118    		{				 
;;;119    			if(Is_Leap_Year(temp1))//是闰年
00018c  4628              MOV      r0,r5
00018e  f7fffffe          BL       Is_Leap_Year
000192  b130              CBZ      r0,|L1.418|
;;;120    			{
;;;121    				if(temp>=366)temp-=366;//闰年的秒钟数
000194  f5b47fb7          CMP      r4,#0x16e
000198  d302              BCC      |L1.416|
00019a  f5a474b7          SUB      r4,r4,#0x16e
00019e  e002              B        |L1.422|
                  |L1.416|
;;;122    				else break;  
0001a0  e006              B        |L1.432|
                  |L1.418|
;;;123    			}
;;;124    			else 
;;;125    				temp-=365;	  //平年 
0001a2  f2a4146d          SUB      r4,r4,#0x16d
                  |L1.422|
;;;126    			temp1++;  
0001a6  1c68              ADDS     r0,r5,#1
0001a8  b285              UXTH     r5,r0
                  |L1.426|
0001aa  f5b47fb6          CMP      r4,#0x16c             ;117
0001ae  d8ed              BHI      |L1.396|
                  |L1.432|
0001b0  bf00              NOP                            ;122
;;;127    		}   
;;;128    		calendar.w_year=temp1;//得到年份
0001b2  48b3              LDR      r0,|L1.1152|
0001b4  8085              STRH     r5,[r0,#4]
;;;129    		temp1=0;
0001b6  2500              MOVS     r5,#0
;;;130    		while(temp>=28)//超过了一个月
0001b8  e016              B        |L1.488|
                  |L1.442|
;;;131    		{
;;;132    			if(Is_Leap_Year(calendar.w_year)&&temp1==1)//当年是不是闰年/2月份
0001ba  49b1              LDR      r1,|L1.1152|
0001bc  8888              LDRH     r0,[r1,#4]  ; calendar
0001be  f7fffffe          BL       Is_Leap_Year
0001c2  b130              CBZ      r0,|L1.466|
0001c4  2d01              CMP      r5,#1
0001c6  d104              BNE      |L1.466|
;;;133    			{
;;;134    				if(temp>=29)temp-=29;//闰年的秒钟数
0001c8  2c1d              CMP      r4,#0x1d
0001ca  d301              BCC      |L1.464|
0001cc  3c1d              SUBS     r4,r4,#0x1d
0001ce  e009              B        |L1.484|
                  |L1.464|
;;;135    				else break; 
0001d0  e00c              B        |L1.492|
                  |L1.466|
;;;136    			}
;;;137    			else 
;;;138    			{
;;;139    				if(temp>=mon_table[temp1])temp-=mon_table[temp1];//平年
0001d2  48a7              LDR      r0,|L1.1136|
0001d4  5d40              LDRB     r0,[r0,r5]
0001d6  42a0              CMP      r0,r4
0001d8  d803              BHI      |L1.482|
0001da  48a5              LDR      r0,|L1.1136|
0001dc  5d40              LDRB     r0,[r0,r5]
0001de  1a24              SUBS     r4,r4,r0
0001e0  e000              B        |L1.484|
                  |L1.482|
;;;140    				else break;
0001e2  e003              B        |L1.492|
                  |L1.484|
;;;141    			}
;;;142    			temp1++;  
0001e4  1c68              ADDS     r0,r5,#1
0001e6  b285              UXTH     r5,r0
                  |L1.488|
0001e8  2c1c              CMP      r4,#0x1c              ;130
0001ea  d2e6              BCS      |L1.442|
                  |L1.492|
0001ec  bf00              NOP                            ;135
;;;143    		}
;;;144    		calendar.w_month=temp1+1;	//得到月份
0001ee  1c68              ADDS     r0,r5,#1
0001f0  49a3              LDR      r1,|L1.1152|
0001f2  7188              STRB     r0,[r1,#6]
;;;145    		calendar.w_date=temp+1;  	//得到日期 
0001f4  1c60              ADDS     r0,r4,#1
0001f6  71c8              STRB     r0,[r1,#7]
                  |L1.504|
;;;146    	}
;;;147    	temp=timecount%86400;     		//得到秒钟数   	   
0001f8  489e              LDR      r0,|L1.1140|
0001fa  fbb6f1f0          UDIV     r1,r6,r0
0001fe  fb006411          MLS      r4,r0,r1,r6
;;;148    	calendar.hour=temp/3600;     	//小时
000202  f44f6061          MOV      r0,#0xe10
000206  fbb4f0f0          UDIV     r0,r4,r0
00020a  499d              LDR      r1,|L1.1152|
00020c  7008              STRB     r0,[r1,#0]
;;;149    	calendar.min=(temp%3600)/60; 	//分钟	
00020e  f44f6061          MOV      r0,#0xe10
000212  fbb4f1f0          UDIV     r1,r4,r0
000216  fb004011          MLS      r0,r0,r1,r4
00021a  213c              MOVS     r1,#0x3c
00021c  fbb0f0f1          UDIV     r0,r0,r1
000220  4997              LDR      r1,|L1.1152|
000222  7048              STRB     r0,[r1,#1]
;;;150    	calendar.sec=(temp%3600)%60; 	//秒钟
000224  f44f6061          MOV      r0,#0xe10
000228  fbb4f1f0          UDIV     r1,r4,r0
00022c  fb004011          MLS      r0,r0,r1,r4
000230  213c              MOVS     r1,#0x3c
000232  fbb0f2f1          UDIV     r2,r0,r1
000236  fb010012          MLS      r0,r1,r2,r0
00023a  4991              LDR      r1,|L1.1152|
00023c  7088              STRB     r0,[r1,#2]
;;;151    	calendar.week = RTC_Get_Week(calendar.w_year,calendar.w_month,calendar.w_date);//获取星期   
00023e  460b              MOV      r3,r1
000240  79da              LDRB     r2,[r3,#7]  ; calendar
000242  7999              LDRB     r1,[r3,#6]  ; calendar
000244  8898              LDRH     r0,[r3,#4]  ; calendar
000246  f7fffffe          BL       RTC_Get_Week
00024a  498d              LDR      r1,|L1.1152|
00024c  7208              STRB     r0,[r1,#8]
;;;152    	return timecount;
00024e  4630              MOV      r0,r6
;;;153    }	 
000250  bd70              POP      {r4-r6,pc}
;;;154    
                          ENDP

                  RTC_Configuration PROC
;;;160    */
;;;161    static void RTC_Configuration(void) 
000252  b51c              PUSH     {r2-r4,lr}
;;;162    {	
;;;163    	uint16_t	i = 0;
000254  2400              MOVS     r4,#0
;;;164    	
;;;165    	RCC_APB1PeriphClockCmd( RCC_APB1Periph_PWR | RCC_APB1Periph_BKP, ENABLE );	//使能电源与备份区时钟
000256  2101              MOVS     r1,#1
000258  f04f50c0          MOV      r0,#0x18000000
00025c  f7fffffe          BL       RCC_APB1PeriphClockCmd
;;;166    	PWR_BackupAccessCmd(ENABLE);//允许访问BKP备份域
000260  2001              MOVS     r0,#1
000262  f7fffffe          BL       PWR_BackupAccessCmd
;;;167    	BKP_TamperPinCmd(DISABLE);	//禁止侵入检测
000266  2000              MOVS     r0,#0
000268  f7fffffe          BL       BKP_TamperPinCmd
;;;168    	BKP_DeInit();				//复位备份域
00026c  f7fffffe          BL       BKP_DeInit
;;;169    	RCC_LSEConfig(RCC_LSE_ON);	//开启LSE
000270  2001              MOVS     r0,#1
000272  f7fffffe          BL       RCC_LSEConfig
;;;170    	
;;;171    	while (RCC_GetFlagStatus(RCC_FLAG_LSERDY) == RESET && i++ < 10000)//等待LSE起振
000276  e002              B        |L1.638|
                  |L1.632|
;;;172    	{
;;;173    		OSTimeDly(1);
000278  2001              MOVS     r0,#1
00027a  f7fffffe          BL       OSTimeDly
                  |L1.638|
00027e  2041              MOVS     r0,#0x41              ;171
000280  f7fffffe          BL       RCC_GetFlagStatus
000284  b930              CBNZ     r0,|L1.660|
000286  4620              MOV      r0,r4                 ;171
000288  1c61              ADDS     r1,r4,#1              ;171
00028a  b28c              UXTH     r4,r1                 ;171
00028c  f2427110          MOV      r1,#0x2710            ;171
000290  4288              CMP      r0,r1                 ;171
000292  dbf1              BLT      |L1.632|
                  |L1.660|
;;;174    	}
;;;175    	if(i >= 10000)
000294  f2427010          MOV      r0,#0x2710
000298  4284              CMP      r4,r0
00029a  db05              BLT      |L1.680|
;;;176    	{
;;;177    		lcd_show_character(&pt_word.warring[15]);//CRYSTAL ERR 晶振故障
00029c  4979              LDR      r1,|L1.1156|
00029e  6989              LDR      r1,[r1,#0x18]  ; pt_word
0002a0  f5017096          ADD      r0,r1,#0x12c
0002a4  f7fffffe          BL       lcd_show_character
                  |L1.680|
;;;178    	}
;;;179    	
;;;180    	RCC_RTCCLKConfig(RCC_RTCCLKSource_LSE);//选择LSE为RTC时钟源
0002a8  f44f7080          MOV      r0,#0x100
0002ac  f7fffffe          BL       RCC_RTCCLKConfig
;;;181    	RCC_RTCCLKCmd(ENABLE);			//RTC时钟使能
0002b0  2001              MOVS     r0,#1
0002b2  f7fffffe          BL       RCC_RTCCLKCmd
;;;182    	RTC_WaitForLastTask();			//等待最后对RTC寄存器的写操作完成
0002b6  f7fffffe          BL       RTC_WaitForLastTask
;;;183    	RTC_WaitForSynchro();			//等待RTC寄存器同步
0002ba  f7fffffe          BL       RTC_WaitForSynchro
;;;184    	RTC_WaitForLastTask();			//等待最后对RTC寄存器的写操作完成
0002be  f7fffffe          BL       RTC_WaitForLastTask
;;;185    	RTC_EnterConfigMode();			//进入 RTC 配置模式
0002c2  f7fffffe          BL       RTC_EnterConfigMode
;;;186    	RTC_SetPrescaler(32767); 		//设置RTC时钟分频值32767，则计数频率= (32.768 KHz)/(32767+1)=1Hz(1s)
0002c6  f64770ff          MOV      r0,#0x7fff
0002ca  f7fffffe          BL       RTC_SetPrescaler
;;;187    	RTC_WaitForLastTask();	  		//等待最后对RTC寄存器的写操作完成
0002ce  f7fffffe          BL       RTC_WaitForLastTask
;;;188    	RTC_Set(2017,5,1,0,0,0);    	//设置时间   
0002d2  2000              MOVS     r0,#0
0002d4  9000              STR      r0,[sp,#0]
0002d6  4603              MOV      r3,r0
0002d8  2201              MOVS     r2,#1
0002da  2105              MOVS     r1,#5
0002dc  9001              STR      r0,[sp,#4]
0002de  f24070e1          MOV      r0,#0x7e1
0002e2  f7fffffe          BL       RTC_Set
;;;189    	RTC_ExitConfigMode();         	//退出RTC配置模式
0002e6  f7fffffe          BL       RTC_ExitConfigMode
;;;190    	RTC_ITConfig(RTC_IT_SEC, ENABLE);//RTC 秒中断使能
0002ea  2101              MOVS     r1,#1
0002ec  4608              MOV      r0,r1
0002ee  f7fffffe          BL       RTC_ITConfig
;;;191    }
0002f2  bd1c              POP      {r2-r4,pc}
;;;192    
                          ENDP

                  RTC_NVIC_Config PROC
;;;196    //==========================
;;;197    static void RTC_NVIC_Config(void)
0002f4  b508              PUSH     {r3,lr}
;;;198    {       
;;;199    	NVIC_InitTypeDef NVIC_InitStruct;
;;;200        NVIC_InitStruct.NVIC_IRQChannel = RTC_IRQn;
0002f6  2003              MOVS     r0,#3
0002f8  f88d0000          STRB     r0,[sp,#0]
;;;201        NVIC_InitStruct.NVIC_IRQChannelPreemptionPriority = 1;
0002fc  2001              MOVS     r0,#1
0002fe  f88d0001          STRB     r0,[sp,#1]
;;;202        NVIC_InitStruct.NVIC_IRQChannelSubPriority = 2;
000302  2002              MOVS     r0,#2
000304  f88d0002          STRB     r0,[sp,#2]
;;;203        NVIC_InitStruct.NVIC_IRQChannelCmd = ENABLE;
000308  2001              MOVS     r0,#1
00030a  f88d0003          STRB     r0,[sp,#3]
;;;204        NVIC_Init(&NVIC_InitStruct);
00030e  4668              MOV      r0,sp
000310  f7fffffe          BL       NVIC_Init
;;;205    }
000314  bd08              POP      {r3,pc}
;;;206    
                          ENDP

                  Rtc_Init PROC
;;;210    */
;;;211    void Rtc_Init(void)
000316  b510              PUSH     {r4,lr}
;;;212    {
;;;213    	
;;;214    	if(BKP_ReadBackupRegister(BKP_DR1) != RTC_USER_FLAG)//检查备份区标志位
000318  2004              MOVS     r0,#4
00031a  f7fffffe          BL       BKP_ReadBackupRegister
00031e  f64a21aa          MOV      r1,#0xaaaa
000322  4288              CMP      r0,r1
000324  d01d              BEQ      |L1.866|
;;;215    	{
;;;216    		lcd_show_character(&pt_word.warring[13]);		//RTC尚未配置
000326  4957              LDR      r1,|L1.1156|
000328  6989              LDR      r1,[r1,#0x18]  ; pt_word
00032a  f5017082          ADD      r0,r1,#0x104
00032e  f7fffffe          BL       lcd_show_character
;;;217    		
;;;218    		RTC_Configuration();                            //RTC初始化配置
000332  f7fffffe          BL       RTC_Configuration
;;;219    		BKP_WriteBackupRegister(BKP_DR1, RTC_USER_FLAG);	 	//把备份区标志位写入BKP_DR1寄存器
000336  f64a21aa          MOV      r1,#0xaaaa
00033a  2004              MOVS     r0,#4
00033c  f7fffffe          BL       BKP_WriteBackupRegister
;;;220    		
;;;221    		if(flash_poweron_init() == TRUE)//flash数据并没有丢失
000340  f7fffffe          BL       flash_poweron_init
000344  2801              CMP      r0,#1
000346  d101              BNE      |L1.844|
;;;222    		{
;;;223    			flash_recovery();
000348  f7fffffe          BL       flash_recovery
                  |L1.844|
;;;224    		}
;;;225    		lcd_show_character(&pt_word.warring[14]);		//RTC复位成功
00034c  494d              LDR      r1,|L1.1156|
00034e  6989              LDR      r1,[r1,#0x18]  ; pt_word
000350  f501708c          ADD      r0,r1,#0x118
000354  f7fffffe          BL       lcd_show_character
;;;226    		OSTimeDly(OS_TICKS_PER_SEC*2);
000358  f44f60fa          MOV      r0,#0x7d0
00035c  f7fffffe          BL       OSTimeDly
000360  e01b              B        |L1.922|
                  |L1.866|
;;;227    	}
;;;228    	else//已配置过 RTC
;;;229    	{
;;;230    		if(RCC_GetFlagStatus(RCC_FLAG_PORRST) != RESET)       	//检查POWER是否发生复位标志
000362  207b              MOVS     r0,#0x7b
000364  f7fffffe          BL       RCC_GetFlagStatus
000368  b910              CBNZ     r0,|L1.880|
;;;231    		{
;;;232    			//LCD_ShowString("电源复位",displayLeftOffset , ROW_1, WHITE, FONT_48);	//RTC尚未配置
;;;233    		}
;;;234    		else 
;;;235    		if(RCC_GetFlagStatus(RCC_FLAG_PINRST) != RESET)	 //检查PIN复位标志设置
00036a  207a              MOVS     r0,#0x7a
00036c  f7fffffe          BL       RCC_GetFlagStatus
                  |L1.880|
;;;236    		{
;;;237    			//LCD_ShowString("按下复位键", displayLeftOffset , ROW_1, WHITE, FONT_48);
;;;238    		}
;;;239    
;;;240    		RCC_APB1PeriphClockCmd( RCC_APB1Periph_PWR | RCC_APB1Periph_BKP, ENABLE );	//使能电源与备份区时钟
000370  2101              MOVS     r1,#1
000372  f04f50c0          MOV      r0,#0x18000000
000376  f7fffffe          BL       RCC_APB1PeriphClockCmd
;;;241    		PWR_BackupAccessCmd(ENABLE);//允许访问BKP备份域
00037a  2001              MOVS     r0,#1
00037c  f7fffffe          BL       PWR_BackupAccessCmd
;;;242    		BKP_TamperPinCmd(DISABLE);	//禁止侵入检测
000380  2000              MOVS     r0,#0
000382  f7fffffe          BL       BKP_TamperPinCmd
;;;243    		
;;;244    		RTC_WaitForSynchro();	                    //等待RTC寄存器同步（等待最近一次对RTC寄存器的写操作完成 ）
000386  f7fffffe          BL       RTC_WaitForSynchro
;;;245    		RTC_ITConfig(RTC_IT_SEC, ENABLE);	        //RTC 秒中断使能
00038a  2101              MOVS     r1,#1
00038c  4608              MOV      r0,r1
00038e  f7fffffe          BL       RTC_ITConfig
;;;246    		RTC_WaitForLastTask();	                    //等待最后对RTC寄存器的写操作完成
000392  f7fffffe          BL       RTC_WaitForLastTask
;;;247    		
;;;248    		flash_poweron_init();
000396  f7fffffe          BL       flash_poweron_init
                  |L1.922|
;;;249    	}
;;;250      	RTC_NVIC_Config();//RCT 中断设置
00039a  f7fffffe          BL       RTC_NVIC_Config
;;;251    	RTC_Get();        //更新时间
00039e  f7fffffe          BL       RTC_Get
;;;252    	
;;;253    	e2p_poweron_init();			//e2prom上电初始化
0003a2  f7fffffe          BL       e2p_poweron_init
;;;254    	e2p_get_global();			//读取全局设置
0003a6  f7fffffe          BL       e2p_get_global
;;;255    	
;;;256    	return ;                                       
;;;257    }
0003aa  bd10              POP      {r4,pc}
;;;258    
                          ENDP

                  bkp_flash_reset PROC
;;;262    */
;;;263    void bkp_flash_reset(void)
0003ac  b53e              PUSH     {r1-r5,lr}
;;;264    {
;;;265    	uint8_t dat[10];
;;;266    	uint32_t time;
;;;267    	
;;;268    	time = RTC_Get();    	//读取时间 
0003ae  f7fffffe          BL       RTC_Get
0003b2  4604              MOV      r4,r0
;;;269    	BKP_WriteBackupRegister(BKP_DR1, 0);	//清除标志位
0003b4  2100              MOVS     r1,#0
0003b6  2004              MOVS     r0,#4
0003b8  f7fffffe          BL       BKP_WriteBackupRegister
;;;270    	RTC_Configuration();
0003bc  f7fffffe          BL       RTC_Configuration
;;;271    	BKP_WriteBackupRegister(BKP_DR1, RTC_USER_FLAG);	//恢复数据后重写备份区标志位，这里需要与开机检测标志位相同，否则会重新清除一次数据
0003c0  f64a21aa          MOV      r1,#0xaaaa
0003c4  2004              MOVS     r0,#4
0003c6  f7fffffe          BL       BKP_WriteBackupRegister
;;;272    	
;;;273    	//恢复rtc时间
;;;274    	RCC_APB1PeriphClockCmd(RCC_APB1Periph_PWR | RCC_APB1Periph_BKP, ENABLE);      //使能PWR 和BKP 外设时钟    
0003ca  2101              MOVS     r1,#1
0003cc  f04f50c0          MOV      r0,#0x18000000
0003d0  f7fffffe          BL       RCC_APB1PeriphClockCmd
;;;275    	PWR_BackupAccessCmd(ENABLE);      				//使能 RTC和后备寄存器访问   
0003d4  2001              MOVS     r0,#1
0003d6  f7fffffe          BL       PWR_BackupAccessCmd
;;;276    	RTC_SetCounter(time);                       //设置RTC计数器的值
0003da  4620              MOV      r0,r4
0003dc  f7fffffe          BL       RTC_SetCounter
;;;277    	RTC_WaitForLastTask();                        	//等待最近一次对RTC寄存器的写操作完成   
0003e0  f7fffffe          BL       RTC_WaitForLastTask
;;;278    	
;;;279    	do{
0003e4  bf00              NOP      
                  |L1.998|
;;;280    		sst26vf032b_erase(0, 0x3ff - 2);//擦除flash信息
0003e6  f24031fd          MOV      r1,#0x3fd
0003ea  2000              MOVS     r0,#0
0003ec  f7fffffe          BL       sst26vf032b_erase
;;;281    		sst26vf032b_read(0, 10 ,dat);	//读测试
0003f0  466a              MOV      r2,sp
0003f2  210a              MOVS     r1,#0xa
0003f4  2000              MOVS     r0,#0
0003f6  f7fffffe          BL       sst26vf032b_read
;;;282    	}while(!(dat[0] == 0xff && dat[3] == 0xff && dat[5] == 0xff && dat[7] == 0xff && dat[9] == 0xff));
0003fa  f89d0000          LDRB     r0,[sp,#0]
0003fe  28ff              CMP      r0,#0xff
000400  d1f1              BNE      |L1.998|
000402  f89d0003          LDRB     r0,[sp,#3]
000406  28ff              CMP      r0,#0xff
000408  d1ed              BNE      |L1.998|
00040a  f89d0005          LDRB     r0,[sp,#5]
00040e  28ff              CMP      r0,#0xff
000410  d1e9              BNE      |L1.998|
000412  f89d0007          LDRB     r0,[sp,#7]
000416  28ff              CMP      r0,#0xff
000418  d1e5              BNE      |L1.998|
00041a  f89d0009          LDRB     r0,[sp,#9]
00041e  28ff              CMP      r0,#0xff
000420  d1e1              BNE      |L1.998|
;;;283    }	
000422  bd3e              POP      {r1-r5,pc}
;;;284    	
                          ENDP

                  RTC_IRQHandler PROC
;;;289    //======================================
;;;290    void RTC_IRQHandler(void)
000424  b510              PUSH     {r4,lr}
;;;291    {
;;;292    	if(RTC_GetITStatus(RTC_IT_SEC) != RESET)//秒中断
000426  2001              MOVS     r0,#1
000428  f7fffffe          BL       RTC_GetITStatus
00042c  b120              CBZ      r0,|L1.1080|
;;;293    	{
;;;294    		RTC_ClearITPendingBit(RTC_IT_SEC);    		//清除中断标志位
00042e  2001              MOVS     r0,#1
000430  f7fffffe          BL       RTC_ClearITPendingBit
;;;295    		RTC_Get();									//更新时间
000434  f7fffffe          BL       RTC_Get
                  |L1.1080|
;;;296    	}
;;;297    //	if(RTC_GetITStatus(RTC_IT_ALR)!= RESET)         //闹钟中断 
;;;298    //	{ 
;;;299    //	  RTC_ClearITPendingBit(RTC_IT_ALR);      		//清闹钟中断         
;;;300    //	}                                
;;;301    	RTC_ClearITPendingBit(RTC_IT_SEC | RTC_IT_OW); 	//清秒中断与闹钟中断标志位
000438  2005              MOVS     r0,#5
00043a  f7fffffe          BL       RTC_ClearITPendingBit
;;;302    	RTC_WaitForLastTask();				        	//等待 RTC 写操作完成
00043e  f7fffffe          BL       RTC_WaitForLastTask
;;;303      
;;;304    }
000442  bd10              POP      {r4,pc}
;;;305    
                          ENDP

                  time_check PROC
;;;306    
;;;307    void time_check(void)
000444  4770              BX       lr
;;;308    {
;;;309    //	 time_t timer = 3600,time2,time3;
;;;310    //	uint8_t kk;
;;;311    //	char tmp[50];
;;;312    //	char *ttp;
;;;313    //	//time_t??long int ??   
;;;314    //	struct tm *tblock, *ff,*tt;
;;;315    //	struct tm tkkkk,fuck;
;;;316    //	ff = &fuck;
;;;317    //	
;;;318    //	tkkkk.tm_year = 117;
;;;319    //	tkkkk.tm_mon = 6;
;;;320    //	tkkkk.tm_mday = 17;
;;;321    //	tkkkk.tm_hour = 20;
;;;322    //	tkkkk.tm_min = 41;
;;;323    //	tkkkk.tm_sec = 10;
;;;324    ////	tkkkk.tm_wday = 0;
;;;325    //	
;;;326    //	tkkkk.tm_isdst = 0;//不实行夏令时
;;;327    ////	tkkkk.tm_yday = 0;
;;;328    //	
;;;329    //	tblock = &tkkkk;
;;;330    // 
;;;331    //	time2 = mktime(tblock);//时间格式转换为秒，从1900年开始
;;;332    //	
;;;333    //	time3 = time2;
;;;334    
;;;335    ////	timer = time(NULL);//????????time(&timer);   //获得系统时间，这个要自己写
;;;336    //	ff = localtime(&time3); //得到本地时间；可以用
;;;337    //	ttp = asctime(ff);		//转换时间为字符串
;;;338    ////	ttp = ctime(&time3);	//转换时间为字符串
;;;339    //	show_string (ttp,0,300);//可用
;;;340    //	tt = gmtime(&time2);	//得到世界时间（用不了）
;;;341    //	kk = 0;
;;;342    //	
;;;343    ////	printf("%d year %02d month %02d day",(1900+p->tm_year),(1+p->tm_mon),p->tm_mday);
;;;344    
;;;345    }
;;;346    
                          ENDP

                  set_rtc_time PROC
;;;350    */
;;;351    bool set_rtc_time(uint8_t type, uint16_t year, uint8_t month, uint8_t day, uint8_t hour, uint8_t min, uint8_t sec)
000446  e92d47fc          PUSH     {r2-r10,lr}
;;;352    {
00044a  4604              MOV      r4,r0
00044c  460d              MOV      r5,r1
00044e  4616              MOV      r6,r2
000450  461f              MOV      r7,r3
000452  e9dda80a          LDRD     r10,r8,[sp,#0x28]
000456  f8dd9030          LDR      r9,[sp,#0x30]
;;;353    	if(year > 100 && type == 1)
00045a  2d64              CMP      r5,#0x64
00045c  dd14              BLE      |L1.1160|
00045e  2c01              CMP      r4,#1
000460  d112              BNE      |L1.1160|
;;;354    		return FALSE;
000462  2000              MOVS     r0,#0
                  |L1.1124|
;;;355    	if(month < 1 || month > 12)
;;;356    		return FALSE;
;;;357    	if(day < 1 || day > 31)
;;;358    		return FALSE;
;;;359    	if(hour > 23)
;;;360    		return FALSE;
;;;361    	if(min > 59)
;;;362    		return FALSE;
;;;363    	if(sec > 59)
;;;364    		return FALSE;
;;;365    	
;;;366    	if(type == 0)//设置 日期/时间
;;;367    	{
;;;368    		return RTC_Set(year, month, day, hour, min, sec);
;;;369    	}
;;;370    	else
;;;371    	if(type == 1)//设置 日期+时间
;;;372    	{
;;;373    		return RTC_Set(year + 2000, month, day, hour, min, sec);
;;;374    	}
;;;375    	return FALSE;
;;;376    }
000464  e8bd87fc          POP      {r2-r10,pc}
                  |L1.1128|
                          DCD      0x01e28500
                  |L1.1132|
                          DCD      0x01e13380
                  |L1.1136|
                          DCD      mon_table
                  |L1.1140|
                          DCD      0x00015180
                  |L1.1144|
                          DCD      table_week
                  |L1.1148|
                          DCD      daycnt
                  |L1.1152|
                          DCD      calendar
                  |L1.1156|
                          DCD      pt_word
                  |L1.1160|
000488  2e01              CMP      r6,#1                 ;355
00048a  db01              BLT      |L1.1168|
00048c  2e0c              CMP      r6,#0xc               ;355
00048e  dd01              BLE      |L1.1172|
                  |L1.1168|
000490  2000              MOVS     r0,#0                 ;356
000492  e7e7              B        |L1.1124|
                  |L1.1172|
000494  2f01              CMP      r7,#1                 ;357
000496  db01              BLT      |L1.1180|
000498  2f1f              CMP      r7,#0x1f              ;357
00049a  dd01              BLE      |L1.1184|
                  |L1.1180|
00049c  2000              MOVS     r0,#0                 ;358
00049e  e7e1              B        |L1.1124|
                  |L1.1184|
0004a0  f1ba0f17          CMP      r10,#0x17             ;359
0004a4  dd01              BLE      |L1.1194|
0004a6  2000              MOVS     r0,#0                 ;360
0004a8  e7dc              B        |L1.1124|
                  |L1.1194|
0004aa  f1b80f3b          CMP      r8,#0x3b              ;361
0004ae  dd01              BLE      |L1.1204|
0004b0  2000              MOVS     r0,#0                 ;362
0004b2  e7d7              B        |L1.1124|
                  |L1.1204|
0004b4  f1b90f3b          CMP      r9,#0x3b              ;363
0004b8  dd01              BLE      |L1.1214|
0004ba  2000              MOVS     r0,#0                 ;364
0004bc  e7d2              B        |L1.1124|
                  |L1.1214|
0004be  b944              CBNZ     r4,|L1.1234|
0004c0  4653              MOV      r3,r10                ;368
0004c2  463a              MOV      r2,r7                 ;368
0004c4  4631              MOV      r1,r6                 ;368
0004c6  4628              MOV      r0,r5                 ;368
0004c8  e9cd8900          STRD     r8,r9,[sp,#0]         ;368
0004cc  f7fffffe          BL       RTC_Set
0004d0  e7c8              B        |L1.1124|
                  |L1.1234|
0004d2  2c01              CMP      r4,#1                 ;371
0004d4  d10a              BNE      |L1.1260|
0004d6  f50561fa          ADD      r1,r5,#0x7d0          ;373
0004da  b288              UXTH     r0,r1                 ;373
0004dc  4653              MOV      r3,r10                ;373
0004de  463a              MOV      r2,r7                 ;373
0004e0  4631              MOV      r1,r6                 ;373
0004e2  e9cd8900          STRD     r8,r9,[sp,#0]         ;373
0004e6  f7fffffe          BL       RTC_Set
0004ea  e7bb              B        |L1.1124|
                  |L1.1260|
0004ec  2000              MOVS     r0,#0                 ;375
0004ee  e7b9              B        |L1.1124|
;;;377    
                          ENDP


                          AREA ||.bss||, DATA, NOINIT, ALIGN=1

                  calendar
                          %        10

                          AREA ||.constdata||, DATA, READONLY, ALIGN=0

                  table_week
000000  00030306          DCB      0x00,0x03,0x03,0x06
000004  01040602          DCB      0x01,0x04,0x06,0x02
000008  05000305          DCB      0x05,0x00,0x03,0x05
                  mon_table
00000c  1f1c1f1e          DCB      0x1f,0x1c,0x1f,0x1e
000010  1f1e1f1f          DCB      0x1f,0x1e,0x1f,0x1f
000014  1e1f1e1f          DCB      0x1e,0x1f,0x1e,0x1f

                          AREA ||.data||, DATA, ALIGN=2

                  THH
                          DCD      0x00000000
                  TMM
                          DCD      0x00000000
                  TSS
                          DCD      0x00000000
                  daycnt
00000c  0000              DCW      0x0000

;*** Start embedded assembler ***

#line 1 "..\\bsp_lib\\rtc.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___5_rtc_c_THH____REV16|
#line 129 "C:\\Keil_v5\\ARM\\CMSIS\\Include\\core_cmInstr.h"
|__asm___5_rtc_c_THH____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___5_rtc_c_THH____REVSH|
#line 144
|__asm___5_rtc_c_THH____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
