; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\output\stm32f10x_it.o --asm_dir=.\Listing\ --list_dir=.\Listing\ --depend=.\output\stm32f10x_it.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x -I..\bsp_lib -I..\UCOSII\port -I..\UCOSII\src -I..\UCOSII\uC-CPU -I..\Libraries\CMSIS -I..\User\INCLUDES -I..\LCD -I..\USR\Global -I..\USR -I..\USR\FSM -I..\USR\Commucation -I..\USR\Mdb -I..\USR\Drop -I..\USR\DriverBoard -I..\USR\Flash -I..\USR\Card -I..\USR\MSG -I..\USR\Bsp -I..\USR\SetPar -I..\User\QRCode -I..\USR\MEM -I..\USR\QRCode -I..\USR\SETUP -I..\USR\stm32 -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -IC:\Keil_v5\ARM\INC\ST\STM32F10x -D__MICROLIB -D__UVISION_VERSION=525 -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER --omf_browse=.\output\stm32f10x_it.crf ..\USR\stm32\stm32f10x_it.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  NMI_Handler PROC
;;;24     *******************************************************************************/
;;;25     void NMI_Handler(void)
000000  4770              BX       lr
;;;26     {
;;;27     }
;;;28     
                          ENDP

                  HardFault_Handler PROC
;;;35     *******************************************************************************/
;;;36     void HardFault_Handler(void)
000002  4910              LDR      r1,|L1.68|
;;;37     {
;;;38         //当硬件错误发生时进入死循环 
;;;39     	lcd_show_character(&pt_word.warring[8]); 		
000004  6989              LDR      r1,[r1,#0x18]  ; pt_word
000006  f10100a0          ADD      r0,r1,#0xa0
00000a  f7fffffe          BL       lcd_show_character
;;;40     
;;;41         while (1)
00000e  bf00              NOP      
                  |L1.16|
000010  e7fe              B        |L1.16|
;;;42         {
;;;43         }
;;;44     }
;;;45     
                          ENDP

                  MemManage_Handler PROC
;;;52     *******************************************************************************/
;;;53     void MemManage_Handler(void)
000012  bf00              NOP      
                  |L1.20|
;;;54     {
;;;55         //当内存管理中断发生时进入死循环 
;;;56         while (1)
000014  e7fe              B        |L1.20|
;;;57         {
;;;58         }
;;;59     }
;;;60     
                          ENDP

                  BusFault_Handler PROC
;;;67     *******************************************************************************/
;;;68     void BusFault_Handler(void)
000016  bf00              NOP      
                  |L1.24|
;;;69     {
;;;70         //当总线错误发生时进入死循环 
;;;71         while (1)
000018  e7fe              B        |L1.24|
;;;72         {
;;;73         }
;;;74     }
;;;75     
                          ENDP

                  UsageFault_Handler PROC
;;;82     *******************************************************************************/
;;;83     void UsageFault_Handler(void)
00001a  bf00              NOP      
                  |L1.28|
;;;84     {
;;;85         //当Usage 错误发生时进入死循环 
;;;86         while (1)
00001c  e7fe              B        |L1.28|
;;;87         {
;;;88         }
;;;89     }
;;;90     
                          ENDP

                  SVC_Handler PROC
;;;97     *******************************************************************************/
;;;98     void SVC_Handler(void)
00001e  4770              BX       lr
;;;99     {
;;;100    }
;;;101    
                          ENDP

                  DebugMon_Handler PROC
;;;108    *******************************************************************************/
;;;109    void DebugMon_Handler(void)
000020  4770              BX       lr
;;;110    {
;;;111    }
;;;112    
                          ENDP

                  SysTick_Handler PROC
;;;119    *******************************************************************************/
;;;120    void SysTick_Handler(void)
000022  b510              PUSH     {r4,lr}
;;;121    {
;;;122    	OS_CPU_SR  cpu_sr;
;;;123    
;;;124    
;;;125        OS_ENTER_CRITICAL();  //保存全局中断标志,关总中断/* Tell uC/OS-II that we are starting an ISR*/
000024  f7fffffe          BL       OS_CPU_SR_Save
000028  4604              MOV      r4,r0
;;;126        OSIntNesting++;
00002a  4807              LDR      r0,|L1.72|
00002c  7800              LDRB     r0,[r0,#0]  ; OSIntNesting
00002e  1c40              ADDS     r0,r0,#1
000030  4905              LDR      r1,|L1.72|
000032  7008              STRB     r0,[r1,#0]
;;;127        OS_EXIT_CRITICAL();	  //恢复全局中断标志
000034  4620              MOV      r0,r4
000036  f7fffffe          BL       OS_CPU_SR_Restore
;;;128    
;;;129        OSTimeTick();     /* Call uC/OS-II's OSTimeTick(),在os_core.c文件里定义,主要判断延时的任务是否计时到*/
00003a  f7fffffe          BL       OSTimeTick
;;;130    
;;;131        OSIntExit();  //在os_core.c文件里定义,如果有更高优先级的任务就绪了,则执行一次任务切换  
00003e  f7fffffe          BL       OSIntExit
;;;132    }
000042  bd10              POP      {r4,pc}
;;;133    /******************************************************************************/
                          ENDP

                  |L1.68|
                          DCD      pt_word
                  |L1.72|
                          DCD      OSIntNesting

;*** Start embedded assembler ***

#line 1 "..\\USR\\stm32\\stm32f10x_it.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___14_stm32f10x_it_c_bb8ca80c____REV16|
#line 129 "C:\\Keil_v5\\ARM\\CMSIS\\Include\\core_cmInstr.h"
|__asm___14_stm32f10x_it_c_bb8ca80c____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___14_stm32f10x_it_c_bb8ca80c____REVSH|
#line 144
|__asm___14_stm32f10x_it_c_bb8ca80c____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
