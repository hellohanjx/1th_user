; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\output\drv.o --asm_dir=.\Listing\ --list_dir=.\Listing\ --depend=.\output\drv.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x -I..\bsp_lib -I..\UCOSII\port -I..\UCOSII\src -I..\UCOSII\uC-CPU -I..\Libraries\CMSIS -I..\User\INCLUDES -I..\LCD -I..\USR\Global -I..\USR -I..\USR\FSM -I..\USR\Commucation -I..\USR\Mdb -I..\USR\Drop -I..\USR\DriverBoard -I..\USR\Flash -I..\USR\Card -I..\USR\MSG -I..\USR\Bsp -I..\USR\SetPar -I..\User\QRCode -I..\USR\MEM -I..\USR\QRCode -I..\USR\SETUP -I..\USR\stm32 -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -IC:\Keil_v5\ARM\INC\ST\STM32F10x -D__MICROLIB -D__UVISION_VERSION=525 -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER --omf_browse=.\output\drv.crf ..\USR\DriverBoard\drv.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  isRecvFinished PROC
;;;80     */
;;;81     static bool isRecvFinished(volatile uint8_t* data,volatile uint8_t* len)
000000  b530              PUSH     {r4,r5,lr}
;;;82     {
000002  4602              MOV      r2,r0
;;;83     	uint8_t i,chk;
;;;84     	
;;;85     	if(data[0] == S_STX)
000004  7810              LDRB     r0,[r2,#0]
000006  2840              CMP      r0,#0x40
000008  d119              BNE      |L1.62|
;;;86     	{
;;;87     		if(*len == (data[3] << 8 | data[4]))//包长符合
00000a  7910              LDRB     r0,[r2,#4]
00000c  78d5              LDRB     r5,[r2,#3]
00000e  ea402005          ORR      r0,r0,r5,LSL #8
000012  780d              LDRB     r5,[r1,#0]
000014  42a8              CMP      r0,r5
000016  d112              BNE      |L1.62|
;;;88     		{
;;;89     			//计算校验
;;;90     			for(i = 0, chk = 0; i < *len - 1; i++)
000018  2300              MOVS     r3,#0
00001a  2400              MOVS     r4,#0
00001c  e004              B        |L1.40|
                  |L1.30|
;;;91     			{
;;;92     				chk += data[i];
00001e  5cd0              LDRB     r0,[r2,r3]
000020  4420              ADD      r0,r0,r4
000022  b2c4              UXTB     r4,r0
000024  1c58              ADDS     r0,r3,#1              ;90
000026  b2c3              UXTB     r3,r0                 ;90
                  |L1.40|
000028  7808              LDRB     r0,[r1,#0]            ;90
00002a  1e40              SUBS     r0,r0,#1              ;90
00002c  4298              CMP      r0,r3                 ;90
00002e  dcf6              BGT      |L1.30|
;;;93     			}
;;;94     			
;;;95     			if(chk == data[(*len) - 1])//校验通过
000030  7808              LDRB     r0,[r1,#0]
000032  1e40              SUBS     r0,r0,#1
000034  5c10              LDRB     r0,[r2,r0]
000036  42a0              CMP      r0,r4
000038  d101              BNE      |L1.62|
;;;96     			{
;;;97     				return TRUE;
00003a  2001              MOVS     r0,#1
                  |L1.60|
;;;98     			}
;;;99     		}
;;;100    	}
;;;101    	return FALSE;
;;;102    }
00003c  bd30              POP      {r4,r5,pc}
                  |L1.62|
00003e  2000              MOVS     r0,#0                 ;101
000040  e7fc              B        |L1.60|
;;;103    
                          ENDP

                  driverboard_state_change PROC
;;;107    */
;;;108    static void driverboard_state_change(uint8_t addr, uint8_t state)
000042  b570              PUSH     {r4-r6,lr}
;;;109    {
000044  4604              MOV      r4,r0
000046  460d              MOV      r5,r1
;;;110    	
;;;111    	if(addr > 9)//防止指针错误
000048  2c09              CMP      r4,#9
00004a  dd00              BLE      |L1.78|
                  |L1.76|
;;;112    		return;
;;;113    	if(state != pt_driverBoard[addr]->state && pt_driverBoard[addr] != 0)
;;;114    	{
;;;115    		if(pt_driverBoard[addr]->state == INIT)
;;;116    		{
;;;117    			FSMMSG *to_fsm;
;;;118    			to_fsm = apply_fsm_msg(FSMMSG_SIZE_DEFAULT);
;;;119    			log_output(to_fsm);
;;;120    			if(to_fsm != 0)
;;;121    			{
;;;122    				pt_driverBoard[addr]->state = state;
;;;123    				to_fsm->type = MsgCHAN;
;;;124    				to_fsm->stype = M_DRV_INIT;
;;;125    				to_fsm->value = state; 
;;;126    				if(!send_fsm_msg(to_fsm))
;;;127    				release_fsm_msg(to_fsm);
;;;128    			}
;;;129    		}
;;;130    		else
;;;131    		{
;;;132    			pt_driverBoard[addr]->state = state;
;;;133    			report_state_change(STATE_DRV, (addr + 1), state);//驱动状态改变
;;;134    		}
;;;135    	}
;;;136    }
00004c  bd70              POP      {r4-r6,pc}
                  |L1.78|
00004e  48fe              LDR      r0,|L1.1096|
000050  f8500024          LDR      r0,[r0,r4,LSL #2]     ;113
000054  7800              LDRB     r0,[r0,#0]            ;113
000056  42a8              CMP      r0,r5                 ;113
000058  d027              BEQ      |L1.170|
00005a  48fb              LDR      r0,|L1.1096|
00005c  f8500024          LDR      r0,[r0,r4,LSL #2]     ;113
000060  b318              CBZ      r0,|L1.170|
000062  48f9              LDR      r0,|L1.1096|
000064  f8500024          LDR      r0,[r0,r4,LSL #2]     ;115
000068  7800              LDRB     r0,[r0,#0]            ;115
00006a  2802              CMP      r0,#2                 ;115
00006c  d114              BNE      |L1.152|
00006e  2000              MOVS     r0,#0                 ;118
000070  f7fffffe          BL       apply_fsm_msg
000074  4606              MOV      r6,r0                 ;118
000076  b176              CBZ      r6,|L1.150|
000078  48f3              LDR      r0,|L1.1096|
00007a  f8500024          LDR      r0,[r0,r4,LSL #2]     ;122
00007e  7005              STRB     r5,[r0,#0]            ;122
000080  2006              MOVS     r0,#6                 ;123
000082  7030              STRB     r0,[r6,#0]            ;123
000084  7070              STRB     r0,[r6,#1]            ;124
000086  6075              STR      r5,[r6,#4]            ;125
000088  4630              MOV      r0,r6                 ;126
00008a  f7fffffe          BL       send_fsm_msg
00008e  b910              CBNZ     r0,|L1.150|
000090  4630              MOV      r0,r6                 ;127
000092  f7fffffe          BL       release_fsm_msg
                  |L1.150|
000096  e008              B        |L1.170|
                  |L1.152|
000098  48eb              LDR      r0,|L1.1096|
00009a  f8500024          LDR      r0,[r0,r4,LSL #2]     ;132
00009e  7005              STRB     r5,[r0,#0]            ;132
0000a0  462a              MOV      r2,r5                 ;133
0000a2  1c61              ADDS     r1,r4,#1              ;133
0000a4  2005              MOVS     r0,#5                 ;133
0000a6  f7fffffe          BL       report_state_change
                  |L1.170|
0000aa  bf00              NOP      
0000ac  e7ce              B        |L1.76|
;;;137    
                          ENDP

                  send_cmd PROC
;;;146    */
;;;147    static uint8_t send_cmd(uint8_t addr, uint8_t *cmd, uint16_t cmd_len ,uint8_t *recv)
0000ae  e92d4ff0          PUSH     {r4-r11,lr}
;;;148    {
0000b2  b087              SUB      sp,sp,#0x1c
0000b4  4605              MOV      r5,r0
0000b6  4688              MOV      r8,r1
0000b8  4691              MOV      r9,r2
0000ba  469a              MOV      r10,r3
;;;149    	uint8_t rs ,j,err, chk;
;;;150    	UART485_CMD_DATA str;
;;;151    	
;;;152    	bus_Lock_485();//锁住发送过程
0000bc  f7fffffe          BL       bus_Lock_485
;;;153    	
;;;154    	rs = OS_TIMEOUT;
0000c0  200a              MOVS     r0,#0xa
0000c2  9006              STR      r0,[sp,#0x18]
;;;155    	err = OS_TIMEOUT;
0000c4  9005              STR      r0,[sp,#0x14]
;;;156    	
;;;157    	str.cmd = _malloc(63, &err);//申请内存
0000c6  a905              ADD      r1,sp,#0x14
0000c8  203f              MOVS     r0,#0x3f
0000ca  f7fffffe          BL       _malloc
0000ce  9001              STR      r0,[sp,#4]
;;;158    	
;;;159    	log_output(str.cmd);
;;;160    	
;;;161    	if(err == OS_NO_ERR)
0000d0  f89d0014          LDRB     r0,[sp,#0x14]
0000d4  2800              CMP      r0,#0
0000d6  d17d              BNE      |L1.468|
;;;162    	{
;;;163    		rs = OS_TIMEOUT;
0000d8  200a              MOVS     r0,#0xa
0000da  9006              STR      r0,[sp,#0x18]
;;;164    		str.recv = recv;					//接收缓冲区指向
0000dc  f8cda008          STR      r10,[sp,#8]
;;;165    		str.needAck = TRUE;					//指令需要应答
0000e0  2001              MOVS     r0,#1
0000e2  f88d0000          STRB     r0,[sp,#0]
;;;166    		str.timeout = OS_TICKS_PER_SEC/3;	//返回等待超时时间
0000e6  f240104d          MOV      r0,#0x14d
0000ea  f8ad000e          STRH     r0,[sp,#0xe]
;;;167    		str.isFinished = isRecvFinished;	//返回处理函数，其实就是个回调函数
0000ee  48d7              LDR      r0,|L1.1100|
0000f0  9004              STR      r0,[sp,#0x10]
;;;168    		
;;;169    		str.cmd_len = 0;
0000f2  2000              MOVS     r0,#0
0000f4  f88d0001          STRB     r0,[sp,#1]
;;;170    		str.cmd[str.cmd_len++] = M_STX;		//包头
0000f8  2224              MOVS     r2,#0x24
0000fa  f89d1001          LDRB     r1,[sp,#1]
0000fe  1c48              ADDS     r0,r1,#1
000100  b2c0              UXTB     r0,r0
000102  f88d0001          STRB     r0,[sp,#1]
000106  9801              LDR      r0,[sp,#4]
000108  5442              STRB     r2,[r0,r1]
;;;171    		str.cmd[str.cmd_len++] = M_ADDR;	//主机地址
00010a  2201              MOVS     r2,#1
00010c  f89d1001          LDRB     r1,[sp,#1]
000110  1c48              ADDS     r0,r1,#1
000112  b2c0              UXTB     r0,r0
000114  f88d0001          STRB     r0,[sp,#1]
000118  9801              LDR      r0,[sp,#4]
00011a  5442              STRB     r2,[r0,r1]
;;;172    		str.cmd[str.cmd_len++] = addr;		//驱动板地址
00011c  f89d1001          LDRB     r1,[sp,#1]
000120  1c48              ADDS     r0,r1,#1
000122  b2c0              UXTB     r0,r0
000124  f88d0001          STRB     r0,[sp,#1]
000128  9801              LDR      r0,[sp,#4]
00012a  5445              STRB     r5,[r0,r1]
;;;173    		str.cmd[str.cmd_len++] = ' ';		//包长
00012c  2120              MOVS     r1,#0x20
00012e  f89d2001          LDRB     r2,[sp,#1]
000132  1c50              ADDS     r0,r2,#1
000134  b2c0              UXTB     r0,r0
000136  f88d0001          STRB     r0,[sp,#1]
00013a  9801              LDR      r0,[sp,#4]
00013c  5481              STRB     r1,[r0,r2]
;;;174    		str.cmd[str.cmd_len++] = ' ';
00013e  2220              MOVS     r2,#0x20
000140  f89d1001          LDRB     r1,[sp,#1]
000144  1c48              ADDS     r0,r1,#1
000146  b2c0              UXTB     r0,r0
000148  f88d0001          STRB     r0,[sp,#1]
00014c  9801              LDR      r0,[sp,#4]
00014e  5442              STRB     r2,[r0,r1]
;;;175    		for(j = 0;j < cmd_len ;j++)//填充数据
000150  2400              MOVS     r4,#0
000152  e00b              B        |L1.364|
                  |L1.340|
;;;176    		{
;;;177    			str.cmd[str.cmd_len++] = cmd[j];
000154  f8181004          LDRB     r1,[r8,r4]
000158  f89d2001          LDRB     r2,[sp,#1]
00015c  1c50              ADDS     r0,r2,#1
00015e  b2c0              UXTB     r0,r0
000160  f88d0001          STRB     r0,[sp,#1]
000164  9801              LDR      r0,[sp,#4]
000166  5481              STRB     r1,[r0,r2]
000168  1c60              ADDS     r0,r4,#1              ;175
00016a  b2c4              UXTB     r4,r0                 ;175
                  |L1.364|
00016c  454c              CMP      r4,r9                 ;175
00016e  dbf1              BLT      |L1.340|
;;;178    		}
;;;179    		str.cmd[3] = (str.cmd_len + 1) >> 8;		//包长
000170  f89d0001          LDRB     r0,[sp,#1]
000174  1c40              ADDS     r0,r0,#1
000176  1200              ASRS     r0,r0,#8
000178  9901              LDR      r1,[sp,#4]
00017a  70c8              STRB     r0,[r1,#3]
;;;180    		str.cmd[4] = (str.cmd_len + 1);
00017c  f89d0001          LDRB     r0,[sp,#1]
000180  1c40              ADDS     r0,r0,#1
000182  9901              LDR      r1,[sp,#4]
000184  7108              STRB     r0,[r1,#4]
;;;181    		
;;;182    		//添加校验
;;;183    		for(j = 0, chk = 0; j < str.cmd_len; j++)
000186  2400              MOVS     r4,#0
000188  2600              MOVS     r6,#0
00018a  e005              B        |L1.408|
                  |L1.396|
;;;184    		{
;;;185    			chk +=  str.cmd[j];
00018c  9801              LDR      r0,[sp,#4]
00018e  5d00              LDRB     r0,[r0,r4]
000190  4430              ADD      r0,r0,r6
000192  b2c6              UXTB     r6,r0
000194  1c60              ADDS     r0,r4,#1              ;183
000196  b2c4              UXTB     r4,r0                 ;183
                  |L1.408|
000198  f89d0001          LDRB     r0,[sp,#1]            ;183
00019c  42a0              CMP      r0,r4                 ;183
00019e  dcf5              BGT      |L1.396|
;;;186    		}
;;;187    		str.cmd[str.cmd_len++] = chk;
0001a0  f89d1001          LDRB     r1,[sp,#1]
0001a4  1c48              ADDS     r0,r1,#1
0001a6  b2c0              UXTB     r0,r0
0001a8  f88d0001          STRB     r0,[sp,#1]
0001ac  9801              LDR      r0,[sp,#4]
0001ae  5446              STRB     r6,[r0,r1]
;;;188    		
;;;189    		if(send_to_485Bus(&str) == OS_NO_ERR)//收到数据
0001b0  4668              MOV      r0,sp
0001b2  f7fffffe          BL       send_to_485Bus
0001b6  2800              CMP      r0,#0
0001b8  d17e              BNE      |L1.696|
;;;190    		{
;;;191    			if(str.recv[2] == str.cmd[2])//驱动板地址符合
0001ba  9802              LDR      r0,[sp,#8]
0001bc  7880              LDRB     r0,[r0,#2]
0001be  9901              LDR      r1,[sp,#4]
0001c0  7889              LDRB     r1,[r1,#2]
0001c2  4288              CMP      r0,r1
0001c4  d179              BNE      |L1.698|
;;;192    			{
;;;193    				if(str.recv[5] == str.cmd[5])//是对发送指令的应答
0001c6  9802              LDR      r0,[sp,#8]
0001c8  7940              LDRB     r0,[r0,#5]
0001ca  9901              LDR      r1,[sp,#4]
0001cc  7949              LDRB     r1,[r1,#5]
0001ce  4288              CMP      r0,r1
0001d0  d174              BNE      |L1.700|
;;;194    				{
;;;195    					if(str.recv[6] == 1)//驱动板接收命令
0001d2  e000              B        |L1.470|
                  |L1.468|
0001d4  e0a9              B        |L1.810|
                  |L1.470|
0001d6  9802              LDR      r0,[sp,#8]
0001d8  7980              LDRB     r0,[r0,#6]
0001da  2801              CMP      r0,#1
0001dc  d16f              BNE      |L1.702|
;;;196    					{
;;;197    						uint8_t chk, i;
;;;198    						err = OS_TIMEOUT;
0001de  200a              MOVS     r0,#0xa
0001e0  9005              STR      r0,[sp,#0x14]
;;;199    						/*
;;;200    						命令执行情况查询
;;;201    						这条指令是固定的
;;;202    						*/
;;;203    						str.cmd_len = 0;
0001e2  2000              MOVS     r0,#0
0001e4  f88d0001          STRB     r0,[sp,#1]
;;;204    						str.cmd[str.cmd_len++] = M_STX;		//包头
0001e8  2124              MOVS     r1,#0x24
0001ea  f89d2001          LDRB     r2,[sp,#1]
0001ee  1c50              ADDS     r0,r2,#1
0001f0  b2c0              UXTB     r0,r0
0001f2  f88d0001          STRB     r0,[sp,#1]
0001f6  9801              LDR      r0,[sp,#4]
0001f8  5481              STRB     r1,[r0,r2]
;;;205    						str.cmd[str.cmd_len++] = M_ADDR;	//主机地址
0001fa  2101              MOVS     r1,#1
0001fc  f89d2001          LDRB     r2,[sp,#1]
000200  1c50              ADDS     r0,r2,#1
000202  b2c0              UXTB     r0,r0
000204  f88d0001          STRB     r0,[sp,#1]
000208  9801              LDR      r0,[sp,#4]
00020a  5481              STRB     r1,[r0,r2]
;;;206    						str.cmd[str.cmd_len++] = addr;		//驱动板地址
00020c  f89d1001          LDRB     r1,[sp,#1]
000210  1c48              ADDS     r0,r1,#1
000212  b2c0              UXTB     r0,r0
000214  f88d0001          STRB     r0,[sp,#1]
000218  9801              LDR      r0,[sp,#4]
00021a  5445              STRB     r5,[r0,r1]
;;;207    						str.cmd[str.cmd_len++] = ' ';		//有效数据长
00021c  2120              MOVS     r1,#0x20
00021e  f89d2001          LDRB     r2,[sp,#1]
000222  1c50              ADDS     r0,r2,#1
000224  b2c0              UXTB     r0,r0
000226  f88d0001          STRB     r0,[sp,#1]
00022a  9801              LDR      r0,[sp,#4]
00022c  5481              STRB     r1,[r0,r2]
;;;208    						str.cmd[str.cmd_len++] = ' ';
00022e  f89d2001          LDRB     r2,[sp,#1]
000232  1c50              ADDS     r0,r2,#1
000234  b2c0              UXTB     r0,r0
000236  f88d0001          STRB     r0,[sp,#1]
00023a  9801              LDR      r0,[sp,#4]
00023c  5481              STRB     r1,[r0,r2]
;;;209    						str.cmd[str.cmd_len++] = CMD_CHECK_EXECUTE;
00023e  21de              MOVS     r1,#0xde
000240  f89d2001          LDRB     r2,[sp,#1]
000244  1c50              ADDS     r0,r2,#1
000246  b2c0              UXTB     r0,r0
000248  f88d0001          STRB     r0,[sp,#1]
00024c  9801              LDR      r0,[sp,#4]
00024e  5481              STRB     r1,[r0,r2]
;;;210    						str.cmd[3] = (str.cmd_len + 1) >> 8;		//包长
000250  f89d0001          LDRB     r0,[sp,#1]
000254  1c40              ADDS     r0,r0,#1
000256  1200              ASRS     r0,r0,#8
000258  9901              LDR      r1,[sp,#4]
00025a  70c8              STRB     r0,[r1,#3]
;;;211    						str.cmd[4] = (str.cmd_len + 1);
00025c  f89d0001          LDRB     r0,[sp,#1]
000260  1c40              ADDS     r0,r0,#1
000262  9901              LDR      r1,[sp,#4]
000264  7108              STRB     r0,[r1,#4]
;;;212    						//添加校验
;;;213    						for(j = 0, chk = 0; j < str.cmd_len; j++)
000266  2400              MOVS     r4,#0
000268  46a3              MOV      r11,r4
00026a  e006              B        |L1.634|
                  |L1.620|
;;;214    						{
;;;215    							chk +=  str.cmd[j];
00026c  9801              LDR      r0,[sp,#4]
00026e  5d00              LDRB     r0,[r0,r4]
000270  4458              ADD      r0,r0,r11
000272  f0000bff          AND      r11,r0,#0xff
000276  1c60              ADDS     r0,r4,#1              ;213
000278  b2c4              UXTB     r4,r0                 ;213
                  |L1.634|
00027a  f89d0001          LDRB     r0,[sp,#1]            ;213
00027e  42a0              CMP      r0,r4                 ;213
000280  dcf4              BGT      |L1.620|
;;;216    						}
;;;217    						str.cmd[str.cmd_len++] = chk;
000282  f89d1001          LDRB     r1,[sp,#1]
000286  1c48              ADDS     r0,r1,#1
000288  b2c0              UXTB     r0,r0
00028a  f88d0001          STRB     r0,[sp,#1]
00028e  9801              LDR      r0,[sp,#4]
000290  f800b001          STRB     r11,[r0,r1]
;;;218    
;;;219    						i = 0;
000294  2700              MOVS     r7,#0
;;;220    						do
000296  bf00              NOP      
                  |L1.664|
;;;221    						{
;;;222    							err = send_to_485Bus(&str);
000298  4668              MOV      r0,sp
00029a  f7fffffe          BL       send_to_485Bus
00029e  9005              STR      r0,[sp,#0x14]
;;;223    							if(str.recv[6] == 3)
0002a0  9802              LDR      r0,[sp,#8]
0002a2  7980              LDRB     r0,[r0,#6]
0002a4  2803              CMP      r0,#3
0002a6  d103              BNE      |L1.688|
;;;224    								OSTimeDly(OS_TICKS_PER_SEC/2);//如果忙，等待500ms再次询问，忙状态最长时间15s（什么电机都应该转完了）
0002a8  f44f70fa          MOV      r0,#0x1f4
0002ac  f7fffffe          BL       OSTimeDly
                  |L1.688|
;;;225    						}while( ( err == OS_NO_ERR && (str.recv[6] == 3) && (i++ < 30) ) || ( err != OS_NO_ERR && (i++ < 2) ) ); 
0002b0  f89d0014          LDRB     r0,[sp,#0x14]
0002b4  b968              CBNZ     r0,|L1.722|
0002b6  e003              B        |L1.704|
                  |L1.696|
0002b8  e034              B        |L1.804|
                  |L1.698|
0002ba  e030              B        |L1.798|
                  |L1.700|
0002bc  e02c              B        |L1.792|
                  |L1.702|
0002be  e028              B        |L1.786|
                  |L1.704|
0002c0  9802              LDR      r0,[sp,#8]
0002c2  7980              LDRB     r0,[r0,#6]
0002c4  2803              CMP      r0,#3
0002c6  d104              BNE      |L1.722|
0002c8  4638              MOV      r0,r7
0002ca  1c79              ADDS     r1,r7,#1
0002cc  b2cf              UXTB     r7,r1
0002ce  281e              CMP      r0,#0x1e
0002d0  dbe2              BLT      |L1.664|
                  |L1.722|
0002d2  f89d0014          LDRB     r0,[sp,#0x14]
0002d6  b120              CBZ      r0,|L1.738|
0002d8  4638              MOV      r0,r7
0002da  1c79              ADDS     r1,r7,#1
0002dc  b2cf              UXTB     r7,r1
0002de  2802              CMP      r0,#2
0002e0  dbda              BLT      |L1.664|
                  |L1.738|
;;;226    							
;;;227    						
;;;228    						if(str.recv[6] == 3)//驱动板忙
0002e2  9802              LDR      r0,[sp,#8]
0002e4  7980              LDRB     r0,[r0,#6]
0002e6  2803              CMP      r0,#3
0002e8  d101              BNE      |L1.750|
;;;229    						{
;;;230    							rs = DRV_RESULT_BUSY;
0002ea  9006              STR      r0,[sp,#0x18]
0002ec  e010              B        |L1.784|
                  |L1.750|
;;;231    						}
;;;232    						else
;;;233    						{
;;;234    							if(str.recv[2] == str.cmd[2])//驱动板地址符合
0002ee  9802              LDR      r0,[sp,#8]
0002f0  7880              LDRB     r0,[r0,#2]
0002f2  9901              LDR      r1,[sp,#4]
0002f4  7889              LDRB     r1,[r1,#2]
0002f6  4288              CMP      r0,r1
0002f8  d108              BNE      |L1.780|
;;;235    							{
;;;236    								if(str.recv[5] == str.cmd[5])//应答的是发送命令
0002fa  9802              LDR      r0,[sp,#8]
0002fc  7940              LDRB     r0,[r0,#5]
0002fe  9901              LDR      r1,[sp,#4]
000300  7949              LDRB     r1,[r1,#5]
000302  4288              CMP      r0,r1
000304  d104              BNE      |L1.784|
;;;237    								{
;;;238    									rs = OS_NO_ERR;
000306  2000              MOVS     r0,#0
000308  9006              STR      r0,[sp,#0x18]
00030a  e001              B        |L1.784|
                  |L1.780|
;;;239    								}
;;;240    							}
;;;241    							else//地址错误
;;;242    							{
;;;243    								rs = DRV_RESULT_ADDRERR;
00030c  200d              MOVS     r0,#0xd
00030e  9006              STR      r0,[sp,#0x18]
                  |L1.784|
;;;244    							}
;;;245    						}
;;;246    					}
000310  e00d              B        |L1.814|
                  |L1.786|
;;;247    					else//驱动板拒收命令
;;;248    					{
;;;249    						rs = DRV_RESULT_CMDERR;
000312  200e              MOVS     r0,#0xe
000314  9006              STR      r0,[sp,#0x18]
000316  e00a              B        |L1.814|
                  |L1.792|
;;;250    					}
;;;251    				}
;;;252    				else//应答非当前指令
;;;253    				{
;;;254    					rs = DRV_RESULT_CMDERR;
000318  200e              MOVS     r0,#0xe
00031a  9006              STR      r0,[sp,#0x18]
00031c  e007              B        |L1.814|
                  |L1.798|
;;;255    				}
;;;256    			}
;;;257    			else//驱动板地址错，第一条指令
;;;258    			{
;;;259    				rs = DRV_RESULT_ADDRERR;
00031e  200d              MOVS     r0,#0xd
000320  9006              STR      r0,[sp,#0x18]
000322  e004              B        |L1.814|
                  |L1.804|
;;;260    			}
;;;261    		}
;;;262    		else//超时未应答
;;;263    		{
;;;264    			rs = DRV_RESULT_TIMEOUT;
000324  200f              MOVS     r0,#0xf
000326  9006              STR      r0,[sp,#0x18]
000328  e001              B        |L1.814|
                  |L1.810|
;;;265    		}
;;;266    	}
;;;267    	else//未申请到内存，此条指令作废
;;;268    	{
;;;269    		
;;;270    		rs = DRV_RESULT_CMDINVALID;
00032a  2010              MOVS     r0,#0x10
00032c  9006              STR      r0,[sp,#0x18]
                  |L1.814|
;;;271    	}
;;;272    	
;;;273    //	if(err != 0)//测试代码
;;;274    //	{
;;;275    //		rs = rs;
;;;276    //	}
;;;277    
;;;278    	_free(str.cmd);//释放内存
00032e  9801              LDR      r0,[sp,#4]
000330  f7fffffe          BL       _free
;;;279    	bus_Unlock_485();
000334  f7fffffe          BL       bus_Unlock_485
;;;280    	return rs;
000338  9806              LDR      r0,[sp,#0x18]
;;;281    }
00033a  b007              ADD      sp,sp,#0x1c
00033c  e8bd8ff0          POP      {r4-r11,pc}
;;;282    
                          ENDP

                  drv_cmd_channleCheck PROC
;;;289    */
;;;290    uint8_t drv_cmd_channleCheck(uint8_t addr, uint8_t channel)
000340  b5f0              PUSH     {r4-r7,lr}
;;;291    {
000342  b08f              SUB      sp,sp,#0x3c
000344  4605              MOV      r5,r0
000346  460c              MOV      r4,r1
;;;292    	uint8_t rs;
;;;293    	uint8_t cmd[30],cmd_len;
;;;294    	uint8_t recv[20];
;;;295    	uint8_t state;//电机状态
;;;296    	
;;;297    	cmd_len = 0; 
000348  2600              MOVS     r6,#0
;;;298    	cmd[cmd_len++] = CMD_CHECK;		//电机查询指令
00034a  2201              MOVS     r2,#1
00034c  4631              MOV      r1,r6
00034e  1c76              ADDS     r6,r6,#1
000350  a807              ADD      r0,sp,#0x1c
000352  5442              STRB     r2,[r0,r1]
;;;299    	if(pt_driverBoard[addr]->channelState[channel] == MOTO_LINK)//如果电机是联动的(开机时读参数，然后更新电机状态)
000354  483c              LDR      r0,|L1.1096|
000356  f8500025          LDR      r0,[r0,r5,LSL #2]
00035a  1dc0              ADDS     r0,r0,#7
00035c  5d00              LDRB     r0,[r0,r4]
00035e  2808              CMP      r0,#8
000360  d106              BNE      |L1.880|
;;;300    		cmd[cmd_len++] = 2;	//电机数量
000362  2202              MOVS     r2,#2
000364  4630              MOV      r0,r6
000366  1c71              ADDS     r1,r6,#1
000368  b2ce              UXTB     r6,r1
00036a  a907              ADD      r1,sp,#0x1c
00036c  540a              STRB     r2,[r1,r0]
00036e  e005              B        |L1.892|
                  |L1.880|
;;;301    	else	//电机非联动
;;;302    		cmd[cmd_len++] = 1;			
000370  2201              MOVS     r2,#1
000372  4630              MOV      r0,r6
000374  1c71              ADDS     r1,r6,#1
000376  b2ce              UXTB     r6,r1
000378  a907              ADD      r1,sp,#0x1c
00037a  540a              STRB     r2,[r1,r0]
                  |L1.892|
;;;303    	cmd[cmd_len++] = channel;	
00037c  4630              MOV      r0,r6
00037e  1c71              ADDS     r1,r6,#1
000380  b2ce              UXTB     r6,r1
000382  a907              ADD      r1,sp,#0x1c
000384  540c              STRB     r4,[r1,r0]
;;;304    	if(pt_driverBoard[addr]->channelState[channel] == MOTO_LINK)
000386  4830              LDR      r0,|L1.1096|
000388  f8500025          LDR      r0,[r0,r5,LSL #2]
00038c  1dc0              ADDS     r0,r0,#7
00038e  5d00              LDRB     r0,[r0,r4]
000390  2808              CMP      r0,#8
000392  d106              BNE      |L1.930|
;;;305    		cmd[cmd_len++] = channel + 1;
000394  1c60              ADDS     r0,r4,#1
000396  b2c2              UXTB     r2,r0
000398  4630              MOV      r0,r6
00039a  1c71              ADDS     r1,r6,#1
00039c  b2ce              UXTB     r6,r1
00039e  a907              ADD      r1,sp,#0x1c
0003a0  540a              STRB     r2,[r1,r0]
                  |L1.930|
;;;306    
;;;307    	rs = send_cmd(addr, cmd, cmd_len, recv);
0003a2  ab02              ADD      r3,sp,#8
0003a4  4632              MOV      r2,r6
0003a6  a907              ADD      r1,sp,#0x1c
0003a8  4628              MOV      r0,r5
0003aa  f7fffffe          BL       send_cmd
0003ae  4607              MOV      r7,r0
;;;308    	if(rs == OS_NO_ERR)//执行完成，但是执行是否成功不一定
0003b0  bb9f              CBNZ     r7,|L1.1050|
;;;309    	{
;;;310    		 
;;;311    		if(pt_driverBoard[addr]->channelState[channel] != recv[9])//电机状态变化
0003b2  4825              LDR      r0,|L1.1096|
0003b4  f8500025          LDR      r0,[r0,r5,LSL #2]
0003b8  1dc0              ADDS     r0,r0,#7
0003ba  5d00              LDRB     r0,[r0,r4]
0003bc  f89d1011          LDRB     r1,[sp,#0x11]
0003c0  4288              CMP      r0,r1
0003c2  d028              BEQ      |L1.1046|
;;;312    		{
;;;313    			pt_driverBoard[addr]->channelState[channel] = recv[9];//更新电机状态
0003c4  f89d1011          LDRB     r1,[sp,#0x11]
0003c8  481f              LDR      r0,|L1.1096|
0003ca  f8500025          LDR      r0,[r0,r5,LSL #2]
0003ce  1dc0              ADDS     r0,r0,#7
0003d0  5501              STRB     r1,[r0,r4]
;;;314    			
;;;315    			if(pt_driverBoard[addr]->channelState[channel] == 1)
0003d2  481d              LDR      r0,|L1.1096|
0003d4  f8500025          LDR      r0,[r0,r5,LSL #2]
0003d8  1dc0              ADDS     r0,r0,#7
0003da  5d00              LDRB     r0,[r0,r4]
0003dc  2801              CMP      r0,#1
0003de  d113              BNE      |L1.1032|
;;;316    			{
;;;317    				#if ZJ_VS_XY == 1
;;;318    				e2p_get_channelState(channel, &state);//读电机状态
0003e0  a901              ADD      r1,sp,#4
0003e2  4620              MOV      r0,r4
0003e4  f7fffffe          BL       e2p_get_channelState
;;;319    				if(pt_driverBoard[addr]->channelState[channel] != state)
0003e8  4817              LDR      r0,|L1.1096|
0003ea  f8500025          LDR      r0,[r0,r5,LSL #2]
0003ee  1dc0              ADDS     r0,r0,#7
0003f0  5d00              LDRB     r0,[r0,r4]
0003f2  f89d1004          LDRB     r1,[sp,#4]
0003f6  4288              CMP      r0,r1
0003f8  d006              BEQ      |L1.1032|
;;;320    					pt_driverBoard[addr]->channelState[channel] = state;//更新电机状态
0003fa  f89d1004          LDRB     r1,[sp,#4]
0003fe  4812              LDR      r0,|L1.1096|
000400  f8500025          LDR      r0,[r0,r5,LSL #2]
000404  1dc0              ADDS     r0,r0,#7
000406  5501              STRB     r1,[r0,r4]
                  |L1.1032|
;;;321    				#endif
;;;322    			}
;;;323    			report_state_change(STATE_CHANNEL, (addr+1), recv[9] - 1);//汇报货道状态改变
000408  f89d0011          LDRB     r0,[sp,#0x11]
00040c  1e42              SUBS     r2,r0,#1
00040e  1c69              ADDS     r1,r5,#1
000410  2001              MOVS     r0,#1
000412  f7fffffe          BL       report_state_change
                  |L1.1046|
;;;324    		}
;;;325    		rs = recv[6];//执行结果
000416  f89d700e          LDRB     r7,[sp,#0xe]
                  |L1.1050|
;;;326    	}
;;;327    	return rs;
00041a  4638              MOV      r0,r7
;;;328    	
;;;329    }
00041c  b00f              ADD      sp,sp,#0x3c
00041e  bdf0              POP      {r4-r7,pc}
;;;330    
                          ENDP

                  drv_cmd_sale PROC
;;;334    */
;;;335    uint8_t drv_cmd_sale(uint8_t addr, uint8_t channel)
000420  b5f0              PUSH     {r4-r7,lr}
;;;336    {
000422  b08f              SUB      sp,sp,#0x3c
000424  4605              MOV      r5,r0
000426  460c              MOV      r4,r1
;;;337    	uint8_t rs;
;;;338    	uint8_t cmd[30],cmd_len;
;;;339    	uint8_t recv[20];
;;;340    	uint8_t state;
;;;341    	
;;;342    	cmd_len = 0; 
000428  2600              MOVS     r6,#0
;;;343    	cmd[cmd_len++] = CMD_SALE;		//电机查询指令
00042a  2202              MOVS     r2,#2
00042c  4631              MOV      r1,r6
00042e  1c76              ADDS     r6,r6,#1
000430  a807              ADD      r0,sp,#0x1c
000432  5442              STRB     r2,[r0,r1]
;;;344    	if(pt_driverBoard[addr]->channelState[channel] == MOTO_LINK)//如果电机是联动的(开机时读参数，然后更新电机状态)
000434  4804              LDR      r0,|L1.1096|
000436  f8500025          LDR      r0,[r0,r5,LSL #2]
00043a  1dc0              ADDS     r0,r0,#7
00043c  5d00              LDRB     r0,[r0,r4]
00043e  2808              CMP      r0,#8
000440  d10a              BNE      |L1.1112|
;;;345    	cmd[cmd_len++] = 2;	//电机数量
000442  4630              MOV      r0,r6
000444  1c71              ADDS     r1,r6,#1
000446  e003              B        |L1.1104|
                  |L1.1096|
                          DCD      pt_driverBoard
                  |L1.1100|
                          DCD      isRecvFinished
                  |L1.1104|
000450  b2ce              UXTB     r6,r1
000452  a907              ADD      r1,sp,#0x1c
000454  540a              STRB     r2,[r1,r0]
000456  e005              B        |L1.1124|
                  |L1.1112|
;;;346    	else	//电机非联动
;;;347    	cmd[cmd_len++] = 1;			
000458  2201              MOVS     r2,#1
00045a  4630              MOV      r0,r6
00045c  1c71              ADDS     r1,r6,#1
00045e  b2ce              UXTB     r6,r1
000460  a907              ADD      r1,sp,#0x1c
000462  540a              STRB     r2,[r1,r0]
                  |L1.1124|
;;;348    	cmd[cmd_len++] = channel;	
000464  4630              MOV      r0,r6
000466  1c71              ADDS     r1,r6,#1
000468  b2ce              UXTB     r6,r1
00046a  a907              ADD      r1,sp,#0x1c
00046c  540c              STRB     r4,[r1,r0]
;;;349    	if(pt_driverBoard[addr]->channelState[channel] == MOTO_LINK)
00046e  48fe              LDR      r0,|L1.2152|
000470  f8500025          LDR      r0,[r0,r5,LSL #2]
000474  1dc0              ADDS     r0,r0,#7
000476  5d00              LDRB     r0,[r0,r4]
000478  2808              CMP      r0,#8
00047a  d106              BNE      |L1.1162|
;;;350    	cmd[cmd_len++] = channel + 1;
00047c  1c60              ADDS     r0,r4,#1
00047e  b2c2              UXTB     r2,r0
000480  4630              MOV      r0,r6
000482  1c71              ADDS     r1,r6,#1
000484  b2ce              UXTB     r6,r1
000486  a907              ADD      r1,sp,#0x1c
000488  540a              STRB     r2,[r1,r0]
                  |L1.1162|
;;;351    
;;;352    	#if ZJ_VS_XY == 1
;;;353    	state = 0;
00048a  2000              MOVS     r0,#0
00048c  9001              STR      r0,[sp,#4]
;;;354    	e2p_set_channelState(channel, &state);//先置位为不在位
00048e  a901              ADD      r1,sp,#4
000490  4620              MOV      r0,r4
000492  f7fffffe          BL       e2p_set_channelState
;;;355    	#endif
;;;356    	
;;;357    	
;;;358    	rs = send_cmd(addr, cmd, cmd_len, recv);
000496  ab02              ADD      r3,sp,#8
000498  4632              MOV      r2,r6
00049a  a907              ADD      r1,sp,#0x1c
00049c  4628              MOV      r0,r5
00049e  f7fffffe          BL       send_cmd
0004a2  4607              MOV      r7,r0
;;;359    	if(rs == OS_NO_ERR)//执行完成，但是执行是否成功不一定
0004a4  b9c7              CBNZ     r7,|L1.1240|
;;;360    	{
;;;361    		if(pt_driverBoard[addr]->channelState[channel] != recv[9])//电机状态变化
0004a6  48f0              LDR      r0,|L1.2152|
0004a8  f8500025          LDR      r0,[r0,r5,LSL #2]
0004ac  1dc0              ADDS     r0,r0,#7
0004ae  5d00              LDRB     r0,[r0,r4]
0004b0  f89d1011          LDRB     r1,[sp,#0x11]
0004b4  4288              CMP      r0,r1
0004b6  d00d              BEQ      |L1.1236|
;;;362    		{
;;;363    			pt_driverBoard[addr]->channelState[channel] = recv[9];//更新电机状态
0004b8  f89d1011          LDRB     r1,[sp,#0x11]
0004bc  48ea              LDR      r0,|L1.2152|
0004be  f8500025          LDR      r0,[r0,r5,LSL #2]
0004c2  1dc0              ADDS     r0,r0,#7
0004c4  5501              STRB     r1,[r0,r4]
;;;364    			report_state_change(STATE_CHANNEL, (addr+1), recv[9] - 1);//汇报货道状态改变
0004c6  f89d0011          LDRB     r0,[sp,#0x11]
0004ca  1e42              SUBS     r2,r0,#1
0004cc  1c69              ADDS     r1,r5,#1
0004ce  2001              MOVS     r0,#1
0004d0  f7fffffe          BL       report_state_change
                  |L1.1236|
;;;365    		}
;;;366    		rs = recv[6];//执行结果
0004d4  f89d700e          LDRB     r7,[sp,#0xe]
                  |L1.1240|
;;;367    	}
;;;368    	#if ZJ_VS_XY == 1
;;;369    	if(pt_driverBoard[addr]->channelState[channel] == 1)//驱动板报电机正常
0004d8  48e3              LDR      r0,|L1.2152|
0004da  f8500025          LDR      r0,[r0,r5,LSL #2]
0004de  1dc0              ADDS     r0,r0,#7
0004e0  5d00              LDRB     r0,[r0,r4]
0004e2  2801              CMP      r0,#1
0004e4  d104              BNE      |L1.1264|
;;;370    	{
;;;371    		state = 1;
0004e6  9001              STR      r0,[sp,#4]
;;;372    		e2p_set_channelState(channel, &state);//置位为在位
0004e8  a901              ADD      r1,sp,#4
0004ea  4620              MOV      r0,r4
0004ec  f7fffffe          BL       e2p_set_channelState
                  |L1.1264|
;;;373    	}
;;;374    	#endif
;;;375    	return rs;
0004f0  4638              MOV      r0,r7
;;;376    }
0004f2  b00f              ADD      sp,sp,#0x3c
0004f4  bdf0              POP      {r4-r7,pc}
;;;377    
                          ENDP

                  drv_cmd_channelReset PROC
;;;381    */
;;;382    uint8_t	drv_cmd_channelReset(uint8_t addr, uint8_t channel)
0004f6  b5f0              PUSH     {r4-r7,lr}
;;;383    {
0004f8  b08f              SUB      sp,sp,#0x3c
0004fa  4605              MOV      r5,r0
0004fc  460c              MOV      r4,r1
;;;384    	uint8_t rs = FALSE;
0004fe  2700              MOVS     r7,#0
;;;385    	uint8_t cmd[30],cmd_len;
;;;386    	uint8_t recv[20];
;;;387    	uint8_t state;
;;;388    	
;;;389    	cmd_len = 0; 
000500  2600              MOVS     r6,#0
;;;390    	cmd[cmd_len++] = CMD_RESET;		//电机查询指令
000502  2203              MOVS     r2,#3
000504  4631              MOV      r1,r6
000506  1c76              ADDS     r6,r6,#1
000508  a807              ADD      r0,sp,#0x1c
00050a  5442              STRB     r2,[r0,r1]
;;;391    	if(pt_driverBoard[addr]->channelState[channel] == MOTO_LINK)//如果电机是联动的(开机时读参数，然后更新电机状态)
00050c  48d6              LDR      r0,|L1.2152|
00050e  f8500025          LDR      r0,[r0,r5,LSL #2]
000512  1dc0              ADDS     r0,r0,#7
000514  5d00              LDRB     r0,[r0,r4]
000516  2808              CMP      r0,#8
000518  d106              BNE      |L1.1320|
;;;392    		cmd[cmd_len++] = 2;	//电机数量
00051a  2202              MOVS     r2,#2
00051c  4630              MOV      r0,r6
00051e  1c71              ADDS     r1,r6,#1
000520  b2ce              UXTB     r6,r1
000522  a907              ADD      r1,sp,#0x1c
000524  540a              STRB     r2,[r1,r0]
000526  e005              B        |L1.1332|
                  |L1.1320|
;;;393    	else	//电机非联动
;;;394    		cmd[cmd_len++] = 1;			
000528  2201              MOVS     r2,#1
00052a  4630              MOV      r0,r6
00052c  1c71              ADDS     r1,r6,#1
00052e  b2ce              UXTB     r6,r1
000530  a907              ADD      r1,sp,#0x1c
000532  540a              STRB     r2,[r1,r0]
                  |L1.1332|
;;;395    	cmd[cmd_len++] = channel;	
000534  4630              MOV      r0,r6
000536  1c71              ADDS     r1,r6,#1
000538  b2ce              UXTB     r6,r1
00053a  a907              ADD      r1,sp,#0x1c
00053c  540c              STRB     r4,[r1,r0]
;;;396    	if(pt_driverBoard[addr]->channelState[channel] == MOTO_LINK)
00053e  48ca              LDR      r0,|L1.2152|
000540  f8500025          LDR      r0,[r0,r5,LSL #2]
000544  1dc0              ADDS     r0,r0,#7
000546  5d00              LDRB     r0,[r0,r4]
000548  2808              CMP      r0,#8
00054a  d106              BNE      |L1.1370|
;;;397    		cmd[cmd_len++] = channel + 1;
00054c  1c60              ADDS     r0,r4,#1
00054e  b2c2              UXTB     r2,r0
000550  4630              MOV      r0,r6
000552  1c71              ADDS     r1,r6,#1
000554  b2ce              UXTB     r6,r1
000556  a907              ADD      r1,sp,#0x1c
000558  540a              STRB     r2,[r1,r0]
                  |L1.1370|
;;;398    
;;;399    	#if ZJ_VS_XY == 1
;;;400    	state = 0;
00055a  2000              MOVS     r0,#0
00055c  9001              STR      r0,[sp,#4]
;;;401    	e2p_set_channelState(channel, &state);//先置位为不在位
00055e  a901              ADD      r1,sp,#4
000560  4620              MOV      r0,r4
000562  f7fffffe          BL       e2p_set_channelState
;;;402    	#endif
;;;403    	
;;;404    	rs = send_cmd(addr, cmd, cmd_len, recv);
000566  ab02              ADD      r3,sp,#8
000568  4632              MOV      r2,r6
00056a  a907              ADD      r1,sp,#0x1c
00056c  4628              MOV      r0,r5
00056e  f7fffffe          BL       send_cmd
000572  4607              MOV      r7,r0
;;;405    	if(rs == OS_NO_ERR)//执行完成（可能执行成功，也可能执行失败）
000574  b9c7              CBNZ     r7,|L1.1448|
;;;406    	{
;;;407    		if(pt_driverBoard[addr]->channelState[channel] != recv[9])//电机状态变化
000576  48bc              LDR      r0,|L1.2152|
000578  f8500025          LDR      r0,[r0,r5,LSL #2]
00057c  1dc0              ADDS     r0,r0,#7
00057e  5d00              LDRB     r0,[r0,r4]
000580  f89d1011          LDRB     r1,[sp,#0x11]
000584  4288              CMP      r0,r1
000586  d00d              BEQ      |L1.1444|
;;;408    		{
;;;409    			pt_driverBoard[addr]->channelState[channel] = recv[9];//更新电机状态
000588  f89d1011          LDRB     r1,[sp,#0x11]
00058c  48b6              LDR      r0,|L1.2152|
00058e  f8500025          LDR      r0,[r0,r5,LSL #2]
000592  1dc0              ADDS     r0,r0,#7
000594  5501              STRB     r1,[r0,r4]
;;;410    			report_state_change(STATE_CHANNEL, (addr+1), recv[9] - 1);//汇报货道状态改变
000596  f89d0011          LDRB     r0,[sp,#0x11]
00059a  1e42              SUBS     r2,r0,#1
00059c  1c69              ADDS     r1,r5,#1
00059e  2001              MOVS     r0,#1
0005a0  f7fffffe          BL       report_state_change
                  |L1.1444|
;;;411    		}
;;;412    		rs = recv[6];//执行结果
0005a4  f89d700e          LDRB     r7,[sp,#0xe]
                  |L1.1448|
;;;413    	}
;;;414    	#if ZJ_VS_XY == 1
;;;415    	if(pt_driverBoard[addr]->channelState[channel] == 1)//驱动板报电机正常
0005a8  48af              LDR      r0,|L1.2152|
0005aa  f8500025          LDR      r0,[r0,r5,LSL #2]
0005ae  1dc0              ADDS     r0,r0,#7
0005b0  5d00              LDRB     r0,[r0,r4]
0005b2  2801              CMP      r0,#1
0005b4  d104              BNE      |L1.1472|
;;;416    	{
;;;417    		state = 1;
0005b6  9001              STR      r0,[sp,#4]
;;;418    		e2p_set_channelState(channel, &state);//置位为在位
0005b8  a901              ADD      r1,sp,#4
0005ba  4620              MOV      r0,r4
0005bc  f7fffffe          BL       e2p_set_channelState
                  |L1.1472|
;;;419    	}
;;;420    	#endif
;;;421    	return rs;
0005c0  4638              MOV      r0,r7
;;;422    }
0005c2  b00f              ADD      sp,sp,#0x3c
0005c4  bdf0              POP      {r4-r7,pc}
;;;423    
                          ENDP

                  drv_cmd_channelCheckall PROC
;;;427    */
;;;428    uint8_t	drv_cmd_channelCheckall(uint8_t addr)
0005c6  b5f0              PUSH     {r4-r7,lr}
;;;429    {
0005c8  b09f              SUB      sp,sp,#0x7c
0005ca  4605              MOV      r5,r0
;;;430    	uint8_t rs;
;;;431    	uint8_t cmd[20],cmd_len;
;;;432    	uint8_t recv[100];
;;;433    	uint8_t state;
;;;434    
;;;435    	cmd_len = 0;
0005cc  2700              MOVS     r7,#0
;;;436    	cmd[cmd_len++] = CMD_CHECKALL;
0005ce  2204              MOVS     r2,#4
0005d0  4639              MOV      r1,r7
0005d2  1c7f              ADDS     r7,r7,#1
0005d4  a81a              ADD      r0,sp,#0x68
0005d6  5442              STRB     r2,[r0,r1]
;;;437    
;;;438    	rs = send_cmd(addr, cmd, cmd_len, recv);
0005d8  ab01              ADD      r3,sp,#4
0005da  463a              MOV      r2,r7
0005dc  a91a              ADD      r1,sp,#0x68
0005de  4628              MOV      r0,r5
0005e0  f7fffffe          BL       send_cmd
0005e4  4606              MOV      r6,r0
;;;439    	if(rs == OS_NO_ERR)//执行完成，但是执行是否成功不一定
0005e6  bb3e              CBNZ     r6,|L1.1592|
;;;440    	{
;;;441    		if(recv[6] == DRV_RESULT_SUCCESS)//只有执行成功才可以更新整机货道
0005e8  f89d000a          LDRB     r0,[sp,#0xa]
0005ec  2801              CMP      r0,#1
0005ee  d121              BNE      |L1.1588|
;;;442    		{
;;;443    			//更新货道状态
;;;444    			uint8_t i;
;;;445    			for(i = 0; i < CHANNEL_SIZE; i++)
0005f0  2400              MOVS     r4,#0
0005f2  e01c              B        |L1.1582|
                  |L1.1524|
;;;446    			{
;;;447    				pt_driverBoard[addr]->channelState[i] = recv[i+9];
0005f4  a901              ADD      r1,sp,#4
0005f6  f1040009          ADD      r0,r4,#9
0005fa  5c09              LDRB     r1,[r1,r0]
0005fc  489a              LDR      r0,|L1.2152|
0005fe  f8500025          LDR      r0,[r0,r5,LSL #2]
000602  1dc0              ADDS     r0,r0,#7
000604  5501              STRB     r1,[r0,r4]
;;;448    				if(pt_driverBoard[addr]->channelState[i] == 1)
000606  4898              LDR      r0,|L1.2152|
000608  f8500025          LDR      r0,[r0,r5,LSL #2]
00060c  1dc0              ADDS     r0,r0,#7
00060e  5d00              LDRB     r0,[r0,r4]
000610  2801              CMP      r0,#1
000612  d10a              BNE      |L1.1578|
;;;449    				{
;;;450    					#if ZJ_VS_XY == 1
;;;451    					e2p_get_channelState(i, &state);//查询电机状态
000614  4669              MOV      r1,sp
000616  4620              MOV      r0,r4
000618  f7fffffe          BL       e2p_get_channelState
;;;452    					pt_driverBoard[addr]->channelState[i] = state;
00061c  f89d1000          LDRB     r1,[sp,#0]
000620  4891              LDR      r0,|L1.2152|
000622  f8500025          LDR      r0,[r0,r5,LSL #2]
000626  1dc0              ADDS     r0,r0,#7
000628  5501              STRB     r1,[r0,r4]
                  |L1.1578|
00062a  1c60              ADDS     r0,r4,#1              ;445
00062c  b2c4              UXTB     r4,r0                 ;445
                  |L1.1582|
00062e  2c50              CMP      r4,#0x50              ;445
000630  dbe0              BLT      |L1.1524|
;;;453    					#endif
;;;454    				}
;;;455    			}
;;;456    		}
000632  bf00              NOP      
                  |L1.1588|
;;;457    		rs = recv[6];
000634  f89d600a          LDRB     r6,[sp,#0xa]
                  |L1.1592|
;;;458    	}
;;;459    	return rs;
000638  4630              MOV      r0,r6
;;;460    }
00063a  b01f              ADD      sp,sp,#0x7c
00063c  bdf0              POP      {r4-r7,pc}
;;;461    
                          ENDP

                  drv_cmd_channelResetall PROC
;;;465    */
;;;466    uint8_t	drv_cmd_channelResetall(uint8_t addr)
00063e  b570              PUSH     {r4-r6,lr}
;;;467    {
000640  b08a              SUB      sp,sp,#0x28
000642  4604              MOV      r4,r0
;;;468    	uint8_t rs;
;;;469    	uint8_t cmd[20],cmd_len;
;;;470    	uint8_t recv[20];
;;;471    
;;;472    	cmd_len = 0;
000644  2600              MOVS     r6,#0
;;;473    	cmd[cmd_len++] = CMD_RESETALL_EX;
000646  220a              MOVS     r2,#0xa
000648  4631              MOV      r1,r6
00064a  1c76              ADDS     r6,r6,#1
00064c  a805              ADD      r0,sp,#0x14
00064e  5442              STRB     r2,[r0,r1]
;;;474    
;;;475    	rs = send_cmd(addr, cmd, cmd_len, recv);
000650  466b              MOV      r3,sp
000652  4632              MOV      r2,r6
000654  a905              ADD      r1,sp,#0x14
000656  4620              MOV      r0,r4
000658  f7fffffe          BL       send_cmd
00065c  4605              MOV      r5,r0
;;;476    	if(rs == OS_NO_ERR)//执行完成，但是执行是否成功不一定
00065e  b995              CBNZ     r5,|L1.1670|
;;;477    	{
;;;478    		if(recv[6] == DRV_RESULT_SUCCESS)//只有执行成功才可以更新整机货道
000660  f89d0006          LDRB     r0,[sp,#6]
000664  2801              CMP      r0,#1
000666  d10c              BNE      |L1.1666|
;;;479    		{
;;;480    			uint8_t i;
;;;481    			for(i = 0; i < EX_SIZE; i++)
000668  2000              MOVS     r0,#0
00066a  e007              B        |L1.1660|
                  |L1.1644|
;;;482    			pt_driverBoard[addr]->exState[i] = 0;//复位成功，所有回路关闭
00066c  2200              MOVS     r2,#0
00066e  497e              LDR      r1,|L1.2152|
000670  f8511024          LDR      r1,[r1,r4,LSL #2]
000674  1c49              ADDS     r1,r1,#1
000676  540a              STRB     r2,[r1,r0]
000678  1c41              ADDS     r1,r0,#1              ;481
00067a  b2c8              UXTB     r0,r1                 ;481
                  |L1.1660|
00067c  2806              CMP      r0,#6                 ;481
00067e  dbf5              BLT      |L1.1644|
;;;483    		}
000680  bf00              NOP      
                  |L1.1666|
;;;484    		rs = recv[6];
000682  f89d5006          LDRB     r5,[sp,#6]
                  |L1.1670|
;;;485    	}
;;;486    	return rs; 
000686  4628              MOV      r0,r5
;;;487    }
000688  b00a              ADD      sp,sp,#0x28
00068a  bd70              POP      {r4-r6,pc}
;;;488    
                          ENDP

                  drv_cmd_openEX PROC
;;;492    */
;;;493    uint8_t	drv_cmd_openEX(uint8_t addr, uint8_t exchannel)
00068c  e92d41f0          PUSH     {r4-r8,lr}
;;;494    {
000690  b08a              SUB      sp,sp,#0x28
000692  4606              MOV      r6,r0
000694  460c              MOV      r4,r1
;;;495    	
;;;496    	uint8_t rs;
;;;497    	uint8_t cmd[20],cmd_len;
;;;498    	uint8_t recv[20];
;;;499    	
;;;500    	cmd_len = 0; 
000696  2700              MOVS     r7,#0
;;;501    	cmd[cmd_len++] = CMD_ENABLE_EX;	//电机查询指令
000698  2208              MOVS     r2,#8
00069a  4639              MOV      r1,r7
00069c  1c7f              ADDS     r7,r7,#1
00069e  a805              ADD      r0,sp,#0x14
0006a0  5442              STRB     r2,[r0,r1]
;;;502    	cmd[cmd_len++] = exchannel;	
0006a2  4639              MOV      r1,r7
0006a4  1c7f              ADDS     r7,r7,#1
0006a6  5444              STRB     r4,[r0,r1]
;;;503    
;;;504    	rs = send_cmd(addr, cmd, cmd_len, recv);
0006a8  466b              MOV      r3,sp
0006aa  463a              MOV      r2,r7
0006ac  a905              ADD      r1,sp,#0x14
0006ae  4630              MOV      r0,r6
0006b0  f7fffffe          BL       send_cmd
0006b4  4680              MOV      r8,r0
;;;505    	if(rs == OS_NO_ERR)//执行完成，但是执行是否成功不一定
0006b6  f1b80f00          CMP      r8,#0
0006ba  d133              BNE      |L1.1828|
;;;506    	{
;;;507    		if(recv[6] == DRV_RESULT_SUCCESS)
0006bc  f89d0006          LDRB     r0,[sp,#6]
0006c0  2801              CMP      r0,#1
0006c2  d12d              BNE      |L1.1824|
;;;508    		{
;;;509    			uint8_t exID;
;;;510    			//更新回路状态
;;;511    			if(pt_driverBoard[addr]->exState[exchannel] != recv[9])
0006c4  4868              LDR      r0,|L1.2152|
0006c6  f8500026          LDR      r0,[r0,r6,LSL #2]
0006ca  1c40              ADDS     r0,r0,#1
0006cc  5d00              LDRB     r0,[r0,r4]
0006ce  f89d1009          LDRB     r1,[sp,#9]
0006d2  4288              CMP      r0,r1
0006d4  d023              BEQ      |L1.1822|
;;;512    			{
;;;513    				pt_driverBoard[addr]->exState[exchannel] = recv[9];//更新输出回路状态
0006d6  f89d1009          LDRB     r1,[sp,#9]
0006da  4863              LDR      r0,|L1.2152|
0006dc  f8500026          LDR      r0,[r0,r6,LSL #2]
0006e0  1c40              ADDS     r0,r0,#1
0006e2  5501              STRB     r1,[r0,r4]
;;;514    				switch(exchannel)
0006e4  2c06              CMP      r4,#6
0006e6  d210              BCS      |L1.1802|
0006e8  e8dff004          TBB      [pc,r4]
0006ec  03050709          DCB      0x03,0x05,0x07,0x09
0006f0  0b0d              DCB      0x0b,0x0d
;;;515    				{
;;;516    					case 0: exID = STATE_COLD; break;
0006f2  2507              MOVS     r5,#7
0006f4  e009              B        |L1.1802|
;;;517    					case 1: exID = STATE_WIND; break;
0006f6  2508              MOVS     r5,#8
0006f8  e007              B        |L1.1802|
;;;518    					case 2: exID = STATE_LAMP; break;
0006fa  2509              MOVS     r5,#9
0006fc  e005              B        |L1.1802|
;;;519    					case 3: exID = STATE_DISINFACT; break;
0006fe  250a              MOVS     r5,#0xa
000700  e003              B        |L1.1802|
;;;520    					case 4: exID = STATE_GLASS; 	break;
000702  250b              MOVS     r5,#0xb
000704  e001              B        |L1.1802|
;;;521    					case 5: exID = STATE_BACKUP2; 	break;
000706  250c              MOVS     r5,#0xc
000708  bf00              NOP      
                  |L1.1802|
00070a  bf00              NOP                            ;516
;;;522    				}
;;;523    				report_state_change(exID, (addr + 1), pt_driverBoard[addr]->exState[exchannel]);//汇报后台
00070c  4856              LDR      r0,|L1.2152|
00070e  f8500026          LDR      r0,[r0,r6,LSL #2]
000712  1c40              ADDS     r0,r0,#1
000714  5d02              LDRB     r2,[r0,r4]
000716  1c71              ADDS     r1,r6,#1
000718  4628              MOV      r0,r5
00071a  f7fffffe          BL       report_state_change
                  |L1.1822|
;;;524    			}
;;;525    		}
00071e  bf00              NOP      
                  |L1.1824|
;;;526    
;;;527    		rs = recv[6];
000720  f89d8006          LDRB     r8,[sp,#6]
                  |L1.1828|
;;;528    	}
;;;529    	return rs;
000724  4640              MOV      r0,r8
;;;530    }
000726  b00a              ADD      sp,sp,#0x28
000728  e8bd81f0          POP      {r4-r8,pc}
;;;531    
                          ENDP

                  drv_cmd_closeEX PROC
;;;535    */
;;;536    uint8_t drv_cmd_closeEX(uint8_t addr, uint8_t exchannel )
00072c  e92d41f0          PUSH     {r4-r8,lr}
;;;537    {
000730  b08e              SUB      sp,sp,#0x38
000732  4606              MOV      r6,r0
000734  460c              MOV      r4,r1
;;;538    	uint8_t rs;
;;;539    	uint8_t cmd[30],cmd_len;
;;;540    	uint8_t recv[20];
;;;541    	
;;;542    	cmd_len = 0; 
000736  2700              MOVS     r7,#0
;;;543    	cmd[cmd_len++] = CMD_DISABLE_EX;	//电机查询指令
000738  2209              MOVS     r2,#9
00073a  4639              MOV      r1,r7
00073c  1c7f              ADDS     r7,r7,#1
00073e  a806              ADD      r0,sp,#0x18
000740  5442              STRB     r2,[r0,r1]
;;;544    	cmd[cmd_len++] = exchannel;	
000742  4639              MOV      r1,r7
000744  1c7f              ADDS     r7,r7,#1
000746  5444              STRB     r4,[r0,r1]
;;;545    
;;;546    	rs = send_cmd(addr, cmd, cmd_len, recv);
000748  ab01              ADD      r3,sp,#4
00074a  463a              MOV      r2,r7
00074c  a906              ADD      r1,sp,#0x18
00074e  4630              MOV      r0,r6
000750  f7fffffe          BL       send_cmd
000754  4680              MOV      r8,r0
;;;547    	if(rs == OS_NO_ERR)//执行完成，但是执行是否成功不一定
000756  f1b80f00          CMP      r8,#0
00075a  d133              BNE      |L1.1988|
;;;548    	{
;;;549    //		pt_driverBoard[addr]->state = 1;//更新货柜状态
;;;550    		if(recv[6] == DRV_RESULT_SUCCESS)
00075c  f89d000a          LDRB     r0,[sp,#0xa]
000760  2801              CMP      r0,#1
000762  d12d              BNE      |L1.1984|
;;;551    		{
;;;552    			uint8_t exID;
;;;553    			//更新货道状态
;;;554    			if(pt_driverBoard[addr]->exState[exchannel] != recv[9])
000764  4840              LDR      r0,|L1.2152|
000766  f8500026          LDR      r0,[r0,r6,LSL #2]
00076a  1c40              ADDS     r0,r0,#1
00076c  5d00              LDRB     r0,[r0,r4]
00076e  f89d100d          LDRB     r1,[sp,#0xd]
000772  4288              CMP      r0,r1
000774  d023              BEQ      |L1.1982|
;;;555    			{
;;;556    
;;;557    				pt_driverBoard[addr]->exState[exchannel] = recv[9];//更新输出回路状态
000776  f89d100d          LDRB     r1,[sp,#0xd]
00077a  483b              LDR      r0,|L1.2152|
00077c  f8500026          LDR      r0,[r0,r6,LSL #2]
000780  1c40              ADDS     r0,r0,#1
000782  5501              STRB     r1,[r0,r4]
;;;558    				switch(exchannel)
000784  2c05              CMP      r4,#5
000786  d20e              BCS      |L1.1958|
000788  e8dff004          TBB      [pc,r4]
00078c  03050709          DCB      0x03,0x05,0x07,0x09
000790  0b00              DCB      0x0b,0x00
;;;559    				{
;;;560    					case 0: exID = STATE_COLD; break;
000792  2507              MOVS     r5,#7
000794  e007              B        |L1.1958|
;;;561    					case 1: exID =STATE_WIND; break;
000796  2508              MOVS     r5,#8
000798  e005              B        |L1.1958|
;;;562    					case 2: exID =STATE_LAMP; break;
00079a  2509              MOVS     r5,#9
00079c  e003              B        |L1.1958|
;;;563    					case 3: exID =STATE_DISINFACT; break;
00079e  250a              MOVS     r5,#0xa
0007a0  e001              B        |L1.1958|
;;;564    					case 4: exID =STATE_GLASS; break;
0007a2  250b              MOVS     r5,#0xb
0007a4  bf00              NOP      
                  |L1.1958|
0007a6  bf00              NOP                            ;560
;;;565    //					case 5: exID = STATE_BACKUP2; break;
;;;566    				}
;;;567    				if(exchannel != 5)//5通道协议中没有
0007a8  2c05              CMP      r4,#5
0007aa  d008              BEQ      |L1.1982|
;;;568    				report_state_change(exID, (addr + 1), pt_driverBoard[addr]->exState[exchannel]);//汇报后台
0007ac  482e              LDR      r0,|L1.2152|
0007ae  f8500026          LDR      r0,[r0,r6,LSL #2]
0007b2  1c40              ADDS     r0,r0,#1
0007b4  5d02              LDRB     r2,[r0,r4]
0007b6  1c71              ADDS     r1,r6,#1
0007b8  4628              MOV      r0,r5
0007ba  f7fffffe          BL       report_state_change
                  |L1.1982|
;;;569    			}
;;;570    		}
0007be  bf00              NOP      
                  |L1.1984|
;;;571    		rs = recv[6];
0007c0  f89d800a          LDRB     r8,[sp,#0xa]
                  |L1.1988|
;;;572    	}
;;;573    	return rs;
0007c4  4640              MOV      r0,r8
;;;574    }
0007c6  b00e              ADD      sp,sp,#0x38
0007c8  e8bd81f0          POP      {r4-r8,pc}
;;;575    
                          ENDP

                  drv_cmd_checkEX PROC
;;;580    */
;;;581    uint8_t	drv_cmd_checkEX(uint8_t addr, uint8_t exchannel )
0007cc  b5f0              PUSH     {r4-r7,lr}
;;;582    {
0007ce  b093              SUB      sp,sp,#0x4c
0007d0  4606              MOV      r6,r0
0007d2  460c              MOV      r4,r1
;;;583    	
;;;584    	uint8_t rs;
;;;585    	uint8_t cmd[20],cmd_len;
;;;586    	uint8_t recv[50];
;;;587    	
;;;588    	cmd_len = 0; 
0007d4  2500              MOVS     r5,#0
;;;589    	cmd[cmd_len++] = CMD_CHECK_EX;	//电机查询指令
0007d6  2207              MOVS     r2,#7
0007d8  4629              MOV      r1,r5
0007da  1c6d              ADDS     r5,r5,#1
0007dc  a80e              ADD      r0,sp,#0x38
0007de  5442              STRB     r2,[r0,r1]
;;;590    	cmd[cmd_len++] = exchannel;	
0007e0  4629              MOV      r1,r5
0007e2  1c6d              ADDS     r5,r5,#1
0007e4  5444              STRB     r4,[r0,r1]
;;;591    
;;;592    	rs = send_cmd(addr, cmd, cmd_len, recv);
0007e6  ab01              ADD      r3,sp,#4
0007e8  462a              MOV      r2,r5
0007ea  a90e              ADD      r1,sp,#0x38
0007ec  4630              MOV      r0,r6
0007ee  f7fffffe          BL       send_cmd
0007f2  4607              MOV      r7,r0
;;;593    	if(rs == OS_NO_ERR)//执行完成，但是执行是否成功不一定
0007f4  b967              CBNZ     r7,|L1.2064|
;;;594    	{
;;;595    		if(recv[6] == DRV_RESULT_SUCCESS)
0007f6  f89d000a          LDRB     r0,[sp,#0xa]
0007fa  2801              CMP      r0,#1
0007fc  d106              BNE      |L1.2060|
;;;596    		{
;;;597    			pt_driverBoard[addr]->exState[exchannel] = recv[9];//更新输出回路状态
0007fe  f89d100d          LDRB     r1,[sp,#0xd]
000802  4819              LDR      r0,|L1.2152|
000804  f8500026          LDR      r0,[r0,r6,LSL #2]
000808  1c40              ADDS     r0,r0,#1
00080a  5501              STRB     r1,[r0,r4]
                  |L1.2060|
;;;598    			//这里不需要汇报，在打开或关闭中汇报
;;;599    		}
;;;600    		rs = recv[6];
00080c  f89d700a          LDRB     r7,[sp,#0xa]
                  |L1.2064|
;;;601    	}
;;;602    	return rs;
000810  4638              MOV      r0,r7
;;;603    }
000812  b013              ADD      sp,sp,#0x4c
000814  bdf0              POP      {r4-r7,pc}
;;;604    
                          ENDP

                  drv_cmd_checkVER PROC
;;;608    */
;;;609    uint8_t	drv_cmd_checkVER(uint8_t addr )
000816  b570              PUSH     {r4-r6,lr}
;;;610    {
000818  b092              SUB      sp,sp,#0x48
00081a  4604              MOV      r4,r0
;;;611    	
;;;612    	uint8_t rs;
;;;613    	uint8_t cmd[20],cmd_len;
;;;614    	uint8_t recv[50];
;;;615    	
;;;616    	cmd_len = 0; 
00081c  2600              MOVS     r6,#0
;;;617    	cmd[cmd_len++] = CMD_CHECK_VER;	//版本号查询
00081e  220b              MOVS     r2,#0xb
000820  4631              MOV      r1,r6
000822  1c76              ADDS     r6,r6,#1
000824  a80d              ADD      r0,sp,#0x34
000826  5442              STRB     r2,[r0,r1]
;;;618    
;;;619    	rs = send_cmd(addr, cmd, cmd_len, recv);
000828  466b              MOV      r3,sp
00082a  4632              MOV      r2,r6
00082c  a90d              ADD      r1,sp,#0x34
00082e  4620              MOV      r0,r4
000830  f7fffffe          BL       send_cmd
000834  4605              MOV      r5,r0
;;;620    	if(rs == OS_NO_ERR)//执行完成，但是执行是否成功不一定
000836  b9f5              CBNZ     r5,|L1.2166|
;;;621    	{
;;;622    		if(recv[6] == DRV_RESULT_SUCCESS)
000838  f89d0006          LDRB     r0,[sp,#6]
00083c  2801              CMP      r0,#1
00083e  d118              BNE      |L1.2162|
;;;623    		{
;;;624    			//取得版本号
;;;625    			uint8_t i;
;;;626    			for(i = 0; (i < VER_SIZE) && (recv[8+i] != 0); i++)
000840  2000              MOVS     r0,#0
000842  e00a              B        |L1.2138|
                  |L1.2116|
;;;627    			pt_driverBoard[addr]->version[i] = recv[8+i];//更新版本号
000844  f1000108          ADD      r1,r0,#8
000848  f81d2001          LDRB     r2,[sp,r1]
00084c  4906              LDR      r1,|L1.2152|
00084e  f8511024          LDR      r1,[r1,r4,LSL #2]
000852  3157              ADDS     r1,r1,#0x57
000854  540a              STRB     r2,[r1,r0]
000856  1c41              ADDS     r1,r0,#1              ;626
000858  b2c8              UXTB     r0,r1                 ;626
                  |L1.2138|
00085a  280b              CMP      r0,#0xb               ;626
00085c  da08              BGE      |L1.2160|
00085e  f1000108          ADD      r1,r0,#8              ;626
000862  f81d1001          LDRB     r1,[sp,r1]            ;626
000866  e001              B        |L1.2156|
                  |L1.2152|
                          DCD      pt_driverBoard
                  |L1.2156|
00086c  2900              CMP      r1,#0                 ;626
00086e  d1e9              BNE      |L1.2116|
                  |L1.2160|
;;;628    		}
000870  bf00              NOP      
                  |L1.2162|
;;;629    		rs = recv[6];
000872  f89d5006          LDRB     r5,[sp,#6]
                  |L1.2166|
;;;630    //		driverboard_state_change(addr, NORMAL );
;;;631    	}
;;;632    	else
;;;633    	{
;;;634    //		driverboard_state_change(addr, AB_NORMANL);
;;;635    	}
;;;636    	return rs;
000876  4628              MOV      r0,r5
;;;637    
;;;638    }
000878  b012              ADD      sp,sp,#0x48
00087a  bd70              POP      {r4-r6,pc}
;;;639    
                          ENDP

                  drv_cmd_checkTemp PROC
;;;644    */
;;;645    uint8_t	drv_cmd_checkTemp(uint8_t addr, uint8_t id )
00087c  b5f0              PUSH     {r4-r7,lr}
;;;646    {
00087e  b095              SUB      sp,sp,#0x54
000880  4605              MOV      r5,r0
000882  460c              MOV      r4,r1
;;;647    	
;;;648    	uint8_t rs;
;;;649    	uint8_t cmd[30],cmd_len;
;;;650    	uint8_t recv[50];
;;;651    	
;;;652    	cmd_len = 0; 
000884  2600              MOVS     r6,#0
;;;653    	cmd[cmd_len++] = CMD_CHECK_TEMP;	//电机查询指令
000886  2206              MOVS     r2,#6
000888  4631              MOV      r1,r6
00088a  1c76              ADDS     r6,r6,#1
00088c  a80d              ADD      r0,sp,#0x34
00088e  5442              STRB     r2,[r0,r1]
;;;654    	cmd[cmd_len++] = id;	
000890  4631              MOV      r1,r6
000892  1c76              ADDS     r6,r6,#1
000894  5444              STRB     r4,[r0,r1]
;;;655    
;;;656    	rs = send_cmd(addr, cmd, cmd_len, recv);
000896  466b              MOV      r3,sp
000898  4632              MOV      r2,r6
00089a  a90d              ADD      r1,sp,#0x34
00089c  4628              MOV      r0,r5
00089e  f7fffffe          BL       send_cmd
0008a2  4607              MOV      r7,r0
;;;657    	if(rs == OS_NO_ERR)//执行完成，但是执行是否成功不一定
0008a4  bb17              CBNZ     r7,|L1.2284|
;;;658    	{
;;;659    		if(recv[6] == DRV_RESULT_SUCCESS)
0008a6  f89d0006          LDRB     r0,[sp,#6]
0008aa  2801              CMP      r0,#1
0008ac  d117              BNE      |L1.2270|
;;;660    		{
;;;661    			//更新温度与温度探头状态
;;;662    			//汇报温度探头状态
;;;663    			if( pt_driverBoard[addr]->temp.state[id] != recv[9] )
0008ae  489c              LDR      r0,|L1.2848|
0008b0  f8500025          LDR      r0,[r0,r5,LSL #2]
0008b4  3064              ADDS     r0,r0,#0x64
0008b6  5d00              LDRB     r0,[r0,r4]
0008b8  f89d1009          LDRB     r1,[sp,#9]
0008bc  4288              CMP      r0,r1
0008be  d006              BEQ      |L1.2254|
;;;664    			{
;;;665    				pt_driverBoard[addr]->temp.state[id] = recv[9];//温度状态
0008c0  f89d1009          LDRB     r1,[sp,#9]
0008c4  4896              LDR      r0,|L1.2848|
0008c6  f8500025          LDR      r0,[r0,r5,LSL #2]
0008ca  3064              ADDS     r0,r0,#0x64
0008cc  5501              STRB     r1,[r0,r4]
                  |L1.2254|
;;;666    				//放到温度策略中去汇报
;;;667    //				report_state_change(STATE_TEMP, id + 1, state);//温度探头状态汇报
;;;668    			}
;;;669    			pt_driverBoard[addr]->temp.value[id] = recv[10];//温度值
0008ce  f89d100a          LDRB     r1,[sp,#0xa]
0008d2  4893              LDR      r0,|L1.2848|
0008d4  f8500025          LDR      r0,[r0,r5,LSL #2]
0008d8  3068              ADDS     r0,r0,#0x68
0008da  f8401024          STR      r1,[r0,r4,LSL #2]
                  |L1.2270|
;;;670    		}
;;;671    		rs = recv[6];
0008de  f89d7006          LDRB     r7,[sp,#6]
;;;672    		driverboard_state_change(addr, NORMAL );
0008e2  2101              MOVS     r1,#1
0008e4  4628              MOV      r0,r5
0008e6  f7fffffe          BL       driverboard_state_change
0008ea  e003              B        |L1.2292|
                  |L1.2284|
;;;673    	}
;;;674    	else
;;;675    	{
;;;676    		driverboard_state_change(addr, AB_NORMANL);
0008ec  2100              MOVS     r1,#0
0008ee  4628              MOV      r0,r5
0008f0  f7fffffe          BL       driverboard_state_change
                  |L1.2292|
;;;677    	}
;;;678    	return rs;
0008f4  4638              MOV      r0,r7
;;;679    
;;;680    }
0008f6  b015              ADD      sp,sp,#0x54
0008f8  bdf0              POP      {r4-r7,pc}
;;;681    
                          ENDP

                  drv_cmd_getParam PROC
;;;685    */
;;;686    uint8_t	drv_cmd_getParam(uint8_t addr , uint16_t *dat)
0008fa  b5f0              PUSH     {r4-r7,lr}
;;;687    {
0008fc  b097              SUB      sp,sp,#0x5c
0008fe  4607              MOV      r7,r0
000900  460c              MOV      r4,r1
;;;688    	uint8_t rs;
;;;689    	uint8_t cmd[30],cmd_len;
;;;690    	uint8_t recv[60];
;;;691    	
;;;692    	cmd_len = 0; 
000902  2600              MOVS     r6,#0
;;;693    	cmd[cmd_len++] = CMD_CHECK_PARAM;	//参数查询
000904  220d              MOVS     r2,#0xd
000906  4631              MOV      r1,r6
000908  1c76              ADDS     r6,r6,#1
00090a  a80f              ADD      r0,sp,#0x3c
00090c  5442              STRB     r2,[r0,r1]
;;;694    
;;;695    	rs = send_cmd(addr, cmd, cmd_len, recv);
00090e  466b              MOV      r3,sp
000910  4632              MOV      r2,r6
000912  a90f              ADD      r1,sp,#0x3c
000914  4638              MOV      r0,r7
000916  f7fffffe          BL       send_cmd
00091a  4605              MOV      r5,r0
;;;696    	if(rs == OS_NO_ERR)//执行完成，但是执行是否成功不一定
00091c  b9dd              CBNZ     r5,|L1.2390|
;;;697    	{
;;;698    		if(recv[6] == DRV_RESULT_SUCCESS)
00091e  f89d0006          LDRB     r0,[sp,#6]
000922  2801              CMP      r0,#1
000924  d115              BNE      |L1.2386|
;;;699    		{
;;;700    			uint8_t i;
;;;701    			for(i = 0; i < 13; i++)
000926  2000              MOVS     r0,#0
000928  e010              B        |L1.2380|
                  |L1.2346|
;;;702    			dat[i] = (recv[8+i*2] << 8) | recv[8+i*2+1];//驱动板参数
00092a  2108              MOVS     r1,#8
00092c  eb010140          ADD      r1,r1,r0,LSL #1
000930  1c49              ADDS     r1,r1,#1
000932  f81d1001          LDRB     r1,[sp,r1]
000936  2208              MOVS     r2,#8
000938  eb020240          ADD      r2,r2,r0,LSL #1
00093c  f81d2002          LDRB     r2,[sp,r2]
000940  ea412102          ORR      r1,r1,r2,LSL #8
000944  f8241010          STRH     r1,[r4,r0,LSL #1]
000948  1c41              ADDS     r1,r0,#1              ;701
00094a  b2c8              UXTB     r0,r1                 ;701
                  |L1.2380|
00094c  280d              CMP      r0,#0xd               ;701
00094e  dbec              BLT      |L1.2346|
;;;703    		}
000950  bf00              NOP      
                  |L1.2386|
;;;704    		rs = recv[6];
000952  f89d5006          LDRB     r5,[sp,#6]
                  |L1.2390|
;;;705    //		driverboard_state_change(addr, NORMAL );
;;;706    	}
;;;707    	else
;;;708    	{
;;;709    //		driverboard_state_change(addr, AB_NORMANL);
;;;710    	}
;;;711    	return rs;
000956  4628              MOV      r0,r5
;;;712    
;;;713    }
000958  b017              ADD      sp,sp,#0x5c
00095a  bdf0              POP      {r4-r7,pc}
;;;714    
                          ENDP

                  drv_cmd_setParam PROC
;;;719    */
;;;720    uint8_t	drv_cmd_setParam(uint8_t addr , uint16_t *dat)
00095c  b5f0              PUSH     {r4-r7,lr}
;;;721    {
00095e  b09d              SUB      sp,sp,#0x74
000960  4607              MOV      r7,r0
000962  460d              MOV      r5,r1
;;;722    	uint8_t rs;
;;;723    	uint8_t cmd[60],cmd_len;
;;;724    	uint8_t recv[50];
;;;725    	
;;;726    	cmd_len = 0; 
000964  2400              MOVS     r4,#0
;;;727    	cmd[cmd_len++] = CMD_SET_PARAM;	//参数查询
000966  220c              MOVS     r2,#0xc
000968  4621              MOV      r1,r4
00096a  1c64              ADDS     r4,r4,#1
00096c  a80e              ADD      r0,sp,#0x38
00096e  5442              STRB     r2,[r0,r1]
;;;728    	
;;;729    	//驱动板类型
;;;730    	cmd[cmd_len++] = (dat[0] >> 8)&0xff;
000970  8828              LDRH     r0,[r5,#0]
000972  0a02              LSRS     r2,r0,#8
000974  4621              MOV      r1,r4
000976  1c64              ADDS     r4,r4,#1
000978  a80e              ADD      r0,sp,#0x38
00097a  5442              STRB     r2,[r0,r1]
;;;731    	cmd[cmd_len++] = (dat[0])&0xff;
00097c  782a              LDRB     r2,[r5,#0]
00097e  4621              MOV      r1,r4
000980  1c64              ADDS     r4,r4,#1
000982  5442              STRB     r2,[r0,r1]
;;;732    	
;;;733    	//温度探头类型
;;;734    	cmd[cmd_len++] = (dat[1] >> 8)&0xff;	
000984  8868              LDRH     r0,[r5,#2]
000986  0a02              LSRS     r2,r0,#8
000988  4621              MOV      r1,r4
00098a  1c64              ADDS     r4,r4,#1
00098c  a80e              ADD      r0,sp,#0x38
00098e  5442              STRB     r2,[r0,r1]
;;;735    	cmd[cmd_len++] = dat[1] & 0xff;	
000990  78aa              LDRB     r2,[r5,#2]
000992  4621              MOV      r1,r4
000994  1c64              ADDS     r4,r4,#1
000996  5442              STRB     r2,[r0,r1]
;;;736    	
;;;737    	//启动电流(mA)
;;;738    	cmd[cmd_len++] = (dat[2] >> 8) & 0xff 	;	
000998  88a8              LDRH     r0,[r5,#4]
00099a  0a02              LSRS     r2,r0,#8
00099c  4621              MOV      r1,r4
00099e  1c64              ADDS     r4,r4,#1
0009a0  a80e              ADD      r0,sp,#0x38
0009a2  5442              STRB     r2,[r0,r1]
;;;739    	cmd[cmd_len++] = dat[2] & 0xff;	
0009a4  792a              LDRB     r2,[r5,#4]
0009a6  4621              MOV      r1,r4
0009a8  1c64              ADDS     r4,r4,#1
0009aa  5442              STRB     r2,[r0,r1]
;;;740    	
;;;741    	//短路电流(mA)
;;;742    	cmd[cmd_len++] = (dat[3] >> 8) & 0xff	;
0009ac  88e8              LDRH     r0,[r5,#6]
0009ae  0a02              LSRS     r2,r0,#8
0009b0  4620              MOV      r0,r4
0009b2  1c61              ADDS     r1,r4,#1
0009b4  b2cc              UXTB     r4,r1
0009b6  a90e              ADD      r1,sp,#0x38
0009b8  540a              STRB     r2,[r1,r0]
;;;743    	cmd[cmd_len++] = dat[3] & 0xff	;
0009ba  79aa              LDRB     r2,[r5,#6]
0009bc  4620              MOV      r0,r4
0009be  1c61              ADDS     r1,r4,#1
0009c0  b2cc              UXTB     r4,r1
0009c2  a90e              ADD      r1,sp,#0x38
0009c4  540a              STRB     r2,[r1,r0]
;;;744    
;;;745    	//电机过载电流(mA)
;;;746    	cmd[cmd_len++] = (dat[4] >> 8) & 0xff	;	
0009c6  8928              LDRH     r0,[r5,#8]
0009c8  0a02              LSRS     r2,r0,#8
0009ca  4620              MOV      r0,r4
0009cc  1c61              ADDS     r1,r4,#1
0009ce  b2cc              UXTB     r4,r1
0009d0  a90e              ADD      r1,sp,#0x38
0009d2  540a              STRB     r2,[r1,r0]
;;;747    	cmd[cmd_len++] = dat[4] & 0xff	;	
0009d4  7a2a              LDRB     r2,[r5,#8]
0009d6  4620              MOV      r0,r4
0009d8  1c61              ADDS     r1,r4,#1
0009da  b2cc              UXTB     r4,r1
0009dc  a90e              ADD      r1,sp,#0x38
0009de  540a              STRB     r2,[r1,r0]
;;;748    
;;;749    	//过载允许时间(s)
;;;750    	cmd[cmd_len++] = ((dat[5]) >> 8) & 0xff;	
0009e0  8968              LDRH     r0,[r5,#0xa]
0009e2  0a02              LSRS     r2,r0,#8
0009e4  4620              MOV      r0,r4
0009e6  1c61              ADDS     r1,r4,#1
0009e8  b2cc              UXTB     r4,r1
0009ea  a90e              ADD      r1,sp,#0x38
0009ec  540a              STRB     r2,[r1,r0]
;;;751    	cmd[cmd_len++] = (dat[5]) & 0xff;	
0009ee  7aaa              LDRB     r2,[r5,#0xa]
0009f0  4620              MOV      r0,r4
0009f2  1c61              ADDS     r1,r4,#1
0009f4  b2cc              UXTB     r4,r1
0009f6  a90e              ADD      r1,sp,#0x38
0009f8  540a              STRB     r2,[r1,r0]
;;;752    
;;;753    	//超时未启动时间(s)
;;;754    	cmd[cmd_len++] = ((dat[6]) >> 8) & 0xff	;	
0009fa  89a8              LDRH     r0,[r5,#0xc]
0009fc  0a02              LSRS     r2,r0,#8
0009fe  4620              MOV      r0,r4
000a00  1c61              ADDS     r1,r4,#1
000a02  b2cc              UXTB     r4,r1
000a04  a90e              ADD      r1,sp,#0x38
000a06  540a              STRB     r2,[r1,r0]
;;;755    	cmd[cmd_len++] = (dat[6]) & 0xff	;	
000a08  7b2a              LDRB     r2,[r5,#0xc]
000a0a  4620              MOV      r0,r4
000a0c  1c61              ADDS     r1,r4,#1
000a0e  b2cc              UXTB     r4,r1
000a10  a90e              ADD      r1,sp,#0x38
000a12  540a              STRB     r2,[r1,r0]
;;;756    
;;;757    	//超时未停止时间(s)
;;;758    	cmd[cmd_len++] = ((dat[7]) >> 8) & 0xff ;	
000a14  89e8              LDRH     r0,[r5,#0xe]
000a16  0a02              LSRS     r2,r0,#8
000a18  4620              MOV      r0,r4
000a1a  1c61              ADDS     r1,r4,#1
000a1c  b2cc              UXTB     r4,r1
000a1e  a90e              ADD      r1,sp,#0x38
000a20  540a              STRB     r2,[r1,r0]
;;;759    	cmd[cmd_len++] = (dat[7]) & 0xff	;	
000a22  7baa              LDRB     r2,[r5,#0xe]
000a24  4620              MOV      r0,r4
000a26  1c61              ADDS     r1,r4,#1
000a28  b2cc              UXTB     r4,r1
000a2a  a90e              ADD      r1,sp,#0x38
000a2c  540a              STRB     r2,[r1,r0]
;;;760    	
;;;761    	//电机停止延时(ms)
;;;762    	cmd[cmd_len++] = (dat[8]	>> 8) & 0xff	;	
000a2e  8a28              LDRH     r0,[r5,#0x10]
000a30  0a02              LSRS     r2,r0,#8
000a32  4620              MOV      r0,r4
000a34  1c61              ADDS     r1,r4,#1
000a36  b2cc              UXTB     r4,r1
000a38  a90e              ADD      r1,sp,#0x38
000a3a  540a              STRB     r2,[r1,r0]
;;;763    	cmd[cmd_len++] = dat[8] & 0xff	;	
000a3c  7c2a              LDRB     r2,[r5,#0x10]
000a3e  4620              MOV      r0,r4
000a40  1c61              ADDS     r1,r4,#1
000a42  b2cc              UXTB     r4,r1
000a44  a90e              ADD      r1,sp,#0x38
000a46  540a              STRB     r2,[r1,r0]
;;;764    
;;;765    	//出货信号检测次数
;;;766    	cmd[cmd_len++] = (dat[9] >> 8) & 0xff ;	
000a48  8a68              LDRH     r0,[r5,#0x12]
000a4a  0a02              LSRS     r2,r0,#8
000a4c  4620              MOV      r0,r4
000a4e  1c61              ADDS     r1,r4,#1
000a50  b2cc              UXTB     r4,r1
000a52  a90e              ADD      r1,sp,#0x38
000a54  540a              STRB     r2,[r1,r0]
;;;767    	cmd[cmd_len++] = dat[9] & 0XFF;
000a56  7caa              LDRB     r2,[r5,#0x12]
000a58  4620              MOV      r0,r4
000a5a  1c61              ADDS     r1,r4,#1
000a5c  b2cc              UXTB     r4,r1
000a5e  a90e              ADD      r1,sp,#0x38
000a60  540a              STRB     r2,[r1,r0]
;;;768    	
;;;769    	//出货信号检测间隔(us)
;;;770    	cmd[cmd_len++] = (dat[10] >> 8) & 0xff;	
000a62  8aa8              LDRH     r0,[r5,#0x14]
000a64  0a02              LSRS     r2,r0,#8
000a66  4620              MOV      r0,r4
000a68  1c61              ADDS     r1,r4,#1
000a6a  b2cc              UXTB     r4,r1
000a6c  a90e              ADD      r1,sp,#0x38
000a6e  540a              STRB     r2,[r1,r0]
;;;771    	cmd[cmd_len++] = dat[10] & 0XFF;	
000a70  7d2a              LDRB     r2,[r5,#0x14]
000a72  4620              MOV      r0,r4
000a74  1c61              ADDS     r1,r4,#1
000a76  b2cc              UXTB     r4,r1
000a78  a90e              ADD      r1,sp,#0x38
000a7a  540a              STRB     r2,[r1,r0]
;;;772    	
;;;773    	//查询信号检测次数
;;;774    	cmd[cmd_len++] = (dat[11] >> 8) & 0xff ;	
000a7c  8ae8              LDRH     r0,[r5,#0x16]
000a7e  0a02              LSRS     r2,r0,#8
000a80  4620              MOV      r0,r4
000a82  1c61              ADDS     r1,r4,#1
000a84  b2cc              UXTB     r4,r1
000a86  a90e              ADD      r1,sp,#0x38
000a88  540a              STRB     r2,[r1,r0]
;;;775    	cmd[cmd_len++] = dat[11] & 0XFF;
000a8a  7daa              LDRB     r2,[r5,#0x16]
000a8c  4620              MOV      r0,r4
000a8e  1c61              ADDS     r1,r4,#1
000a90  b2cc              UXTB     r4,r1
000a92  a90e              ADD      r1,sp,#0x38
000a94  540a              STRB     r2,[r1,r0]
;;;776    	
;;;777    	//查询信号检测间隔(us)
;;;778    	cmd[cmd_len++] = (dat[12] >> 8) & 0xff;	
000a96  8b28              LDRH     r0,[r5,#0x18]
000a98  0a02              LSRS     r2,r0,#8
000a9a  4620              MOV      r0,r4
000a9c  1c61              ADDS     r1,r4,#1
000a9e  b2cc              UXTB     r4,r1
000aa0  a90e              ADD      r1,sp,#0x38
000aa2  540a              STRB     r2,[r1,r0]
;;;779    	cmd[cmd_len++] = dat[12] & 0XFF;	
000aa4  7e2a              LDRB     r2,[r5,#0x18]
000aa6  4620              MOV      r0,r4
000aa8  1c61              ADDS     r1,r4,#1
000aaa  b2cc              UXTB     r4,r1
000aac  a90e              ADD      r1,sp,#0x38
000aae  540a              STRB     r2,[r1,r0]
;;;780    	rs = send_cmd(addr, cmd, cmd_len, recv);
000ab0  ab01              ADD      r3,sp,#4
000ab2  4622              MOV      r2,r4
000ab4  4638              MOV      r0,r7
000ab6  f7fffffe          BL       send_cmd
000aba  4606              MOV      r6,r0
;;;781    	if(rs == OS_NO_ERR)//执行完成，但是执行是否成功不一定
000abc  b90e              CBNZ     r6,|L1.2754|
;;;782    	{
;;;783    		if(recv[6] == DRV_RESULT_SUCCESS)
;;;784    		{
;;;785    		}
;;;786    		rs = recv[6];
000abe  f89d600a          LDRB     r6,[sp,#0xa]
                  |L1.2754|
;;;787    //		driverboard_state_change(addr, NORMAL );
;;;788    	}
;;;789    	else
;;;790    	{
;;;791    //		driverboard_state_change(addr, AB_NORMANL);
;;;792    	}
;;;793    	return rs;
000ac2  4630              MOV      r0,r6
;;;794    
;;;795    }
000ac4  b01d              ADD      sp,sp,#0x74
000ac6  bdf0              POP      {r4-r7,pc}
;;;796    
                          ENDP

                  drv_cmd_resetParam PROC
;;;801    */
;;;802    uint8_t	drv_cmd_resetParam(uint8_t addr)
000ac8  b570              PUSH     {r4-r6,lr}
;;;803    {
000aca  b08e              SUB      sp,sp,#0x38
000acc  4606              MOV      r6,r0
;;;804    	uint8_t rs;
;;;805    	uint8_t cmd[30],cmd_len;
;;;806    	uint8_t recv[20];
;;;807    	
;;;808    	cmd_len = 0; 
000ace  2500              MOVS     r5,#0
;;;809    	cmd[cmd_len++] = CMD_RESET_PARAM;	//参数复位
000ad0  220e              MOVS     r2,#0xe
000ad2  4629              MOV      r1,r5
000ad4  1c6d              ADDS     r5,r5,#1
000ad6  a806              ADD      r0,sp,#0x18
000ad8  5442              STRB     r2,[r0,r1]
;;;810    
;;;811    	rs = send_cmd(addr, cmd, cmd_len, recv);
000ada  ab01              ADD      r3,sp,#4
000adc  462a              MOV      r2,r5
000ade  a906              ADD      r1,sp,#0x18
000ae0  4630              MOV      r0,r6
000ae2  f7fffffe          BL       send_cmd
000ae6  4604              MOV      r4,r0
;;;812    	if(rs == OS_NO_ERR)//执行完成，但是执行是否成功不一定
000ae8  b90c              CBNZ     r4,|L1.2798|
;;;813    	{
;;;814    		rs = recv[6];
000aea  f89d400a          LDRB     r4,[sp,#0xa]
                  |L1.2798|
;;;815    //		driverboard_state_change(addr, NORMAL );
;;;816    	}
;;;817    	else
;;;818    	{
;;;819    //		driverboard_state_change(addr, AB_NORMANL);
;;;820    	}
;;;821    	return rs;
000aee  4620              MOV      r0,r4
;;;822    
;;;823    }
000af0  b00e              ADD      sp,sp,#0x38
000af2  bd70              POP      {r4-r6,pc}
;;;824    /*
                          ENDP

                  drv_cmd_reset PROC
;;;828    */
;;;829    uint8_t drv_cmd_reset(uint8_t addr)
000af4  b570              PUSH     {r4-r6,lr}
;;;830    {
000af6  b08e              SUB      sp,sp,#0x38
000af8  4606              MOV      r6,r0
;;;831    	uint8_t rs;
;;;832    	uint8_t cmd[30],cmd_len;
;;;833    	uint8_t recv[20];
;;;834    	
;;;835    	cmd_len = 0; 
000afa  2500              MOVS     r5,#0
;;;836    	cmd[cmd_len++] = CMD_RESET_DRIVERBOARD;	//参数查询
000afc  220f              MOVS     r2,#0xf
000afe  4629              MOV      r1,r5
000b00  1c6d              ADDS     r5,r5,#1
000b02  a806              ADD      r0,sp,#0x18
000b04  5442              STRB     r2,[r0,r1]
;;;837    
;;;838    	rs = send_cmd(addr, cmd, cmd_len, recv);
000b06  ab01              ADD      r3,sp,#4
000b08  462a              MOV      r2,r5
000b0a  a906              ADD      r1,sp,#0x18
000b0c  4630              MOV      r0,r6
000b0e  f7fffffe          BL       send_cmd
000b12  4604              MOV      r4,r0
;;;839    	if(rs == OS_NO_ERR)//执行完成，但是执行是否成功不一定
000b14  b90c              CBNZ     r4,|L1.2842|
;;;840    	{
;;;841    		if(recv[6] == DRV_RESULT_SUCCESS)
;;;842    		{
;;;843    		}
;;;844    		rs = recv[6];
000b16  f89d400a          LDRB     r4,[sp,#0xa]
                  |L1.2842|
;;;845    //		driverboard_state_change(addr, NORMAL );
;;;846    	}
;;;847    	else
;;;848    	{
;;;849    //		driverboard_state_change(addr, AB_NORMANL);
;;;850    	}
;;;851    	return rs;
000b1a  4620              MOV      r0,r4
;;;852    }
000b1c  b00e              ADD      sp,sp,#0x38
000b1e  bd70              POP      {r4-r6,pc}
;;;853    
                          ENDP

                  |L1.2848|
                          DCD      pt_driverBoard

;*** Start embedded assembler ***

#line 1 "..\\USR\\DriverBoard\\drv.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___5_drv_c_c989ae75____REV16|
#line 129 "C:\\Keil_v5\\ARM\\CMSIS\\Include\\core_cmInstr.h"
|__asm___5_drv_c_c989ae75____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___5_drv_c_c989ae75____REVSH|
#line 144
|__asm___5_drv_c_c989ae75____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
